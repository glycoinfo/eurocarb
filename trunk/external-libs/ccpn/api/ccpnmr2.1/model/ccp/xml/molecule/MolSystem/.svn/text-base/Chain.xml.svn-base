<?xml version='1.0'?>
<!--
#######################################################################

CCPN Data Model version 2.0.b3

Autogenerated by XmlModelIo revision 1.17 on ?
  from data model element ccp.molecule.MolSystem.Chain revision ?

#######################################################################
======================COPYRIGHT/LICENSE START==========================

Chain.xml: xmlmodel model for CCPN data model, MetaClass ccp.molecule.MolSystem.Chain

Copyright (C) 2007  (CCPN Project)

=======================================================================

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.
 
A copy of this license can be found in ../../../../../license/LGPL.license
 
This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
Lesser General Public License for more details.
 
You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA


======================COPYRIGHT/LICENSE END============================

for further information, please contact :

- CCPN website (http://www.ccpn.ac.uk/)

- email: ccpn@bioc.cam.ac.uk

=======================================================================

If you are using this software for academic purposes, we suggest
quoting the following references:

===========================REFERENCE START=============================
Rasmus H. Fogh, Wayne Boucher, Wim F. Vranken, Anne
Pajon, Tim J. Stevens, T.N. Bhat, John Westbrook, John M.C. Ionides and
Ernest D. Laue (2005). A framework for scientific data modeling and automated
software development. Bioinformatics 21, 1678-1684.


This file was generated with the Memops software generation framework,
and contains original contributions embedded in the framework

===========================REFERENCE END===============================
-->

<MetaClass name="Chain"
 guid="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00024"
 container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00022"
 isAbstract="false" isImplicit="false" isLeaf="false" isRoot="false"
 isSingleton="false" partitionsChildren="false" visibility="public_vis">
  <documentation>A specific instance of a given molecule in a specific environment. E.g. one of the chains for a homodimer.

The Chain corresponds to a specific Molecule, but may differ in some ways. 

Creating a Chain automatically creates the Residue and Atom objects corresponding to it. </documentation>
  <keyNames>
    <item>code</item>
  </keyNames>
  <supertypes>
    <item>www.ccpn.ac.uk_Fogh_2006-09-14-16:28:57_00005</item>
  </supertypes>
  <constructorCodeStubs>
    <item tag="java">if (getMolecule() != null) {
  // if not it is an error, but it fails more gracefully this way

  // make Residues
  for (ccp.api.molecule.Molecule.MolResidue molResidue: getMolecule().getMolResidues()) {
    java.util.HashMap&lt;java.lang.String, java.lang.Object&gt; atls = new
java.util.HashMap&lt;java.lang.String, java.lang.Object&gt;();
    atls.put("seqId", molResidue.getSerial());
    atls.put("seqCode", molResidue.getSeqCode());
    atls.put("seqInsertCode", molResidue.getSeqInsertCode());
    atls.put("linking", molResidue.getLinking());
    atls.put("descriptor", molResidue.getDescriptor());
  
    newResidue(atls);
  }

  // make ChainFragments
  createChainFragments();
}</item>
    <item tag="python">molecule = self.molecule
if molecule:
  # this should never be null, but it fails more gracefully this way

  # make Residues
  for molResidue in self.molecule.molResidues:
    Residue(self, seqId=molResidue.serial,seqCode=molResidue.seqCode, seqInsertCode=molResidue.seqInsertCode, linking=molResidue.linking, descriptor=molResidue.descriptor )

  # make ChainFragments
  self.createChainFragments()</item>
  </constructorCodeStubs>
  <taggedValues>
    <item tag="repositoryId">$Id: Chain.xml,v 1.45.2.10 2009/09/14 14:45:24 wimvranken Exp $</item>
    <item tag="repositoryTag">$Name: release_2_1_0_2 $</item>
  </taggedValues>

  <!-- Start constraints for <MetaClass: ccp.molecule.MolSystem.Chain>: -->
  <MetaConstraint name="seqCode_and_seqInsertCode_form_secondary_key_for_residues"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00025"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00024"
   isImplicit="false">
    <codeStubs>
      <item tag="java">java.util.Set&lt;java.lang.String&gt; dd = new java.util.HashSet&lt;java.lang.String&gt;();
int nn = 0;
for (ccp.api.molecule.MolSystem.Residue res: getResidues()) {
  java.lang.String ss = res.getSeqCode() + ":" + res.getSeqInsertCode();
  dd.add(ss);
  nn++;
}
isValid = (dd.size() == nn);
</item>
      <item tag="python">ll = self.residues
aset = frozenset((res.seqCode, res.seqInsertCode) for res in ll)
isValid = (len(aset) == len(ll))
</item>
    </codeStubs>
  </MetaConstraint>
  <!-- End constraints for <MetaClass: ccp.molecule.MolSystem.Chain>: -->


  <MetaRole name="chainFragments"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:32_00001"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00024"
   baseName="chainFragment" changeability="changeable" hicard="-1"
   hierarchy="child" isAbstract="false" isAutomatic="false" isDerived="false"
   isImplementation="false" isImplicit="false" isOrdered="false" isUnique="true"
   locard="0" noDeleteIfSet="false" partitionsChildren="false"
   scope="instance_level" visibility="public_vis">
    <otherRole>www.ccpn.ac.uk_Fogh_2006-08-16-18:23:31_00039</otherRole>
    <valueType>www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00036</valueType>
  </MetaRole>

  <MetaRole name="chainInteractions"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:32_00021"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00024"
   baseName="chainInteraction" changeability="changeable" hicard="-1"
   isAbstract="false" isAutomatic="false" isDerived="false"
   isImplementation="false" isImplicit="false" isOrdered="false" isUnique="true"
   locard="0" noDeleteIfSet="false" partitionsChildren="false"
   scope="instance_level" visibility="public_vis">
    <documentation>An interaction of a given type between a pair  of Chains</documentation>
    <otherRole>www.ccpn.ac.uk_Fogh_2006-08-16-18:23:32_00022</otherRole>
    <valueType>www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00026</valueType>
  </MetaRole>

  <MetaAttribute name="chemExchangeState"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:32_00009"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00024"
   baseName="chemExchangeState" changeability="changeable" hicard="1"
   isAbstract="false" isAutomatic="false" isDerived="false"
   isImplementation="false" isImplicit="false" isOrdered="false" isUnique="true"
   locard="0" scope="instance_level" visibility="public_vis">
    <documentation>for NMR spectroscopy. Short text describing the chemical exchange state.</documentation>
    <valueType>www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00033</valueType>
  </MetaAttribute>

  <MetaAttribute name="code"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:32_00002"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00024"
   baseName="code" changeability="frozen" hicard="1" isAbstract="false"
   isAutomatic="false" isDerived="false" isImplementation="false"
   isImplicit="false" isOrdered="false" isUnique="true" locard="1"
   scope="instance_level" visibility="public_vis">
    <documentation>ChainCode - key for the Chain class. Should ideally be a single letter, if possible.</documentation>
    <valueType>www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00033</valueType>
  </MetaAttribute>

  <MetaAttribute name="conformationalIsomer"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:32_00008"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00024"
   baseName="conformationalIsomer" changeability="changeable" hicard="1"
   isAbstract="false" isAutomatic="false" isDerived="false"
   isImplementation="false" isImplicit="false" isOrdered="false" isUnique="true"
   locard="0" scope="instance_level" visibility="public_vis">
    <documentation>short text describing the conformational isomer</documentation>
    <valueType>www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00033</valueType>
  </MetaAttribute>

  <MetaOperation name="createChainFragments"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:32_00020"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00024"
   isAbstract="false" isImplicit="false" isQuery="false" opType="other"
   scope="instance_level" visibility="public_vis">
    <documentation>Creates ChainFragments for all Residues that do not already have them, while making no modification to existing ChainFragments or their contents. Is called automatically on Chain creation. Any program that modifies the automatically created ChainFragments should call this function at the end, to ensure that every Residue belongs to a  ChainFragment. 

The function  divides the residues in four molTypes: protein, carbohydrate, DNA/RNA ,and other. Within each molType, stretches of linear polymer of two or more residues are identified without regard to the seqId value of the residues. These are put in separate ChainFragments, with the residues ordered by sequence rather than seqID. Subsequently,  residues not part of a linear polymer are grouped in the largest directly connected fragments of uniform molType. Finally, for fragments of type DNA/RNA the molType is set to DNA or RNA if this is the only molType that happens to be present, to DNA/RNA otherwise.</documentation>
    <target>www.ccpn.ac.uk_Fogh_2006-08-16-18:23:32_00020</target>
    <codeStubs>
      <item tag="java">// global set up
java.lang.String carbo = "carbohydrate";
java.lang.String dnarna = "DNA/RNA";
java.lang.String other = "other";
java.lang.String prevtag = "prev";
java.lang.String nexttag = "next";
java.lang.String molTypes[] = {"protein", carbo, other, dnarna};
java.util.Map&lt;java.lang.String, java.util.Map&lt;ccp.api.molecule.Molecule.MolResidue, ccp.api.molecule.MolSystem.Residue&gt;&gt; topdict = new
java.util.HashMap&lt;java.lang.String, java.util.Map&lt;ccp.api.molecule.Molecule.MolResidue, ccp.api.molecule.MolSystem.Residue&gt;&gt;();
for (int ii = 0; ii &lt; molTypes.length; ii++)
  topdict.put(molTypes[ii], new java.util.HashMap&lt;ccp.api.molecule.Molecule.MolResidue, ccp.api.molecule.MolSystem.Residue&gt;());

// partition residues by molType
for (ccp.api.molecule.Molecule.MolResidue molres: getMolecule().getMolResidues()) {
  ccp.api.molecule.MolSystem.Residue res = findFirstResidue("seqId", molres.getSerial());
  if (res.getChainFragment() == null) {
    java.lang.String molType = molres.getMolType();
    if (!topdict.containsKey(molType))
      molType = other;
    java.util.Map&lt;ccp.api.molecule.Molecule.MolResidue, ccp.api.molecule.MolSystem.Residue&gt; dd = topdict.get(molType);
    dd.put(molres, res);
  }
}

// analyse link graph and make ChainFragments
for (int ii = 0; ii &lt; molTypes.length; ii++) {
  java.lang.String molType = molTypes[ii];
  java.util.Map&lt;ccp.api.molecule.Molecule.MolResidue, ccp.api.molecule.MolSystem.Residue&gt; dd = topdict.get(molType);
  java.util.Map&lt;ccp.api.molecule.Molecule.MolResidue, ccp.api.molecule.MolSystem.Residue&gt; dd2;
  if (carbo.equals(molType)) {
    dd2 = dd;
  } else {
    // make linear polymer fragments
    dd2 = new java.util.HashMap&lt;ccp.api.molecule.Molecule.MolResidue, ccp.api.molecule.MolSystem.Residue&gt;();
    while (!dd.isEmpty()) {
      // set up
      // This hack is a replacement for dd.popitem(), i.e. it gets a random key
      ccp.api.molecule.Molecule.MolResidue molres = dd.keySet().iterator().next();
      ccp.api.molecule.MolSystem.Residue res0 = dd.get(molres);
      ccp.api.molecule.MolSystem.Residue res = res0;
      ccp.api.molecule.Molecule.MolResidue mr = molres;
      java.util.List&lt;ccp.api.molecule.MolSystem.Residue&gt; residues = new java.util.ArrayList&lt;ccp.api.molecule.MolSystem.Residue&gt;();
      residues.add(res);
      java.lang.String tag1 = prevtag;
      java.lang.String tag2 = nexttag;
      boolean firstTime = true;

      while (true) {
        // find linear polymer linked molResidue, and add residue to residues list
        ccp.api.molecule.Molecule.MolResLinkEnd linkEnd = mr.findFirstMolResLinkEnd("linkCode", tag1);
        if (linkEnd != null) {
          ccp.api.molecule.Molecule.MolResLink ml = linkEnd.getMolResLink();
          if (ml != null) {
            java.util.Set&lt;ccp.api.molecule.Molecule.MolResLinkEnd&gt; ll = ml.getMolResLinkEnds();
            java.util.Iterator&lt;ccp.api.molecule.Molecule.MolResLinkEnd&gt; lliter = ll.iterator();
            ccp.api.molecule.Molecule.MolResLinkEnd le = lliter.next();
            if (le == linkEnd)
              le = lliter.next();
            if (tag2.equals(le.getLinkCode())) {
              mr = le.getMolResidue();
              res = dd.get(mr);
              if (res != null) {
                dd.remove(mr);
                residues.add(res);
                continue;
              }
            }
          }
        }

        // If we get here, we have reached the end of the polymer chain
        if (firstTime) {
          // now start again at molres, going in opposite direction
          firstTime = false;
          tag1 = nexttag;
          tag2 = prevtag;
          java.util.Collections.reverse(residues);
          mr = molres;

        } else {
          // both ends done, finalise
          if (residues.size() &lt; 2) {
            // no linear polymer found - put molres in new dictionary
            dd2.put(molres, res0);
          } else {
            java.lang.String mt = molType;
            if (dnarna.equals(molType)) {
              java.util.Iterator&lt;ccp.api.molecule.MolSystem.Residue&gt; iter = residues.iterator();
              mt = iter.next().getMolType();
              while (iter.hasNext()) {
                ccp.api.molecule.MolSystem.Residue rr = iter.next();
                if (!mt.equals(rr.getMolType())) {
                  mt = dnarna;
                  break;
                }
              }
            }
              
            ccp.api.molecule.MolSystem.ChainFragment cf = newChainFragment(true, mt);                
            cf.setResidues(residues);
          }   
          break;
        }       
      }         
    }         
  }         
          
  // make fragments that are not linear polymers
  while (!dd2.isEmpty()) {
    // set up 
    // This hack is a replacement for dd2.popitem(), i.e. it gets a random key
    ccp.api.molecule.Molecule.MolResidue mres = dd2.keySet().iterator().next();
    ccp.api.molecule.MolSystem.Residue res = dd2.get(mres);
    java.util.List&lt;ccp.api.molecule.Molecule.MolResidue&gt; mrs = new java.util.ArrayList&lt;ccp.api.molecule.Molecule.MolResidue&gt;();
    mrs.add(mres);
    java.util.List&lt;ccp.api.molecule.MolSystem.Residue&gt; residues = new java.util.ArrayList&lt;ccp.api.molecule.MolSystem.Residue&gt;();
    residues.add(res);
          
    for (ccp.api.molecule.Molecule.MolResidue molres: mrs) {
      for (ccp.api.molecule.Molecule.MolResLinkEnd linkEnd: molres.getMolResLinkEnds()) {          
        ccp.api.molecule.Molecule.MolResLink ml = linkEnd.getMolResLink();
        if (ml != null) {
          java.util.Set&lt;ccp.api.molecule.Molecule.MolResLinkEnd&gt; ll = ml.getMolResLinkEnds();
          java.util.Iterator&lt;ccp.api.molecule.Molecule.MolResLinkEnd&gt; lliter = ll.iterator();        
          ccp.api.molecule.Molecule.MolResLinkEnd le = lliter.next();
          if (le == linkEnd)
            le = lliter.next();
          ccp.api.molecule.Molecule.MolResidue mr = le.getMolResidue();
          res = dd.get(mr);
          if (res != null) {
            dd.remove(mr);
            mrs.add(mr);
            residues.add(res);
          }
        }
      }
    }

    java.lang.String mt = molType;
    if (dnarna.equals(molType)) {
      java.util.Iterator&lt;ccp.api.molecule.MolSystem.Residue&gt; iter = residues.iterator();
      mt = iter.next().getMolType();
      while (iter.hasNext()) {
        ccp.api.molecule.MolSystem.Residue rr = iter.next();
        if (!mt.equals(rr.getMolType())) {
          mt = dnarna;
          break;
        }
      }
    }

    ccp.api.molecule.MolSystem.ChainFragment cf = newChainFragment(true, mt);
    cf.setResidues(residues);
  }
}</item>
      <item tag="python"># global set up
dnarna = 'DNA/RNA'
topdict = {'protein':{},  'carbohydrate':{}, 'other':{}, dnarna:{}}
linearTags = ('prev', 'next')

#partition residues by molType
for molres in self.molecule.molResidues:
  res = self.findFirstResidue(seqId=molres.serial)
  if res is not None and not res.chainFragment:
    molType = molres.molType
    dd = topdict.get(molType)
    if dd is None:
      dd = topdict['other']
    dd[molres] = res

# analyse link graph and make ChainFragments
for (molType, dd) in topdict.items():
    
  if molType == 'carbohydrate':
    dd2 = dd

  else:
    # make linear polymer fragments
    dd2 = {}
    while dd:
  
      # set up
      (molres, res0) = dd.popitem()
      res = res0
      mr = molres
      residues = [res]
      (tag1, tag2) = linearTags
      firstTime = True
    
      while True:
        # find linear polymer linked molResidue, and add residue to residues list
        linkEnd = mr.findFirstMolResLinkEnd(linkCode=tag1)
        if linkEnd:
          ml = linkEnd.molResLink
          if ml:
            (le, le2) = ml.molResLinkEnds
            if le is linkEnd:
              le = le2
            if le.linkCode == tag2:
              mr = le.molResidue
              res = dd.get(mr)
              if res is not None:
                del dd[mr]
                residues.append(res)
                continue
 
        # If we get here, we have reached the end of the polymer chain
        if firstTime:
          # now start again at molres, going in opposite direction
          firstTime = False
          (tag1, tag2) = (tag2, tag1)
          residues.reverse()
          mr = molres
        
        else:
          # both ends done, finalise
          if len(residues) &lt; 2:
            # no linear polymer found - put molres in new dictionary
            dd2[molres] = res0
          else:
            if molType == dnarna:
              mt = residues[0].molType
              for rr in residues[1:]:
                if rr.molType != mt:
                  mt = 'DNA/RNA'
                  break
            else:
              mt = molType
            
            ChainFragment(
             self, molType=mt, isLinearPolymer=True, residues=residues
            )
          #
          break
  
  # make fragments that are not linear polyumers
  while dd2:
    # set up
    (molres, res) = dd2.popitem()
    mrs = [molres]
    residues = [res]
    
    for molres in mrs:
      for linkEnd in molres.molResLinkEnds:
        ml = linkEnd.molResLink
        if ml:
          (le, le2) = ml.molResLinkEnds
          if le is linkEnd:
            le = le2
          mr = le.molResidue
          res = dd2.get(mr)
          if res is not None:
            del dd2[mr]
            mrs.append(mr)
            residues.append(res)
    
    if molType == dnarna:
      mt = residues[0].molType
      for rr in residues[1:]:
        if rr.molType != mt:
          mt = 'DNA/RNA'
          break
    else:
      mt = molType
      
    ChainFragment(
     self,molType=mt, isLinearPolymer=False, residues=residues
    )</item>
    </codeStubs>
  </MetaOperation>

  <MetaAttribute name="details"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:32_00013"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00024"
   baseName="details" changeability="changeable" hicard="1" isAbstract="false"
   isAutomatic="false" isDerived="false" isImplementation="false"
   isImplicit="false" isOrdered="false" isUnique="true" locard="0"
   scope="instance_level" visibility="public_vis">
    <documentation>Free text, for notes, explanatory comments, etc.</documentation>
    <valueType>www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00036</valueType>
  </MetaAttribute>

  <MetaAttribute name="empiricalFormula"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:32_00010"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00024"
   baseName="empiricalFormula" changeability="frozen" hicard="1"
   isAbstract="false" isAutomatic="false" isDerived="true"
   isImplementation="false" isImplicit="false" isOrdered="false" isUnique="true"
   locard="1" scope="instance_level" visibility="public_vis">
    <documentation>empirical molecular formula for Chain (may be different from that of the corresponding molecule</documentation>
    <valueType>www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00033</valueType>
  </MetaAttribute>

  <MetaAttribute name="formalCharge"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:32_00012"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00024"
   baseName="formalCharge" changeability="frozen" hicard="1" isAbstract="false"
   isAutomatic="false" isDerived="true" isImplementation="false"
   isImplicit="false" isOrdered="false" isUnique="true" locard="1"
   scope="instance_level" visibility="public_vis">
    <documentation>formal charge of Chain (may differ from that of the corresponding molecule).</documentation>
    <valueType>www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00032</valueType>
  </MetaAttribute>

  <MetaOperation name="getEmpiricalFormula"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:32_00014"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00024"
   isAbstract="false" isImplicit="false" isQuery="true" opType="get"
   scope="instance_level" visibility="public_vis">
    <documentation>getter for derived attribute empiricalFormula</documentation>
    <target>www.ccpn.ac.uk_Fogh_2006-08-16-18:23:32_00010</target>
    <codeStubs>
      <item tag="java">// get formula dictionary 
java.util.Map&lt;java.lang.String, java.lang.Integer&gt; dd = new java.util.HashMap&lt;java.lang.String, java.lang.Integer&gt;();
for (ccp.api.molecule.MolSystem.Residue mr: getResidues()) {
  for (ccp.api.molecule.ChemComp.AbstractChemAtom ca: mr.getChemCompVar().getChemAtoms()) {
    if (ca instanceof ccp.api.molecule.ChemComp.ChemAtom) {
      java.lang.String ss = ((ccp.api.molecule.ChemComp.ChemAtom) ca).getElementSymbol();
      java.lang.Integer ii = dd.get(ss);
      if (ii == null)
        dd.put(ss, 1);
      else
        dd.put(ss, ii+1);
    }
  }
}

// generate formula
java.lang.StringBuffer ll = new java.lang.StringBuffer(2*dd.size());
java.lang.String[] es = { "C", "H" };
for (int kk = 0; kk &lt; es.length; kk++) {
  java.lang.String ss = es[kk];
  java.lang.Integer ii = dd.remove(ss);
  if (ii != null) {
    ll.append(ss);
    ll.append(ii);
  }
}

java.util.List&lt;java.lang.String&gt; keys = java.util.Collections.list(java.util.Collections.enumeration(dd.keySet()));
java.util.Collections.sort(keys);
for (java.lang.String ss: keys) {
  java.lang.Integer ii = dd.get(ss);
  ll.append(ss);
  ll.append(ii);
}

result = ll.toString();</item>
      <item tag="python"># get formula dictionary
dd = {}
clazz = ccp.api.molecule.ChemComp.ChemAtom
for mr in self.residues:
  for ss in (ca.elementSymbol for ca in mr.chemCompVar.chemAtoms if isinstance(ca, clazz)):
    ii = dd.get(ss)
    if ii is None:
      dd[ss] = 1
    else:
      dd[ss] = ii + 1

# generate formula
ll = [None] * (len(dd)*2)
next = 0
for ss in ('C', 'H'):
  ii = dd.get(ss)
  if ii is not None:
    ll[next] = ss
    ll[next+1] = str(ii)
    del dd[ss]
    next = next + 2

items = dd.items()
items.sort()
for (ss, ii) in items:
  ll[next] = ss
  ll[next+1] = str(ii)
  next = next + 2
#
result = ''.join(ll) or None</item>
    </codeStubs>
  </MetaOperation>

  <MetaOperation name="getFormalCharge"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:32_00018"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00024"
   isAbstract="false" isImplicit="false" isQuery="true" opType="get"
   scope="instance_level" visibility="public_vis">
    <documentation>getter for derived attribute formalCharge</documentation>
    <target>www.ccpn.ac.uk_Fogh_2006-08-16-18:23:32_00012</target>
    <codeStubs>
      <item tag="java">result = 0;
for (ccp.api.molecule.MolSystem.Residue rr: getResidues())
  result += rr.getChemCompVar().getFormalCharge();</item>
      <item tag="python">result = sum(x.chemCompVar.formalCharge for x in self.residues)</item>
    </codeStubs>
  </MetaOperation>

  <MetaOperation name="getMolecularMass"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:32_00016"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00024"
   isAbstract="false" isImplicit="false" isQuery="true" opType="get"
   scope="instance_level" visibility="public_vis">
    <documentation>getter for derived attribute molecularMass</documentation>
    <target>www.ccpn.ac.uk_Fogh_2006-08-16-18:23:32_00011</target>
    <codeStubs>
      <item tag="java">// get formula dictionary 
java.util.Map&lt;java.lang.String, java.lang.Integer&gt; dd = new java.util.HashMap&lt;java.lang.String, java.lang.Integer&gt;();
for (ccp.api.molecule.MolSystem.Residue mr: getResidues()) {
  for (ccp.api.molecule.ChemComp.AbstractChemAtom ca: mr.getChemCompVar().getChemAtoms()) {
    if (ca instanceof ccp.api.molecule.ChemComp.ChemAtom) {
      java.lang.String ss = ((ccp.api.molecule.ChemComp.ChemAtom) ca).getElementSymbol();
      java.lang.Integer ii = dd.get(ss);
      if (ii == null)
        dd.put(ss, 1);
      else
        dd.put(ss, ii+1);
    }
  }
}

// calculate mass
ccp.api.molecule.ChemElement.ChemElementStore xx = getRoot().getCurrentChemElementStore();
result = 0.0f;
for (java.lang.String ss: dd.keySet()) {
  java.lang.Integer ii = dd.get(ss);
  result += ii * xx.findFirstChemElement("symbol", ss).getMass();
}</item>
      <item tag="python"># get formula dictionary
dd = {}
clazz = ccp.api.molecule.ChemComp.ChemAtom
for mr in self.residues:
  for ss in (ca.elementSymbol for ca in mr.chemCompVar.chemAtoms if isinstance(ca, clazz)):
    ii = dd.get(ss)
    if ii is None:
      dd[ss] = 1
    else:
      dd[ss] = ii + 1

# calculate mass
xx = self.root.currentChemElementStore
result = sum(ii * xx.findFirstChemElement(symbol=ss).mass for (ss, ii) in dd.items())</item>
    </codeStubs>
  </MetaOperation>

  <MetaAttribute name="magnEquivalenceCode"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:32_00006"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00024"
   baseName="magnEquivalenceCode" changeability="changeable" hicard="1"
   isAbstract="false" isAutomatic="false" isDerived="false"
   isImplementation="false" isImplicit="false" isOrdered="false" isUnique="true"
   locard="0" scope="instance_level" visibility="public_vis">
    <documentation>For NMR data. Chains with the same magnEquivalenceCode are magnetically equivalent within the MolSystem. If not set no chains are magnetically equivalent.</documentation>
    <valueType>www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00033</valueType>
  </MetaAttribute>

  <MetaRole name="molSystem"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:31_00001"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00024"
   aggregation="composite" baseName="molSystem" changeability="frozen"
   hicard="1" hierarchy="parent" isAbstract="false" isAutomatic="false"
   isDerived="false" isImplementation="false" isImplicit="false"
   isOrdered="false" isUnique="true" locard="1" noDeleteIfSet="false"
   partitionsChildren="false" scope="instance_level" visibility="public_vis">
    <otherRole>www.ccpn.ac.uk_Fogh_2006-08-16-18:23:31_00002</otherRole>
    <valueType>www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00023</valueType>
  </MetaRole>

  <MetaAttribute name="molecularMass"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:32_00011"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00024"
   baseName="molecularMass" changeability="frozen" hicard="1" isAbstract="false"
   isAutomatic="false" isDerived="true" isImplementation="false"
   isImplicit="false" isOrdered="false" isUnique="true" locard="1"
   scope="instance_level" visibility="public_vis">
    <documentation>molecular mass of Chain (may differ from that of the corresponding molecule).</documentation>
    <valueType>www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00031</valueType>
  </MetaAttribute>

  <MetaRole name="chains"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:33_00045"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00039"
   baseName="chain" changeability="changeable" hicard="-1" isAbstract="false"
   isAutomatic="false" isDerived="false" isImplementation="false"
   isImplicit="false" isOrdered="false" isUnique="true" locard="0"
   noDeleteIfSet="true" partitionsChildren="false" scope="instance_level"
   visibility="public_vis">
    <documentation>MolSystem Chains corresponding to Molecule</documentation>
    <otherRole>www.ccpn.ac.uk_Fogh_2006-08-16-18:23:33_00044</otherRole>
    <valueType>www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00024</valueType>
  </MetaRole>

  <MetaRole name="molecule"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:33_00044"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00024"
   baseName="molecule" changeability="frozen" hicard="1" isAbstract="false"
   isAutomatic="false" isDerived="false" isImplementation="false"
   isImplicit="false" isOrdered="false" isUnique="true" locard="1"
   noDeleteIfSet="false" partitionsChildren="false" scope="instance_level"
   visibility="public_vis">
    <documentation>Molecule to which Chain corresponds</documentation>
    <otherRole>www.ccpn.ac.uk_Fogh_2006-08-16-18:23:33_00045</otherRole>
    <valueType>www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00039</valueType>
  </MetaRole>

  <MetaAttribute name="pdbOneLetterCode"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:32_00003"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00024"
   baseName="pdbOneLetterCode" changeability="changeable" hicard="1"
   isAbstract="false" isAutomatic="false" isDerived="false"
   isImplementation="false" isImplicit="false" isOrdered="false" isUnique="true"
   locard="1" scope="instance_level" visibility="public_vis">
    <documentation>One letter chain identifier. Will be used by PDB (and programs that use similar conventions). WARNING: having same oneLetterCode for different chains is legal but may cause serious confusion.</documentation>
    <valueType>www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00033</valueType>
    <defaultValue>
      <item> </item>
    </defaultValue>

    <!-- Start constraints for <MetaAttribute: ccp.molecule.MolSystem.Chain.pdbOneLetterCode>: -->
    <MetaConstraint name="length_is_one"
     guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:32_00004"
     container="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:32_00003"
     isImplicit="false">
      <codeStubs>
        <item tag="java">value.length() == 1</item>
        <item tag="python">len(value) == 1</item>
      </codeStubs>
    </MetaConstraint>
    <!-- End constraints for <MetaAttribute: ccp.molecule.MolSystem.Chain.pdbOneLetterCode>: -->
  </MetaAttribute>

  <MetaAttribute name="physicalState"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:32_00007"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00024"
   baseName="physicalState" changeability="changeable" hicard="1"
   isAbstract="false" isAutomatic="false" isDerived="false"
   isImplementation="false" isImplicit="false" isOrdered="false" isUnique="true"
   locard="0" scope="instance_level" visibility="public_vis">
    <documentation>e.g. folded/unfolded</documentation>
    <valueType>www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00033</valueType>
  </MetaAttribute>

  <MetaRole name="residues"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:31_00036"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00024"
   baseName="residue" changeability="changeable" hicard="-1" hierarchy="child"
   isAbstract="false" isAutomatic="false" isDerived="false"
   isImplementation="false" isImplicit="false" isOrdered="false" isUnique="true"
   locard="0" noDeleteIfSet="false" partitionsChildren="false"
   scope="instance_level" visibility="public_vis">
    <documentation>child link</documentation>
    <otherRole>www.ccpn.ac.uk_Fogh_2006-08-16-18:23:31_00035</otherRole>
    <valueType>www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00030</valueType>
  </MetaRole>

  <MetaAttribute name="role"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:32_00005"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00024"
   baseName="role" changeability="changeable" hicard="1" isAbstract="false"
   isAutomatic="false" isDerived="false" isImplementation="false"
   isImplicit="false" isOrdered="false" isUnique="true" locard="0"
   scope="instance_level" visibility="public_vis">
    <documentation>Role of Chain within MolSystem</documentation>
    <valueType>www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00033</valueType>
  </MetaAttribute>
</MetaClass>

