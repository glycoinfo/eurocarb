"""
#######################################################################

CCPN Data Model version 2.0.b2

Autogenerated by PyFileApiGen revision 1.51.2.3 on Mon Apr  6 17:04:32 2009
  from data model element ccp.nmr.NmrConstraint revision 1.39.2.9

#######################################################################
======================COPYRIGHT/LICENSE START==========================

NmrConstraint.py: python API for CCPN data model, MetaPackage ccp.nmr.NmrConstraint

Copyright (C) 2007 Rasmus Fogh (CCPN Project)

=======================================================================

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.
 
A copy of this license can be found in ../../../../license/LGPL.license
 
This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
Lesser General Public License for more details.
 
You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA


======================COPYRIGHT/LICENSE END============================

for further information, please contact :

- CCPN website (http://www.ccpn.ac.uk/)

- email: ccpn@bioc.cam.ac.uk

=======================================================================

If you are using this software for academic purposes, we suggest
quoting the following references:

===========================REFERENCE START=============================
Wim F. Vranken, Wayne Boucher, Tim J. Stevens, Rasmus
H. Fogh, Anne Pajon, Miguel Llinas, Eldon L. Ulrich, John L. Markley, John
Ionides and Ernest D. Laue (2005). The CCPN Data Model for NMR Spectroscopy:
Development of a Software Pipeline. Proteins 59, 687 - 696.

Rasmus H. Fogh, Wayne Boucher, Wim F. Vranken, Anne
Pajon, Tim J. Stevens, T.N. Bhat, John Westbrook, John M.C. Ionides and
Ernest D. Laue (2005). A framework for scientific data modeling and automated
software development. Bioinformatics 21, 1678-1684.


This file was generated with the Memops software generation framework,
and contains original contributions embedded in the framework

===========================REFERENCE END===============================
"""

import cStringIO
#import sets
import traceback
import types
import operator

# special function for fast whitespace checking.
# used in DataType Word and Token handcode
import re
containsWhitespace = re.compile('\s').search
containsNonAlphanumeric = re.compile('[^a-zA-Z0-9_]').search
 
from memops.general import Implementation as implementation
ApiError = implementation.ApiError

# imported packages:
import ccp.api.general.Method
import ccp.api.molecule.ChemElement
import ccp.api.molecule.MolStructure
import ccp.api.molecule.MolSystem
import ccp.api.molecule.Validation
import ccp.api.nmr.Nmr
import memops.api.AccessControl
import memops.api.Implementation

metaPackage = memops.api.Implementation.topPackage.metaObjFromQualName('ccp.nmr.NmrConstraint')

###############################################################################
class AbstractConstraint(memops.api.Implementation.DataObject):
  r"""Constraint (of any type)
  """
  #   from data model element ccp.nmr.NmrConstraint.AbstractConstraint revision 1.43.2.9
  _metaclass = metaPackage.getElement('AbstractConstraint')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('applicationData', 'className', 'details', 'fieldNames', 'inConstructor', 'isDeleted', 'metaclass', 'origData', 'packageName', 'packageShortName', 'qualifiedName', 'serial', 'weight', 'access', 'constraintGroups', 'method', 'nmrConstraintValidations', 'parentList', 'peakContribs', 'peaks', 'root', 'topObject', 'violations',)

  __init__ = memops.api.Implementation.ComplexDataType.__init__

  addApplicationData = memops.api.Implementation.DataObject.addApplicationData
  
  def addConstraintGroup(self, value):
    """
    Add for ccp.nmr.NmrConstraint.AbstractConstraint.constraintGroups
    """
    dataDict = self.__dict__
    if (not isinstance(value, ConstraintGroup)):
      raise ApiError("""%s.addConstraintGroup:
       value is not of class ccp.nmr.NmrConstraint.ConstraintGroup""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('constraintGroups')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.addConstraintGroup:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.addConstraintGroup:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.addConstraintGroup:
       called with deleted value""" % self.qualifiedName
      )

    if (value in currentValues):
      raise ApiError("""%s.addConstraintGroup:
       value is in list already""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      if (value is not None):
        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.addConstraintGroup:
           Link constraintGroups between objects from separate partitions
           - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    oldSelves = value.__dict__.get('constraints')
    oldSelves.add(self)
    currentValues.add(value)
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('addConstraintGroup')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  def addNmrConstraintValidation(self, value):
    """
    Add for
    ccp.nmr.NmrConstraint.AbstractConstraint.nmrConstraintValidations
    """
    dataDict = self.__dict__
    from ccp.api.molecule.Validation import NmrConstraintValidation as importedType
    if (not isinstance(value, importedType)):
      raise ApiError("""%s.addNmrConstraintValidation:
       value is not of class ccp.molecule.Validation.NmrConstraintValidation""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('nmrConstraintValidations')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      topObject = value.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)
      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.addNmrConstraintValidation:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.addNmrConstraintValidation:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.addNmrConstraintValidation:
       called with deleted value""" % self.qualifiedName
      )

    if (value in currentValues):
      raise ApiError("""%s.addNmrConstraintValidation:
       value is in list already""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      if (value is not None):
        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        yy2 = yy1.__dict__.get('nmrConstraintStore')
        if (not (xx1 is yy2)):
          raise ApiError("""%s.addNmrConstraintValidation:
           Link nmrConstraintValidations between objects from separate partitions
           - ccp.molecule.Validation.ValidationStore.nmrConstraintStore not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      if (notInConstructor):
        if (value is not None):
          ll= value.keywordDefinition.targetNames
          isValid = (not ll or self.qualifiedName in ll)
          if (not (isValid)):
            raise ApiError("""%s.addNmrConstraintValidation:
             nmrConstraintValidations constraint KeywordDefinition_fits_Constraint violated by value""" % self.qualifiedName
             + ": %s" % (value,)
            )

    oldSelves = value.__dict__.get('nmrConstraints')
    oldSelves.add(self)
    currentValues.add(value)
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('addNmrConstraintValidation')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  def addPeak(self, value):
    """
    add function for derived link peaks
    """
    dataDict = self.__dict__
    from ccp.api.nmr.Nmr import Peak as importedType
    if (not isinstance(value, importedType)):
      raise ApiError("""%s.addPeak:
       value is not of class ccp.nmr.Nmr.Peak""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = self.getPeaks()
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.addPeak:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.addPeak:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.addPeak:
       called with deleted value""" % self.qualifiedName
      )

    if (value in currentValues):
      raise ApiError("""%s.addPeak:
       value is in list already""" % self.qualifiedName
       + ": %s" % (self,)
      )

    ConstraintPeakContrib(self, peak=value)
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

  checkAllValid = memops.api.Implementation.ComplexDataType.checkAllValid

  checkValid = memops.api.Implementation.ComplexDataType.checkValid

  delete = memops.api.Implementation.DataObject.delete

  findAllApplicationData = memops.api.Implementation.DataObject.findAllApplicationData
  
  def findAllConstraintGroups(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.AbstractConstraint.constraintGroups
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('constraintGroups')
      result = set(currentValues)

    else:
      currentValues = dataDict.get('constraintGroups')
      result = set()
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('details', 'serial', 'access', 'nmrConstraintStore',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result.add(v)

    return result
  
  def findAllNmrConstraintValidations(self, **conditions):
    """
    FindAll for
    ccp.nmr.NmrConstraint.AbstractConstraint.nmrConstraintValidations
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('nmrConstraintValidations')
      result = set(currentValues)

    else:
      currentValues = dataDict.get('nmrConstraintValidations')
      result = set()
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('booleanValue', 'context', 'details', 'figOfMerit', 'floatValue', 'intValue', 'keyword', 'serial', 'textValue', 'access', 'validationStore',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result.add(v)

    return result
  
  def findAllPeakContribs(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.AbstractConstraint.peakContribs
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('peakContribs').values()
      result = set(currentValues)

    else:
      currentValues = dataDict.get('peakContribs').values()
      result = set()
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('dataSourceSerial', 'experimentSerial', 'peakListSerial', 'peakSerial', 'access', 'constraint',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result.add(v)

    return result
  
  def findAllPeaks(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.AbstractConstraint.peaks
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = self.getPeaks()
      result = set(currentValues)

    else:
      currentValues = self.getPeaks()
      result = set()
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('annotation', 'constraintWeight', 'details', 'figOfMerit', 'serial', 'access', 'fitMethod', 'peakList',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result.add(v)

    return result
  
  def findAllViolations(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.AbstractConstraint.violations
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('violations')
      result = set(currentValues)

    else:
      currentValues = dataDict.get('violations')
      result = set()
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('calcValue', 'calcValueError', 'fractionViolated', 'violation', 'access', 'constraint', 'method', 'violationList',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result.add(v)

    return result

  findFirstApplicationData = memops.api.Implementation.DataObject.findFirstApplicationData
  
  def findFirstConstraintGroup(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.AbstractConstraint.constraintGroups
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('constraintGroups')
      if (currentValues):
        result = iter(currentValues).next()
      else:
        result = None

    else:
      currentValues = dataDict.get('constraintGroups')
      result = None
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('details', 'serial', 'access', 'nmrConstraintStore',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result = v; break

    return result
  
  def findFirstNmrConstraintValidation(self, **conditions):
    """
    FindFirst for
    ccp.nmr.NmrConstraint.AbstractConstraint.nmrConstraintValidations
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('nmrConstraintValidations')
      if (currentValues):
        result = iter(currentValues).next()
      else:
        result = None

    else:
      currentValues = dataDict.get('nmrConstraintValidations')
      result = None
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('booleanValue', 'context', 'details', 'figOfMerit', 'floatValue', 'intValue', 'keyword', 'serial', 'textValue', 'access', 'validationStore',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result = v; break

    return result
  
  def findFirstPeak(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.AbstractConstraint.peaks
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = self.getPeaks()
      if (currentValues):
        result = iter(currentValues).next()
      else:
        result = None

    else:
      currentValues = self.getPeaks()
      result = None
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('annotation', 'constraintWeight', 'details', 'figOfMerit', 'serial', 'access', 'fitMethod', 'peakList',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result = v; break

    return result
  
  def findFirstPeakContrib(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.AbstractConstraint.peakContribs
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('peakContribs').values()
      if (currentValues):
        result = iter(currentValues).next()
      else:
        result = None

    else:
      ll = list()
      objKey = conditions.get('experimentSerial')
      ll.append(objKey)
      if (objKey is not None):
        objKey = conditions.get('dataSourceSerial')
        ll.append(objKey)
        if (objKey is not None):
          objKey = conditions.get('peakListSerial')
          ll.append(objKey)
          if (objKey is not None):
            objKey = conditions.get('peakSerial')
            ll.append(objKey)
            if (objKey is not None):
              objKey = tuple(ll)

      if (objKey is not None):
        result = dataDict.get('peakContribs').get(objKey)

        if (result is None):
          return result

        elif (len(conditions) <= 4):
          return result

        else:
          currentValues = set()
          currentValues.add(result)

      else:
        currentValues = dataDict.get('peakContribs').values()

      result = None
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('dataSourceSerial', 'experimentSerial', 'peakListSerial', 'peakSerial', 'access', 'constraint',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result = v; break

    return result
  
  def findFirstViolation(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.AbstractConstraint.violations
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('violations')
      if (currentValues):
        result = iter(currentValues).next()
      else:
        result = None

    else:
      currentValues = dataDict.get('violations')
      result = None
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('calcValue', 'calcValueError', 'fractionViolated', 'violation', 'access', 'constraint', 'method', 'violationList',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result = v; break

    return result

  getAccess = memops.api.Implementation.DataObject.getAccess

  getApplicationData = memops.api.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.AbstractConstraint
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (3 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.AbstractConstraint'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (2 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.AbstractConstraint'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-2]
      obj2 = obj1.__dict__.get('constraintLists').get(objKey)

      if (obj2 is not None):
        objKey = fullKey[-1]
        obj3 = obj2.__dict__.get('constraints').get(objKey)
        result = obj3

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = memops.api.Implementation.MemopsObject.getByNavigation

  getClassName = memops.api.Implementation.ComplexDataType.getClassName
  
  def getConstraintGroups(self):
    """
    Get for ccp.nmr.NmrConstraint.AbstractConstraint.constraintGroups
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('constraintGroups')
    result = frozenset(tempVar)
    return result
  
  def getDetails(self):
    """
    Get for ccp.nmr.NmrConstraint.AbstractConstraint.details
    """
    dataDict = self.__dict__
    result = dataDict.get('details')
    return result

  getExpandedKey = memops.api.Implementation.MemopsObject.getExpandedKey

  getFieldNames = memops.api.Implementation.ComplexDataType.getFieldNames
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccp.nmr.NmrConstraint.AbstractConstraint
    """
    dataDict = self.__dict__
    result = list()

    obj2 = dataDict.get('parentList')
    obj1 = obj2.__dict__.get('nmrConstraintStore')

    if (useGuid):
      result.append(obj1.__dict__.get('guid'))
    else:
      result.append(obj1.__dict__.get('serial'))

    result.append(obj2.__dict__.get('serial'))
    result.append(dataDict.get('serial'))

    return result

  getInConstructor = memops.api.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = memops.api.Implementation.MemopsObject.getIsDeleted
  
  def getLocalKey(self):
    """
    GetLocalKey for ccp.nmr.NmrConstraint.AbstractConstraint
    """
    dataDict = self.__dict__
    result = dataDict.get('serial')
    return result

  getMetaclass = memops.api.Implementation.ComplexDataType.getMetaclass
  
  def getMethod(self):
    """
    Get for ccp.nmr.NmrConstraint.AbstractConstraint.method
    """
    dataDict = self.__dict__
    result = dataDict.get('method')
    return result
  
  def getNmrConstraintValidations(self):
    """
    Get for
    ccp.nmr.NmrConstraint.AbstractConstraint.nmrConstraintValidations
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('nmrConstraintValidations')
    result = frozenset(tempVar)
    return result
  
  def getOrigData(self):
    """
    Get for ccp.nmr.NmrConstraint.AbstractConstraint.origData
    """
    dataDict = self.__dict__
    result = dataDict.get('origData')
    return result

  getPackageName = memops.api.Implementation.ComplexDataType.getPackageName

  getPackageShortName = memops.api.Implementation.ComplexDataType.getPackageShortName
  
  def getParentList(self):
    """
    Get for ccp.nmr.NmrConstraint.AbstractConstraint.parentList
    """
    dataDict = self.__dict__
    raise ApiError("""%s.getParentList:
     getParentList should never be called - must be overridden in subclass""" % self.qualifiedName
     + ": %s" % (self,)
    )
  
  def getPeakContribs(self):
    """
    Get for ccp.nmr.NmrConstraint.AbstractConstraint.peakContribs
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('peakContribs').values()
    result = frozenset(tempVar)
    return result
  
  def getPeaks(self):
    """
    getter for derived link peaks
    """
    dataDict = self.__dict__
    result = [x.peak for x in self.peakContribs]
    result = frozenset(x for x in result if x is not None)
    return result

  getQualifiedName = memops.api.Implementation.ComplexDataType.getQualifiedName

  getRoot = memops.api.Implementation.MemopsObject.getRoot
  
  def getSerial(self):
    """
    Get for ccp.nmr.NmrConstraint.AbstractConstraint.serial
    """
    dataDict = self.__dict__
    result = dataDict.get('serial')
    return result

  getTopObject = memops.api.Implementation.DataObject.getTopObject
  
  def getViolations(self):
    """
    Get for ccp.nmr.NmrConstraint.AbstractConstraint.violations
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('violations')
    result = frozenset(tempVar)
    return result
  
  def getWeight(self):
    """
    Get for ccp.nmr.NmrConstraint.AbstractConstraint.weight
    """
    dataDict = self.__dict__
    result = dataDict.get('weight')
    return result
  
  def newConstraintPeakContrib(self, **attrlinks):
    """
    Factory function to create ccp.nmr.NmrConstraint.ConstraintPeakContrib
    """
    return ConstraintPeakContrib(self, **attrlinks)

  removeApplicationData = memops.api.Implementation.DataObject.removeApplicationData
  
  def removeConstraintGroup(self, value):
    """
    Remove for ccp.nmr.NmrConstraint.AbstractConstraint.constraintGroups
    """
    dataDict = self.__dict__
    if (not isinstance(value, ConstraintGroup)):
      raise ApiError("""%s.removeConstraintGroup:
       value is not of class ccp.nmr.NmrConstraint.ConstraintGroup""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('constraintGroups')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.removeConstraintGroup:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.removeConstraintGroup:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.removeConstraintGroup:
       called with deleted value""" % self.qualifiedName
      )

    if (not (value in currentValues)):
      raise ApiError("""%s.removeConstraintGroup:
       value not in list""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      pass

    oldSelves = value.__dict__.get('constraints')
    oldSelves.remove(self)
    currentValues.remove(value)
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('removeConstraintGroup')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  def removeNmrConstraintValidation(self, value):
    """
    Remove for
    ccp.nmr.NmrConstraint.AbstractConstraint.nmrConstraintValidations
    """
    dataDict = self.__dict__
    from ccp.api.molecule.Validation import NmrConstraintValidation as importedType
    if (not isinstance(value, importedType)):
      raise ApiError("""%s.removeNmrConstraintValidation:
       value is not of class ccp.molecule.Validation.NmrConstraintValidation""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('nmrConstraintValidations')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      topObject = value.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)
      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.removeNmrConstraintValidation:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.removeNmrConstraintValidation:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.removeNmrConstraintValidation:
       called with deleted value""" % self.qualifiedName
      )

    if (not (value in currentValues)):
      raise ApiError("""%s.removeNmrConstraintValidation:
       value not in list""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      pass

    oldSelves = value.__dict__.get('nmrConstraints')
    oldSelves.remove(self)
    currentValues.remove(value)
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('removeNmrConstraintValidation')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  def removePeak(self, value):
    """
    remove function for derived link peaks
    """
    dataDict = self.__dict__
    from ccp.api.nmr.Nmr import Peak as importedType
    if (not isinstance(value, importedType)):
      raise ApiError("""%s.removePeak:
       value is not of class ccp.nmr.Nmr.Peak""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = self.getPeaks()
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.removePeak:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.removePeak:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.removePeak:
       called with deleted value""" % self.qualifiedName
      )

    if (not (value in currentValues)):
      raise ApiError("""%s.removePeak:
       value not in list""" % self.qualifiedName
       + ": %s" % (self,)
      )

    obj = self.findFirstPeakContrib(peak=value)
    if obj is not None:
      obj.delete()
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

  setAccess = memops.api.Implementation.DataObject.setAccess

  setApplicationData = memops.api.Implementation.DataObject.setApplicationData
  
  def setConstraintGroups(self, values):
    """
    Set for ccp.nmr.NmrConstraint.AbstractConstraint.constraintGroups
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setConstraintGroups:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      if (not isinstance(value, ConstraintGroup)):
        raise ApiError("""%s.setConstraintGroups:
         value is not of class ccp.nmr.NmrConstraint.ConstraintGroup""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('constraintGroups')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setConstraintGroups:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setConstraintGroups:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setConstraintGroups:
         an object in values is deleted""" % self.qualifiedName
        )

    if (values == currentValues):
      return

    if (notOverride):
      xx1 = dataDict.get('topObject')
      for value in values:
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setConstraintGroups:
           Link constraintGroups between objects from separate partitions
           - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    for cv in currentValues:
      if (not (cv in values)):
        oldSelves = cv.__dict__.get('constraints')
        oldSelves.remove(self)

    for cv in values:
      if (not (cv in currentValues)):
        oldSelves = cv.__dict__.get('constraints')
        oldSelves.add(self)

    dataDict['constraintGroups'] = values
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setConstraintGroups')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  def setDetails(self, value):
    """
    Set for ccp.nmr.NmrConstraint.AbstractConstraint.details
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, memops.api.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.setDetails:
         memops.Implementation.Text input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 254):
        raise ApiError("""%s.setDetails:
         memops.Implementation.Text maximum length is 254 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.setDetails:
         memops.Implementation.Text: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('details')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setDetails:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setDetails:
       called on deleted object""" % self.qualifiedName
      )

    if (value == currentValue):
      return

    if (notOverride):
      pass

    dataDict['details'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setDetails')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  def setMethod(self, value):
    """
    Set for ccp.nmr.NmrConstraint.AbstractConstraint.method
    """
    dataDict = self.__dict__
    if (value is not None):
      from ccp.api.general.Method import Method as importedType
      if (not isinstance(value, importedType)):
        raise ApiError("""%s.setMethod:
         value is not of class ccp.general.Method.Method""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('method')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setMethod:
       called on deleted object""" % self.qualifiedName
      )

    if (value is not None):
      if (value.__dict__.get('isDeleted')):
        raise ApiError("""%s.setMethod:
         called with deleted value""" % self.qualifiedName
        )

    if (value == currentValue):
      return

    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setMethod:
         cannot set method, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is not None):
        xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setMethod:
           Link method between objects from separate partitions
           - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    if (currentValue is not None):
      if (notIsReading):
        oldSelves = currentValue.__dict__.get('constraints')
        oldSelves.remove(self)
      else:
        raise ApiError("""%s.setMethod:
         Read link 'method' incompatible with pre-existing link""" % self.qualifiedName
         + ": %s" % (self,)
        )

    if (value is not None):
      newSelves = value.__dict__.get('constraints')
      newSelves.add(self)

    dataDict['method'] = value

    # doNotifies
  
  def setNmrConstraintValidations(self, values):
    """
    Set for
    ccp.nmr.NmrConstraint.AbstractConstraint.nmrConstraintValidations
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setNmrConstraintValidations:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      from ccp.api.molecule.Validation import NmrConstraintValidation as importedType
      if (not isinstance(value, importedType)):
        raise ApiError("""%s.setNmrConstraintValidations:
         value is not of class ccp.molecule.Validation.NmrConstraintValidation""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('nmrConstraintValidations')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      for pv in currentValues:
        if (not (pv in values)):
          topObject = pv.__dict__.get('topObject')
          topObjectsToCheck.add(topObject)

      for pv in values:
        if (not (pv in currentValues)):
          topObject = pv.__dict__.get('topObject')
          topObjectsToCheck.add(topObject)

      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setNmrConstraintValidations:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setNmrConstraintValidations:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setNmrConstraintValidations:
         an object in values is deleted""" % self.qualifiedName
        )

    if (values == currentValues):
      return

    if (notOverride):
      xx1 = dataDict.get('topObject')
      for value in values:
        yy1 = value.__dict__.get('topObject')
        yy2 = yy1.__dict__.get('nmrConstraintStore')
        if (not (xx1 is yy2)):
          raise ApiError("""%s.setNmrConstraintValidations:
           Link nmrConstraintValidations between objects from separate partitions
           - ccp.molecule.Validation.ValidationStore.nmrConstraintStore not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      if (notInConstructor):
        for value in values:
          ll= value.keywordDefinition.targetNames
          isValid = (not ll or self.qualifiedName in ll)
          if (not (isValid)):
            raise ApiError("""%s.setNmrConstraintValidations:
             nmrConstraintValidations constraint KeywordDefinition_fits_Constraint violated by value""" % self.qualifiedName
             + ": %s" % (value,)
            )

    for cv in currentValues:
      if (not (cv in values)):
        oldSelves = cv.__dict__.get('nmrConstraints')
        oldSelves.remove(self)

    for cv in values:
      if (not (cv in currentValues)):
        oldSelves = cv.__dict__.get('nmrConstraints')
        oldSelves.add(self)

    dataDict['nmrConstraintValidations'] = values
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setNmrConstraintValidations')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  def setOrigData(self, value):
    """
    Set for ccp.nmr.NmrConstraint.AbstractConstraint.origData
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, memops.api.Implementation.Float.PythonType)):
        pass
      elif ([x for x in memops.api.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = memops.api.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.setOrigData:
         memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.setOrigData:
         Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('origData')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setOrigData:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setOrigData:
       called on deleted object""" % self.qualifiedName
      )

    if (value == currentValue):
      return

    if (notOverride):
      pass

    dataDict['origData'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setOrigData')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  def setPeaks(self, values):
    """
    setter for derived link peaks
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setPeaks:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      from ccp.api.nmr.Nmr import Peak as importedType
      if (not isinstance(value, importedType)):
        raise ApiError("""%s.setPeaks:
         value is not of class ccp.nmr.Nmr.Peak""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = self.getPeaks()
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setPeaks:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setPeaks:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setPeaks:
         an object in values is deleted""" % self.qualifiedName
        )

    if (values == currentValues):
      return

    for xx in self.peakContribs:
      xx.delete()
    for peak in values:
      ConstraintPeakContrib(self, peak=peak)
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

  def setSerial(self, value):
    """
    Set for ccp.nmr.NmrConstraint.AbstractConstraint.serial
    """
    dataDict = self.__dict__
    if (isinstance(value, memops.api.Implementation.Int.PythonType)):
      pass
    elif ([x for x in memops.api.Implementation.Int.compatibleTypes if isinstance(value, x)]):
      value = memops.api.Implementation.Int.create(value)
    else:
      raise ApiError("""%s.setSerial:
       memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('serial')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setSerial:
       called on deleted object""" % self.qualifiedName
      )

    if (value == currentValue):
      return

    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setSerial:
         cannot set serial, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is None):
        raise ApiError("""%s.setSerial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    parent = dataDict.get('parentList')
    oldSerial = parent.__dict__.get('_serialDict').get('constraints')
    if (value < 0):
      value = (oldSerial + 1)
      parent.__dict__.get('_serialDict')['constraints'] = value
    elif (value > oldSerial):
      parent.__dict__.get('_serialDict')['constraints'] = value

    dataDict['serial'] = value

    # doNotifies
  
  def setViolations(self, values):
    """
    Set for ccp.nmr.NmrConstraint.AbstractConstraint.violations
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setViolations:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      if (not isinstance(value, Violation)):
        raise ApiError("""%s.setViolations:
         value is not of class ccp.nmr.NmrConstraint.Violation""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('violations')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setViolations:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setViolations:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setViolations:
         an object in values is deleted""" % self.qualifiedName
        )

    if (values == currentValues):
      return

    if (notOverride):
      for cv in currentValues:
        if (not (cv in values)):
          raise ApiError("""%s.setViolations:
           locard constraint: cannot set because some of current values not in values""" % self.qualifiedName
           + ": %s" % (self,)
          )

      xx1 = dataDict.get('topObject')
      for value in values:
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setViolations:
           Link violations between objects from separate partitions
           - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    for cv in values:
      cv.__dict__['constraint'] = self

    dataDict['violations'] = values
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setViolations')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  def setWeight(self, value):
    """
    Set for ccp.nmr.NmrConstraint.AbstractConstraint.weight
    """
    dataDict = self.__dict__
    if (isinstance(value, memops.api.Implementation.Float.PythonType)):
      pass
    elif ([x for x in memops.api.Implementation.Float.compatibleTypes if isinstance(value, x)]):
      value = memops.api.Implementation.Float.create(value)
    else:
      raise ApiError("""%s.setWeight:
       memops.Implementation.NonNegativeFloat input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (0.0 <= value)):
      raise ApiError("""%s.setWeight:
       NonNegativeFloat constraint float_value_ge_0 violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (value - value == 0.0)):
      raise ApiError("""%s.setWeight:
       NonNegativeFloat constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('weight')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setWeight:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setWeight:
       called on deleted object""" % self.qualifiedName
      )

    if (value == currentValue):
      return

    if (notOverride):
      if (value is None):
        raise ApiError("""%s.setWeight:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    dataDict['weight'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setWeight')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  def sortedConstraintGroups(self):
    """
    Sorted for ccp.nmr.NmrConstraint.AbstractConstraint.constraintGroups
    """
    dataDict = self.__dict__
    ll = dataDict.get('constraintGroups')
    ll = [(x.getFullKey(),x) for x in ll]
    
    ll.sort()
    result = [x[1] for x in ll]
    return result
  
  def sortedNmrConstraintValidations(self):
    """
    Sorted for
    ccp.nmr.NmrConstraint.AbstractConstraint.nmrConstraintValidations
    """
    dataDict = self.__dict__
    ll = dataDict.get('nmrConstraintValidations')
    ll = [(repr(x),x) for x in ll]
    
    ll.sort()
    result = [x[1] for x in ll]
    return result
  
  def sortedPeakContribs(self):
    """
    Sorted for ccp.nmr.NmrConstraint.AbstractConstraint.peakContribs
    """
    dataDict = self.__dict__
    sortdd = dataDict.get('peakContribs')
    
    ll = sortdd.keys()
    ll.sort()
    result = [sortdd[x] for x in ll]
    return result
  
  def sortedPeaks(self):
    """
    Sorted for ccp.nmr.NmrConstraint.AbstractConstraint.peaks
    """
    dataDict = self.__dict__
    ll = self.getPeaks()
    ll = [(x.getFullKey(),x) for x in ll]
    
    ll.sort()
    result = [x[1] for x in ll]
    return result
  
  def sortedViolations(self):
    """
    Sorted for ccp.nmr.NmrConstraint.AbstractConstraint.violations
    """
    dataDict = self.__dict__
    ll = dataDict.get('violations')
    ll = [(x.getFullKey(),x) for x in ll]
    
    ll.sort()
    result = [x[1] for x in ll]
    return result

  toDetailedString = memops.api.Implementation.ComplexDataType.toDetailedString

  applicationData = memops.api.Implementation.DataObject.applicationData

  className = memops.api.Implementation.ComplexDataType.className
  
  details = property(getDetails, setDetails, None,
  r"""Free text, for notes, explanatory comments, etc.
  """)

  fieldNames = memops.api.Implementation.ComplexDataType.fieldNames

  inConstructor = memops.api.Implementation.ComplexDataType.inConstructor

  isDeleted = memops.api.Implementation.MemopsObject.isDeleted

  metaclass = memops.api.Implementation.ComplexDataType.metaclass
  
  origData = property(getOrigData, setOrigData, None,
  r"""Value of original measurement that gave rise to Constraint. E.g. 
  Crosspeak Intensity or Volume (for a distance constraint), Coupling 
  Constant (In Hz) for a dihedral constraint, etc. Provided to cater for 
  structure generation programs that keep this kind of information in 
  their constraint lists.
  """)

  packageName = memops.api.Implementation.ComplexDataType.packageName

  packageShortName = memops.api.Implementation.ComplexDataType.packageShortName

  qualifiedName = memops.api.Implementation.ComplexDataType.qualifiedName
  
  serial = property(getSerial, setSerial, None,
  r"""Serial number of object. Serves as object main key. Serial numbers of 
  deleted objects are not re-used. Serial numbers can only be set by the 
  implementation. Values are in practice always positive, since negative 
  values are interpreted as a signal to set the next free serial
  """)
  
  weight = property(getWeight, setWeight, None,
  r"""Relative weight of constraint in constraint list
  """)

  access = memops.api.Implementation.DataObject.access
  
  constraintGroups = property(getConstraintGroups, setConstraintGroups, None,
  r"""Constraint groups that constraint takes part in
  """)
  
  method = property(getMethod, setMethod, None,
  r"""Method used to calculate Constraint. Overrides any Method attached to 
  parent ConstraintList.
  """)
  
  nmrConstraintValidations = property(getNmrConstraintValidations, setNmrConstraintValidations, None,
  r"""Validation results that include AbstractConstraint
  """)
  
  parentList = property(getParentList,  None, None,
  r"""parent link
  """)
  
  peakContribs = property(getPeakContribs,  None, None,
  r"""child link to class ConstraintPeakContrib
  """)
  
  peaks = property(getPeaks, setPeaks, None,
  r"""peaks used in derivation of AbstractConstraint.
  """)

  root = memops.api.Implementation.MemopsObject.root

  topObject = memops.api.Implementation.DataObject.topObject
  
  violations = property(getViolations, setViolations, None,
  r"""Violation of Constraint in a given structure or set of structures.
  """)

###############################################################################
class AbstractConstraintList(memops.api.Implementation.DataObject):
  r"""List of constraints (of any type).
  """
  #   from data model element ccp.nmr.NmrConstraint.AbstractConstraintList revision 1.46.2.10
  _metaclass = metaPackage.getElement('AbstractConstraintList')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('applicationData', 'className', 'details', 'experimentSerials', 'fieldNames', 'inConstructor', 'isDeleted', 'measureListSerials', 'metaclass', 'name', 'packageName', 'packageShortName', 'qualifiedName', 'serial', 'unit', 'usedForCalculation', 'access', 'conditionState', 'constraints', 'experiments', 'measurementLists', 'method', 'nmrConstraintListValidations', 'nmrConstraintStore', 'nmrSimEnergyTerms', 'parent', 'root', 'topObject',)

  __init__ = memops.api.Implementation.ComplexDataType.__init__

  addApplicationData = memops.api.Implementation.DataObject.addApplicationData
  
  def addExperiment(self, value):
    """
    add function for derived link experiments
    """
    dataDict = self.__dict__
    from ccp.api.nmr.Nmr import Experiment as importedType
    if (not isinstance(value, importedType)):
      raise ApiError("""%s.addExperiment:
       value is not of class ccp.nmr.Nmr.Experiment""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = self.getExperiments()
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.addExperiment:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.addExperiment:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.addExperiment:
       called with deleted value""" % self.qualifiedName
      )

    if (value in currentValues):
      raise ApiError("""%s.addExperiment:
       value is in list already""" % self.qualifiedName
       + ": %s" % (self,)
      )

    self.addExperimentSerial(value.serial)
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

  def addExperimentSerial(self, value):
    """
    Add for ccp.nmr.NmrConstraint.AbstractConstraintList.experimentSerials
    """
    dataDict = self.__dict__
    if (isinstance(value, memops.api.Implementation.Int.PythonType)):
      pass
    elif ([x for x in memops.api.Implementation.Int.compatibleTypes if isinstance(value, x)]):
      value = memops.api.Implementation.Int.create(value)
    else:
      raise ApiError("""%s.addExperimentSerial:
       memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('experimentSerials')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.addExperimentSerial:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.addExperimentSerial:
       called on deleted object""" % self.qualifiedName
      )

    if (value in currentValues):
      raise ApiError("""%s.addExperimentSerial:
       value is in list already""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      pass

    currentValues.add(value)
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('addExperimentSerial')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  def addMeasureListSerial(self, value):
    """
    Add for ccp.nmr.NmrConstraint.AbstractConstraintList.measureListSerials
    """
    dataDict = self.__dict__
    if (isinstance(value, memops.api.Implementation.Int.PythonType)):
      pass
    elif ([x for x in memops.api.Implementation.Int.compatibleTypes if isinstance(value, x)]):
      value = memops.api.Implementation.Int.create(value)
    else:
      raise ApiError("""%s.addMeasureListSerial:
       memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('measureListSerials')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.addMeasureListSerial:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.addMeasureListSerial:
       called on deleted object""" % self.qualifiedName
      )

    if (value in currentValues):
      raise ApiError("""%s.addMeasureListSerial:
       value is in list already""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      pass

    currentValues.add(value)
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('addMeasureListSerial')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  def addMeasurementList(self, value):
    """
    add function for drived link measurementLists
    """
    dataDict = self.__dict__
    from ccp.api.nmr.Nmr import AbstractMeasurementList as importedType
    if (not isinstance(value, importedType)):
      raise ApiError("""%s.addMeasurementList:
       value is not of class ccp.nmr.Nmr.AbstractMeasurementList""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = self.getMeasurementLists()
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.addMeasurementList:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.addMeasurementList:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.addMeasurementList:
       called with deleted value""" % self.qualifiedName
      )

    if (value in currentValues):
      raise ApiError("""%s.addMeasurementList:
       value is in list already""" % self.qualifiedName
       + ": %s" % (self,)
      )

    self.addMeasureListSerial(value.serial)
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

  def addNmrConstraintListValidation(self, value):
    """
    Add for
    ccp.nmr.NmrConstraint.AbstractConstraintList.nmrConstraintListValidations
    """
    dataDict = self.__dict__
    from ccp.api.molecule.Validation import NmrConstraintListValidation as importedType
    if (not isinstance(value, importedType)):
      raise ApiError("""%s.addNmrConstraintListValidation:
       value is not of class ccp.molecule.Validation.NmrConstraintListValidation""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('nmrConstraintListValidations')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      topObject = value.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)
      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.addNmrConstraintListValidation:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.addNmrConstraintListValidation:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.addNmrConstraintListValidation:
       called with deleted value""" % self.qualifiedName
      )

    if (value in currentValues):
      raise ApiError("""%s.addNmrConstraintListValidation:
       value is in list already""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      if (value is not None):
        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        yy2 = yy1.__dict__.get('nmrConstraintStore')
        if (not (xx1 is yy2)):
          raise ApiError("""%s.addNmrConstraintListValidation:
           Link nmrConstraintListValidations between objects from separate partitions
           - ccp.molecule.Validation.ValidationStore.nmrConstraintStore not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      if (notInConstructor):
        if (value is not None):
          ll= value.keywordDefinition.targetNames
          isValid = (not ll or self.qualifiedName in ll)
          if (not (isValid)):
            raise ApiError("""%s.addNmrConstraintListValidation:
             nmrConstraintListValidations constraint KeywordDefinition_fits_ConstraintList violated by value""" % self.qualifiedName
             + ": %s" % (value,)
            )

    oldSelves = value.__dict__.get('nmrConstraintLists')
    oldSelves.add(self)
    currentValues.add(value)
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('addNmrConstraintListValidation')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  def addNmrSimEnergyTerm(self, value):
    """
    Add for ccp.nmr.NmrConstraint.AbstractConstraintList.nmrSimEnergyTerms
    """
    dataDict = self.__dict__
    from molsim.api.NmrSim import NmrSimEnergyTerm as importedType
    if (not isinstance(value, importedType)):
      raise ApiError("""%s.addNmrSimEnergyTerm:
       value is not of class molsim.NmrSim.NmrSimEnergyTerm""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    root = dataDict.get('topObject').__dict__.get('memopsRoot')
    root.refreshTopObjects('molsim.NmrSim')
    tobjList = root.__dict__.get('nmrSimStores').values()
    for tobj in tobjList:
      if (not (tobj.__dict__.get('isLoaded'))):
        tobj.load()

    currentValues = dataDict.get('nmrSimEnergyTerms')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      topObject = value.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)
      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.addNmrSimEnergyTerm:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.addNmrSimEnergyTerm:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.addNmrSimEnergyTerm:
       called with deleted value""" % self.qualifiedName
      )

    if (value in currentValues):
      raise ApiError("""%s.addNmrSimEnergyTerm:
       value is in list already""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      if (value is not None):
        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('run')
        yy2 = yy1.__dict__.get('inputConstraintStore')
        if (not (xx1 is yy2)):
          raise ApiError("""%s.addNmrSimEnergyTerm:
           Link nmrSimEnergyTerms between objects from separate partitions
           - molsim.NmrSim.Run.inputConstraintStore not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    oldSelves = value.__dict__.get('constraintLists')
    oldSelves.add(self)
    currentValues.add(value)
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('addNmrSimEnergyTerm')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  checkAllValid = memops.api.Implementation.ComplexDataType.checkAllValid

  checkValid = memops.api.Implementation.ComplexDataType.checkValid

  delete = memops.api.Implementation.DataObject.delete

  findAllApplicationData = memops.api.Implementation.DataObject.findAllApplicationData
  
  def findAllConstraints(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.AbstractConstraintList.constraints
    """
    dataDict = self.__dict__
    raise ApiError("""%s.findAllConstraints:
     findAllConstraints should never be called - must be overridden in subclass""" % self.qualifiedName
     + ": %s" % (self,)
    )
  
  def findAllExperiments(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.AbstractConstraintList.experiments
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = self.getExperiments()
      result = set(currentValues)

    else:
      currentValues = self.getExperiments()
      result = set()
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('date', 'details', 'name', 'nmrTubeType', 'numDim', 'numScans', 'sampleState', 'sampleVolume', 'serial', 'spinningAngle', 'spinningRate', 'volumeUnit', 'access', 'derivationMethod', 'dipolarRelaxList', 'hExchProtectionList', 'hExchRateList', 'isotropicS2List', 'jCouplingList', 'nmrProject', 'noeList', 'pkaList', 'probe', 'rawData', 'rdcList', 'refExperiment', 'sample', 'sampleConditionSet', 'shiftAnisotropyList', 'shiftDifferenceList', 'shiftList', 'spectralDensityList', 'spectrometer', 't1List', 't1rhoList', 't2List',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result.add(v)

    return result
  
  def findAllMeasurementLists(self, **conditions):
    """
    FindAll for
    ccp.nmr.NmrConstraint.AbstractConstraintList.measurementLists
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = self.getMeasurementLists()
      result = set(currentValues)

    else:
      currentValues = self.getMeasurementLists()
      result = set()
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('details', 'isSimulated', 'name', 'serial', 'unit', 'access', 'method', 'nmrProject', 'outputFromNmrRun',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result.add(v)

    return result
  
  def findAllNmrConstraintListValidations(self, **conditions):
    """
    FindAll for
    ccp.nmr.NmrConstraint.AbstractConstraintList.nmrConstraintListValidations
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('nmrConstraintListValidations')
      result = set(currentValues)

    else:
      currentValues = dataDict.get('nmrConstraintListValidations')
      result = set()
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('booleanValue', 'context', 'details', 'figOfMerit', 'floatValue', 'intValue', 'keyword', 'serial', 'textValue', 'access', 'validationStore',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result.add(v)

    return result
  
  def findAllNmrSimEnergyTerms(self, **conditions):
    """
    FindAll for
    ccp.nmr.NmrConstraint.AbstractConstraintList.nmrSimEnergyTerms
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      root = dataDict.get('topObject').__dict__.get('memopsRoot')
      root.refreshTopObjects('molsim.NmrSim')
      tobjList = root.__dict__.get('nmrSimStores').values()
      for tobj in tobjList:
        if (not (tobj.__dict__.get('isLoaded'))):
          tobj.load()

      currentValues = dataDict.get('nmrSimEnergyTerms')
      result = set(currentValues)

    else:
      root = dataDict.get('topObject').__dict__.get('memopsRoot')
      root.refreshTopObjects('molsim.NmrSim')
      tobjList = root.__dict__.get('nmrSimStores').values()
      for tobj in tobjList:
        if (not (tobj.__dict__.get('isLoaded'))):
          tobj.load()

      currentValues = dataDict.get('nmrSimEnergyTerms')
      result = set()
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('code', 'details', 'name', 'termId', 'access', 'energyTerm', 'run',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result.add(v)

    return result

  findFirstApplicationData = memops.api.Implementation.DataObject.findFirstApplicationData
  
  def findFirstConstraint(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.AbstractConstraintList.constraints
    """
    dataDict = self.__dict__
    raise ApiError("""%s.findFirstConstraint:
     findFirstConstraint should never be called - must be overridden in subclass""" % self.qualifiedName
     + ": %s" % (self,)
    )
  
  def findFirstExperiment(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.AbstractConstraintList.experiments
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = self.getExperiments()
      if (currentValues):
        result = iter(currentValues).next()
      else:
        result = None

    else:
      currentValues = self.getExperiments()
      result = None
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('date', 'details', 'name', 'nmrTubeType', 'numDim', 'numScans', 'sampleState', 'sampleVolume', 'serial', 'spinningAngle', 'spinningRate', 'volumeUnit', 'access', 'derivationMethod', 'dipolarRelaxList', 'hExchProtectionList', 'hExchRateList', 'isotropicS2List', 'jCouplingList', 'nmrProject', 'noeList', 'pkaList', 'probe', 'rawData', 'rdcList', 'refExperiment', 'sample', 'sampleConditionSet', 'shiftAnisotropyList', 'shiftDifferenceList', 'shiftList', 'spectralDensityList', 'spectrometer', 't1List', 't1rhoList', 't2List',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result = v; break

    return result
  
  def findFirstMeasurementList(self, **conditions):
    """
    FindFirst for
    ccp.nmr.NmrConstraint.AbstractConstraintList.measurementLists
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = self.getMeasurementLists()
      if (currentValues):
        result = iter(currentValues).next()
      else:
        result = None

    else:
      currentValues = self.getMeasurementLists()
      result = None
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('details', 'isSimulated', 'name', 'serial', 'unit', 'access', 'method', 'nmrProject', 'outputFromNmrRun',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result = v; break

    return result
  
  def findFirstNmrConstraintListValidation(self, **conditions):
    """
    FindFirst for
    ccp.nmr.NmrConstraint.AbstractConstraintList.nmrConstraintListValidations
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('nmrConstraintListValidations')
      if (currentValues):
        result = iter(currentValues).next()
      else:
        result = None

    else:
      currentValues = dataDict.get('nmrConstraintListValidations')
      result = None
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('booleanValue', 'context', 'details', 'figOfMerit', 'floatValue', 'intValue', 'keyword', 'serial', 'textValue', 'access', 'validationStore',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result = v; break

    return result
  
  def findFirstNmrSimEnergyTerm(self, **conditions):
    """
    FindFirst for
    ccp.nmr.NmrConstraint.AbstractConstraintList.nmrSimEnergyTerms
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      root = dataDict.get('topObject').__dict__.get('memopsRoot')
      root.refreshTopObjects('molsim.NmrSim')
      tobjList = root.__dict__.get('nmrSimStores').values()
      for tobj in tobjList:
        if (not (tobj.__dict__.get('isLoaded'))):
          tobj.load()

      currentValues = dataDict.get('nmrSimEnergyTerms')
      if (currentValues):
        result = iter(currentValues).next()
      else:
        result = None

    else:
      root = dataDict.get('topObject').__dict__.get('memopsRoot')
      root.refreshTopObjects('molsim.NmrSim')
      tobjList = root.__dict__.get('nmrSimStores').values()
      for tobj in tobjList:
        if (not (tobj.__dict__.get('isLoaded'))):
          tobj.load()

      currentValues = dataDict.get('nmrSimEnergyTerms')
      result = None
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('code', 'details', 'name', 'termId', 'access', 'energyTerm', 'run',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result = v; break

    return result

  getAccess = memops.api.Implementation.DataObject.getAccess

  getApplicationData = memops.api.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.AbstractConstraintList
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (2 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.AbstractConstraintList'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (1 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.AbstractConstraintList'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-1]
      obj2 = obj1.__dict__.get('constraintLists').get(objKey)
      result = obj2

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = memops.api.Implementation.MemopsObject.getByNavigation

  getClassName = memops.api.Implementation.ComplexDataType.getClassName
  
  def getConditionState(self):
    """
    Get for ccp.nmr.NmrConstraint.AbstractConstraintList.conditionState
    """
    dataDict = self.__dict__
    result = dataDict.get('conditionState')
    return result
  
  def getConstraints(self):
    """
    Get for ccp.nmr.NmrConstraint.AbstractConstraintList.constraints
    """
    dataDict = self.__dict__
    raise ApiError("""%s.getConstraints:
     getConstraints should never be called - must be overridden in subclass""" % self.qualifiedName
     + ": %s" % (self,)
    )
  
  def getDetails(self):
    """
    Get for ccp.nmr.NmrConstraint.AbstractConstraintList.details
    """
    dataDict = self.__dict__
    result = dataDict.get('details')
    return result

  getExpandedKey = memops.api.Implementation.MemopsObject.getExpandedKey
  
  def getExperimentSerials(self):
    """
    Get for ccp.nmr.NmrConstraint.AbstractConstraintList.experimentSerials
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('experimentSerials')
    result = frozenset(tempVar)
    return result
  
  def getExperiments(self):
    """
    getter for derived link experiments
    """
    dataDict = self.__dict__
    func = self.nmrConstraintStore.nmrProject.findFirstExperiment
    aset = set(func(serial=x) for x in self.experimentSerials)
    if None in aset:
      aset.remove(None)
    result = frozenset(aset)
    return result

  getFieldNames = memops.api.Implementation.ComplexDataType.getFieldNames
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccp.nmr.NmrConstraint.AbstractConstraintList
    """
    dataDict = self.__dict__
    result = list()

    obj1 = dataDict.get('nmrConstraintStore')

    if (useGuid):
      result.append(obj1.__dict__.get('guid'))
    else:
      result.append(obj1.__dict__.get('serial'))

    result.append(dataDict.get('serial'))

    return result

  getInConstructor = memops.api.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = memops.api.Implementation.MemopsObject.getIsDeleted
  
  def getLocalKey(self):
    """
    GetLocalKey for ccp.nmr.NmrConstraint.AbstractConstraintList
    """
    dataDict = self.__dict__
    result = dataDict.get('serial')
    return result
  
  def getMeasureListSerials(self):
    """
    Get for ccp.nmr.NmrConstraint.AbstractConstraintList.measureListSerials
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('measureListSerials')
    result = frozenset(tempVar)
    return result
  
  def getMeasurementLists(self):
    """
    getter for derived link measurementLists
    """
    dataDict = self.__dict__
    func = self.nmrConstraintStore.nmrProject.findFirstMeasurementList
    aset = set(func(serial=x) for x in self.measureListSerials)
    if None in aset:
      aset.remove(None)
    result = frozenset(aset)
    return result

  getMetaclass = memops.api.Implementation.ComplexDataType.getMetaclass
  
  def getMethod(self):
    """
    Get for ccp.nmr.NmrConstraint.AbstractConstraintList.method
    """
    dataDict = self.__dict__
    result = dataDict.get('method')
    return result
  
  def getName(self):
    """
    Get for ccp.nmr.NmrConstraint.AbstractConstraintList.name
    """
    dataDict = self.__dict__
    result = dataDict.get('name')
    return result
  
  def getNmrConstraintListValidations(self):
    """
    Get for
    ccp.nmr.NmrConstraint.AbstractConstraintList.nmrConstraintListValidations
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('nmrConstraintListValidations')
    result = frozenset(tempVar)
    return result
  
  def getNmrConstraintStore(self):
    """
    Get for ccp.nmr.NmrConstraint.AbstractConstraintList.nmrConstraintStore
    """
    dataDict = self.__dict__
    result = dataDict.get('nmrConstraintStore')
    return result
  
  def getNmrSimEnergyTerms(self):
    """
    Get for ccp.nmr.NmrConstraint.AbstractConstraintList.nmrSimEnergyTerms
    """
    dataDict = self.__dict__
    root = dataDict.get('topObject').__dict__.get('memopsRoot')
    root.refreshTopObjects('molsim.NmrSim')
    tobjList = root.__dict__.get('nmrSimStores').values()
    for tobj in tobjList:
      if (not (tobj.__dict__.get('isLoaded'))):
        tobj.load()

    tempVar = dataDict.get('nmrSimEnergyTerms')
    result = frozenset(tempVar)
    return result

  getPackageName = memops.api.Implementation.ComplexDataType.getPackageName

  getPackageShortName = memops.api.Implementation.ComplexDataType.getPackageShortName
  
  def getParent(self):
    """
    Get for ccp.nmr.NmrConstraint.AbstractConstraintList.parent
    """
    dataDict = self.__dict__
    result = dataDict.get('nmrConstraintStore')
    return result

  getQualifiedName = memops.api.Implementation.ComplexDataType.getQualifiedName

  getRoot = memops.api.Implementation.MemopsObject.getRoot
  
  def getSerial(self):
    """
    Get for ccp.nmr.NmrConstraint.AbstractConstraintList.serial
    """
    dataDict = self.__dict__
    result = dataDict.get('serial')
    return result

  getTopObject = memops.api.Implementation.DataObject.getTopObject
  
  def getUnit(self):
    """
    Get for ccp.nmr.NmrConstraint.AbstractConstraintList.unit
    """
    dataDict = self.__dict__
    result = dataDict.get('unit')
    return result
  
  def getUsedForCalculation(self):
    """
    Get for ccp.nmr.NmrConstraint.AbstractConstraintList.usedForCalculation
    """
    dataDict = self.__dict__
    result = dataDict.get('usedForCalculation')
    return result

  removeApplicationData = memops.api.Implementation.DataObject.removeApplicationData
  
  def removeExperiment(self, value):
    """
    remove function for derived link experiments
    """
    dataDict = self.__dict__
    from ccp.api.nmr.Nmr import Experiment as importedType
    if (not isinstance(value, importedType)):
      raise ApiError("""%s.removeExperiment:
       value is not of class ccp.nmr.Nmr.Experiment""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = self.getExperiments()
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.removeExperiment:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.removeExperiment:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.removeExperiment:
       called with deleted value""" % self.qualifiedName
      )

    if (not (value in currentValues)):
      raise ApiError("""%s.removeExperiment:
       value not in list""" % self.qualifiedName
       + ": %s" % (self,)
      )

    self.removeExperimentSerial(value.serial)
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

  def removeExperimentSerial(self, value):
    """
    Remove for
    ccp.nmr.NmrConstraint.AbstractConstraintList.experimentSerials
    """
    dataDict = self.__dict__
    if (isinstance(value, memops.api.Implementation.Int.PythonType)):
      pass
    elif ([x for x in memops.api.Implementation.Int.compatibleTypes if isinstance(value, x)]):
      value = memops.api.Implementation.Int.create(value)
    else:
      raise ApiError("""%s.removeExperimentSerial:
       memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('experimentSerials')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.removeExperimentSerial:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.removeExperimentSerial:
       called on deleted object""" % self.qualifiedName
      )

    if (not (value in currentValues)):
      raise ApiError("""%s.removeExperimentSerial:
       value not in list""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      pass

    currentValues.remove(value)
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('removeExperimentSerial')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  def removeMeasureListSerial(self, value):
    """
    Remove for
    ccp.nmr.NmrConstraint.AbstractConstraintList.measureListSerials
    """
    dataDict = self.__dict__
    if (isinstance(value, memops.api.Implementation.Int.PythonType)):
      pass
    elif ([x for x in memops.api.Implementation.Int.compatibleTypes if isinstance(value, x)]):
      value = memops.api.Implementation.Int.create(value)
    else:
      raise ApiError("""%s.removeMeasureListSerial:
       memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('measureListSerials')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.removeMeasureListSerial:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.removeMeasureListSerial:
       called on deleted object""" % self.qualifiedName
      )

    if (not (value in currentValues)):
      raise ApiError("""%s.removeMeasureListSerial:
       value not in list""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      pass

    currentValues.remove(value)
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('removeMeasureListSerial')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  def removeMeasurementList(self, value):
    """
    remove function for derived link measurementLists
    """
    dataDict = self.__dict__
    from ccp.api.nmr.Nmr import AbstractMeasurementList as importedType
    if (not isinstance(value, importedType)):
      raise ApiError("""%s.removeMeasurementList:
       value is not of class ccp.nmr.Nmr.AbstractMeasurementList""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = self.getMeasurementLists()
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.removeMeasurementList:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.removeMeasurementList:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.removeMeasurementList:
       called with deleted value""" % self.qualifiedName
      )

    if (not (value in currentValues)):
      raise ApiError("""%s.removeMeasurementList:
       value not in list""" % self.qualifiedName
       + ": %s" % (self,)
      )

    self.removeMeasureListSerial(value.serial)
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

  def removeNmrConstraintListValidation(self, value):
    """
    Remove for
    ccp.nmr.NmrConstraint.AbstractConstraintList.nmrConstraintListValidations
    """
    dataDict = self.__dict__
    from ccp.api.molecule.Validation import NmrConstraintListValidation as importedType
    if (not isinstance(value, importedType)):
      raise ApiError("""%s.removeNmrConstraintListValidation:
       value is not of class ccp.molecule.Validation.NmrConstraintListValidation""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('nmrConstraintListValidations')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      topObject = value.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)
      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.removeNmrConstraintListValidation:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.removeNmrConstraintListValidation:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.removeNmrConstraintListValidation:
       called with deleted value""" % self.qualifiedName
      )

    if (not (value in currentValues)):
      raise ApiError("""%s.removeNmrConstraintListValidation:
       value not in list""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      pass

    oldSelves = value.__dict__.get('nmrConstraintLists')
    oldSelves.remove(self)
    currentValues.remove(value)
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('removeNmrConstraintListValidation')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  def removeNmrSimEnergyTerm(self, value):
    """
    Remove for
    ccp.nmr.NmrConstraint.AbstractConstraintList.nmrSimEnergyTerms
    """
    dataDict = self.__dict__
    from molsim.api.NmrSim import NmrSimEnergyTerm as importedType
    if (not isinstance(value, importedType)):
      raise ApiError("""%s.removeNmrSimEnergyTerm:
       value is not of class molsim.NmrSim.NmrSimEnergyTerm""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    root = dataDict.get('topObject').__dict__.get('memopsRoot')
    root.refreshTopObjects('molsim.NmrSim')
    tobjList = root.__dict__.get('nmrSimStores').values()
    for tobj in tobjList:
      if (not (tobj.__dict__.get('isLoaded'))):
        tobj.load()

    currentValues = dataDict.get('nmrSimEnergyTerms')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      topObject = value.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)
      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.removeNmrSimEnergyTerm:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.removeNmrSimEnergyTerm:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.removeNmrSimEnergyTerm:
       called with deleted value""" % self.qualifiedName
      )

    if (not (value in currentValues)):
      raise ApiError("""%s.removeNmrSimEnergyTerm:
       value not in list""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      pass

    oldSelves = value.__dict__.get('constraintLists')
    oldSelves.remove(self)
    currentValues.remove(value)
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('removeNmrSimEnergyTerm')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  setAccess = memops.api.Implementation.DataObject.setAccess

  setApplicationData = memops.api.Implementation.DataObject.setApplicationData
  
  def setConditionState(self, value):
    """
    Set for ccp.nmr.NmrConstraint.AbstractConstraintList.conditionState
    """
    dataDict = self.__dict__
    if (value is not None):
      if (not isinstance(value, ConditionState)):
        raise ApiError("""%s.setConditionState:
         value is not of class ccp.nmr.NmrConstraint.ConditionState""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('conditionState')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setConditionState:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setConditionState:
       called on deleted object""" % self.qualifiedName
      )

    if (value is not None):
      if (value.__dict__.get('isDeleted')):
        raise ApiError("""%s.setConditionState:
         called with deleted value""" % self.qualifiedName
        )

    if (value == currentValue):
      return

    if (notOverride):
      if (value is not None):
        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setConditionState:
           Link conditionState between objects from separate partitions
           - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    if (currentValue is not None):
      if (notIsReading):
        oldSelves = currentValue.__dict__.get('constraintLists')
        oldSelves.remove(self)
      else:
        raise ApiError("""%s.setConditionState:
         Read link 'conditionState' incompatible with pre-existing link""" % self.qualifiedName
         + ": %s" % (self,)
        )

    if (value is not None):
      newSelves = value.__dict__.get('constraintLists')
      newSelves.add(self)

    dataDict['conditionState'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setConditionState')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  def setDetails(self, value):
    """
    Set for ccp.nmr.NmrConstraint.AbstractConstraintList.details
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, memops.api.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.setDetails:
         memops.Implementation.String input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('details')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setDetails:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setDetails:
       called on deleted object""" % self.qualifiedName
      )

    if (value == currentValue):
      return

    if (notOverride):
      pass

    dataDict['details'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setDetails')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  def setExperimentSerials(self, values):
    """
    Set for ccp.nmr.NmrConstraint.AbstractConstraintList.experimentSerials
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setExperimentSerials:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      if (isinstance(value, memops.api.Implementation.Int.PythonType)):
        pass
      elif ([x for x in memops.api.Implementation.Int.compatibleTypes if isinstance(value, x)]):
        castValue = memops.api.Implementation.Int.create(value)
        values.remove(value)
        if (castValue in values):
          values.add(value)
          raise ApiError("""%s.setExperimentSerials:
           replacement value already in unique collection """ % self.qualifiedName
           + ": %s" % (castValue,)
          )
        else:
          values.add(castValue)

        value = castValue
      else:
        raise ApiError("""%s.setExperimentSerials:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('experimentSerials')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setExperimentSerials:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setExperimentSerials:
       called on deleted object""" % self.qualifiedName
      )

    if (values == currentValues):
      return

    if (notOverride):
      pass

    dataDict['experimentSerials'] = values
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setExperimentSerials')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  def setExperiments(self, values):
    """
    setter for derived link experiments
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setExperiments:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      from ccp.api.nmr.Nmr import Experiment as importedType
      if (not isinstance(value, importedType)):
        raise ApiError("""%s.setExperiments:
         value is not of class ccp.nmr.Nmr.Experiment""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = self.getExperiments()
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setExperiments:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setExperiments:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setExperiments:
         an object in values is deleted""" % self.qualifiedName
        )

    if (values == currentValues):
      return

    self.experimentSerials = [x.serial for x in values]
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

  def setMeasureListSerials(self, values):
    """
    Set for ccp.nmr.NmrConstraint.AbstractConstraintList.measureListSerials
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setMeasureListSerials:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      if (isinstance(value, memops.api.Implementation.Int.PythonType)):
        pass
      elif ([x for x in memops.api.Implementation.Int.compatibleTypes if isinstance(value, x)]):
        castValue = memops.api.Implementation.Int.create(value)
        values.remove(value)
        if (castValue in values):
          values.add(value)
          raise ApiError("""%s.setMeasureListSerials:
           replacement value already in unique collection """ % self.qualifiedName
           + ": %s" % (castValue,)
          )
        else:
          values.add(castValue)

        value = castValue
      else:
        raise ApiError("""%s.setMeasureListSerials:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('measureListSerials')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setMeasureListSerials:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setMeasureListSerials:
       called on deleted object""" % self.qualifiedName
      )

    if (values == currentValues):
      return

    if (notOverride):
      pass

    dataDict['measureListSerials'] = values
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setMeasureListSerials')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  def setMeasurementLists(self, values):
    """
    setter for derived link measurementLists
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setMeasurementLists:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      from ccp.api.nmr.Nmr import AbstractMeasurementList as importedType
      if (not isinstance(value, importedType)):
        raise ApiError("""%s.setMeasurementLists:
         value is not of class ccp.nmr.Nmr.AbstractMeasurementList""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = self.getMeasurementLists()
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setMeasurementLists:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setMeasurementLists:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setMeasurementLists:
         an object in values is deleted""" % self.qualifiedName
        )

    if (values == currentValues):
      return

    self.measureListSerials = [x.serial for x in values]
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

  def setMethod(self, value):
    """
    Set for ccp.nmr.NmrConstraint.AbstractConstraintList.method
    """
    dataDict = self.__dict__
    if (value is not None):
      from ccp.api.general.Method import Method as importedType
      if (not isinstance(value, importedType)):
        raise ApiError("""%s.setMethod:
         value is not of class ccp.general.Method.Method""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('method')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setMethod:
       called on deleted object""" % self.qualifiedName
      )

    if (value is not None):
      if (value.__dict__.get('isDeleted')):
        raise ApiError("""%s.setMethod:
         called with deleted value""" % self.qualifiedName
        )

    if (value == currentValue):
      return

    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setMethod:
         cannot set method, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is not None):
        xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setMethod:
           Link method between objects from separate partitions
           - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    if (currentValue is not None):
      if (notIsReading):
        oldSelves = currentValue.__dict__.get('constraintLists')
        oldSelves.remove(self)
      else:
        raise ApiError("""%s.setMethod:
         Read link 'method' incompatible with pre-existing link""" % self.qualifiedName
         + ": %s" % (self,)
        )

    if (value is not None):
      newSelves = value.__dict__.get('constraintLists')
      newSelves.add(self)

    dataDict['method'] = value

    # doNotifies
  
  def setName(self, value):
    """
    Set for ccp.nmr.NmrConstraint.AbstractConstraintList.name
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, memops.api.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.setName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.setName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.setName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.setName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('name')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setName:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setName:
       called on deleted object""" % self.qualifiedName
      )

    if (value == currentValue):
      return

    if (notOverride):
      pass

    dataDict['name'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setName')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  def setNmrConstraintListValidations(self, values):
    """
    Set for
    ccp.nmr.NmrConstraint.AbstractConstraintList.nmrConstraintListValidations
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setNmrConstraintListValidations:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      from ccp.api.molecule.Validation import NmrConstraintListValidation as importedType
      if (not isinstance(value, importedType)):
        raise ApiError("""%s.setNmrConstraintListValidations:
         value is not of class ccp.molecule.Validation.NmrConstraintListValidation""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('nmrConstraintListValidations')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      for pv in currentValues:
        if (not (pv in values)):
          topObject = pv.__dict__.get('topObject')
          topObjectsToCheck.add(topObject)

      for pv in values:
        if (not (pv in currentValues)):
          topObject = pv.__dict__.get('topObject')
          topObjectsToCheck.add(topObject)

      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setNmrConstraintListValidations:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setNmrConstraintListValidations:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setNmrConstraintListValidations:
         an object in values is deleted""" % self.qualifiedName
        )

    if (values == currentValues):
      return

    if (notOverride):
      xx1 = dataDict.get('topObject')
      for value in values:
        yy1 = value.__dict__.get('topObject')
        yy2 = yy1.__dict__.get('nmrConstraintStore')
        if (not (xx1 is yy2)):
          raise ApiError("""%s.setNmrConstraintListValidations:
           Link nmrConstraintListValidations between objects from separate partitions
           - ccp.molecule.Validation.ValidationStore.nmrConstraintStore not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      if (notInConstructor):
        for value in values:
          ll= value.keywordDefinition.targetNames
          isValid = (not ll or self.qualifiedName in ll)
          if (not (isValid)):
            raise ApiError("""%s.setNmrConstraintListValidations:
             nmrConstraintListValidations constraint KeywordDefinition_fits_ConstraintList violated by value""" % self.qualifiedName
             + ": %s" % (value,)
            )

    for cv in currentValues:
      if (not (cv in values)):
        oldSelves = cv.__dict__.get('nmrConstraintLists')
        oldSelves.remove(self)

    for cv in values:
      if (not (cv in currentValues)):
        oldSelves = cv.__dict__.get('nmrConstraintLists')
        oldSelves.add(self)

    dataDict['nmrConstraintListValidations'] = values
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setNmrConstraintListValidations')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  def setNmrSimEnergyTerms(self, values):
    """
    Set for ccp.nmr.NmrConstraint.AbstractConstraintList.nmrSimEnergyTerms
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setNmrSimEnergyTerms:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      from molsim.api.NmrSim import NmrSimEnergyTerm as importedType
      if (not isinstance(value, importedType)):
        raise ApiError("""%s.setNmrSimEnergyTerms:
         value is not of class molsim.NmrSim.NmrSimEnergyTerm""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    root = dataDict.get('topObject').__dict__.get('memopsRoot')
    root.refreshTopObjects('molsim.NmrSim')
    tobjList = root.__dict__.get('nmrSimStores').values()
    for tobj in tobjList:
      if (not (tobj.__dict__.get('isLoaded'))):
        tobj.load()

    currentValues = dataDict.get('nmrSimEnergyTerms')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      for pv in currentValues:
        if (not (pv in values)):
          topObject = pv.__dict__.get('topObject')
          topObjectsToCheck.add(topObject)

      for pv in values:
        if (not (pv in currentValues)):
          topObject = pv.__dict__.get('topObject')
          topObjectsToCheck.add(topObject)

      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setNmrSimEnergyTerms:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setNmrSimEnergyTerms:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setNmrSimEnergyTerms:
         an object in values is deleted""" % self.qualifiedName
        )

    if (values == currentValues):
      return

    if (notOverride):
      xx1 = dataDict.get('topObject')
      for value in values:
        yy1 = value.__dict__.get('run')
        yy2 = yy1.__dict__.get('inputConstraintStore')
        if (not (xx1 is yy2)):
          raise ApiError("""%s.setNmrSimEnergyTerms:
           Link nmrSimEnergyTerms between objects from separate partitions
           - molsim.NmrSim.Run.inputConstraintStore not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    for cv in currentValues:
      if (not (cv in values)):
        oldSelves = cv.__dict__.get('constraintLists')
        oldSelves.remove(self)

    for cv in values:
      if (not (cv in currentValues)):
        oldSelves = cv.__dict__.get('constraintLists')
        oldSelves.add(self)

    dataDict['nmrSimEnergyTerms'] = values
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setNmrSimEnergyTerms')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  def setSerial(self, value):
    """
    Set for ccp.nmr.NmrConstraint.AbstractConstraintList.serial
    """
    dataDict = self.__dict__
    if (isinstance(value, memops.api.Implementation.Int.PythonType)):
      pass
    elif ([x for x in memops.api.Implementation.Int.compatibleTypes if isinstance(value, x)]):
      value = memops.api.Implementation.Int.create(value)
    else:
      raise ApiError("""%s.setSerial:
       memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('serial')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setSerial:
       called on deleted object""" % self.qualifiedName
      )

    if (value == currentValue):
      return

    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setSerial:
         cannot set serial, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is None):
        raise ApiError("""%s.setSerial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    parent = dataDict.get('nmrConstraintStore')
    oldSerial = parent.__dict__.get('_serialDict').get('constraintLists')
    if (value < 0):
      value = (oldSerial + 1)
      parent.__dict__.get('_serialDict')['constraintLists'] = value
    elif (value > oldSerial):
      parent.__dict__.get('_serialDict')['constraintLists'] = value

    dataDict['serial'] = value

    # doNotifies
  
  def setUnit(self, value):
    """
    Set for ccp.nmr.NmrConstraint.AbstractConstraintList.unit
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, memops.api.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.setUnit:
         memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 32):
        raise ApiError("""%s.setUnit:
         memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.setUnit:
         memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.split()) == 1)):
        raise ApiError("""%s.setUnit:
         Word constraint contains_no_white_space violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('unit')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setUnit:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setUnit:
       called on deleted object""" % self.qualifiedName
      )

    if (value == currentValue):
      return

    if (notOverride):
      pass

    dataDict['unit'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setUnit')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  def setUsedForCalculation(self, value):
    """
    Set for ccp.nmr.NmrConstraint.AbstractConstraintList.usedForCalculation
    """
    dataDict = self.__dict__
    if (not (value in [True, False])):
      raise ApiError("""%s.setUsedForCalculation:
       memops.Implementation.Boolean input is not in enumeration [True, False]""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('usedForCalculation')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setUsedForCalculation:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setUsedForCalculation:
       called on deleted object""" % self.qualifiedName
      )

    if (value == currentValue):
      return

    if (notOverride):
      if (value is None):
        raise ApiError("""%s.setUsedForCalculation:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    dataDict['usedForCalculation'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setUsedForCalculation')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  def sortedConstraints(self):
    """
    Sorted for ccp.nmr.NmrConstraint.AbstractConstraintList.constraints
    """
    dataDict = self.__dict__
    raise ApiError("""%s.sortedConstraints:
     sortedConstraints should never be called - must be overridden in subclass""" % self.qualifiedName
     + ": %s" % (self,)
    )
  
  def sortedExperiments(self):
    """
    Sorted for ccp.nmr.NmrConstraint.AbstractConstraintList.experiments
    """
    dataDict = self.__dict__
    ll = self.getExperiments()
    ll = [(x.getFullKey(),x) for x in ll]
    
    ll.sort()
    result = [x[1] for x in ll]
    return result
  
  def sortedMeasurementLists(self):
    """
    Sorted for ccp.nmr.NmrConstraint.AbstractConstraintList.measurementLists
    """
    dataDict = self.__dict__
    ll = self.getMeasurementLists()
    ll = [(x.getFullKey(),x) for x in ll]
    
    ll.sort()
    result = [x[1] for x in ll]
    return result
  
  def sortedNmrConstraintListValidations(self):
    """
    Sorted for
    ccp.nmr.NmrConstraint.AbstractConstraintList.nmrConstraintListValidations
    """
    dataDict = self.__dict__
    ll = dataDict.get('nmrConstraintListValidations')
    ll = [(repr(x),x) for x in ll]
    
    ll.sort()
    result = [x[1] for x in ll]
    return result
  
  def sortedNmrSimEnergyTerms(self):
    """
    Sorted for
    ccp.nmr.NmrConstraint.AbstractConstraintList.nmrSimEnergyTerms
    """
    dataDict = self.__dict__
    root = dataDict.get('topObject').__dict__.get('memopsRoot')
    root.refreshTopObjects('molsim.NmrSim')
    tobjList = root.__dict__.get('nmrSimStores').values()
    for tobj in tobjList:
      if (not (tobj.__dict__.get('isLoaded'))):
        tobj.load()

    ll = dataDict.get('nmrSimEnergyTerms')
    ll = [(x.getFullKey(),x) for x in ll]
    
    ll.sort()
    result = [x[1] for x in ll]
    return result

  toDetailedString = memops.api.Implementation.ComplexDataType.toDetailedString

  applicationData = memops.api.Implementation.DataObject.applicationData

  className = memops.api.Implementation.ComplexDataType.className
  
  details = property(getDetails, setDetails, None,
  r"""free text containing notes, descriptive remarks, etc.
  """)
  
  experimentSerials = property(getExperimentSerials, setExperimentSerials, None,
  r"""Serials for experiments that have contributed to Constraints in 
  constraintList. Serve as key for derived link experiments
  """)

  fieldNames = memops.api.Implementation.ComplexDataType.fieldNames

  inConstructor = memops.api.Implementation.ComplexDataType.inConstructor

  isDeleted = memops.api.Implementation.MemopsObject.isDeleted
  
  measureListSerials = property(getMeasureListSerials, setMeasureListSerials, None,
  r"""Serials for measurementLists that have contributed to Constraints in 
  constraintList. Serve as key for derived link measurementLists.
  """)

  metaclass = memops.api.Implementation.ComplexDataType.metaclass
  
  name = property(getName, setName, None,
  r"""Name of constraint list. Serves as a descriptive addition to the serial 
  number.
  """)

  packageName = memops.api.Implementation.ComplexDataType.packageName

  packageShortName = memops.api.Implementation.ComplexDataType.packageShortName

  qualifiedName = memops.api.Implementation.ComplexDataType.qualifiedName
  
  serial = property(getSerial, setSerial, None,
  r"""The serial number is the key for class AbstractConstraintList and 
  together with the parent object serves as a unique identifier for the 
  AbstractConstraintList.
  Serial numbers are generated by the API. Serial 
  numbers of deleted objects are not reused.
  """)
  
  unit = property(getUnit, setUnit, None,
  r"""Measurement unit of listed constraints. Should be made into an 
  enumeration.
  """)
  
  usedForCalculation = property(getUsedForCalculation, setUsedForCalculation, None,
  r"""Determines if the ConstraintList was (or should be) used for structure 
  calculation.
  """)

  access = memops.api.Implementation.DataObject.access
  
  conditionState = property(getConditionState, setConditionState, None,
  r"""COndition set that COnstraint list refers to
  """)
  
  constraints = property(getConstraints,  None, None,
  r"""child link to class AbstractConstraint
  """)
  
  experiments = property(getExperiments, setExperiments, None,
  r"""Experiments from which ConstraintLists are derived. May be incomplete or 
  not set.
  """)
  
  measurementLists = property(getMeasurementLists, setMeasurementLists, None,
  r"""Measurement Lists used in deriving Constraint list
  """)
  
  method = property(getMethod, setMethod, None,
  r"""Default Method used for calculating Constraints in ConstraintList. May 
  be overwritten by Method for individual Constraints.
  """)
  
  nmrConstraintListValidations = property(getNmrConstraintListValidations, setNmrConstraintListValidations, None,
  r"""Validation results that include AbstractConstraintList
  """)
  
  nmrConstraintStore = property(getNmrConstraintStore,  None, None,
  r"""parent link
  """)
  
  nmrSimEnergyTerms = property(getNmrSimEnergyTerms, setNmrSimEnergyTerms, None,
  r"""RestraintGroups using ConstraintList
  """)
  
  parent = property(getParent, None, None,
  r"""link to parent object - synonym for nmrConstraintStore
  """)

  root = memops.api.Implementation.MemopsObject.root

  topObject = memops.api.Implementation.DataObject.topObject

###############################################################################
class ChainStateLink(memops.api.Implementation.DataObject):
  r"""Class holding (information for) derived link to Nmr.ChainState. 
  """
  #   from data model element ccp.nmr.NmrConstraint.ChainStateLink revision 1.40.2.9
  _metaclass = metaPackage.getElement('ChainStateLink')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('applicationData', 'chainStateSerial', 'chainStateSetSerial', 'className', 'fieldNames', 'inConstructor', 'isDeleted', 'metaclass', 'packageName', 'packageShortName', 'qualifiedName', 'access', 'chainState', 'fixedResonance', 'parent', 'root', 'topObject',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccp.nmr.NmrConstraint.ChainStateLink
    """
    dataDict = self.__dict__
    dataDict['fixedResonance'] = parent
    if (not isinstance(parent, FixedResonance)):
      raise ApiError("""%s.__init__:
       value is not of class ccp.nmr.NmrConstraint.FixedResonance""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:

      dataDict['applicationData'] = list()
      dataDict['chainStateSerial'] = None
      dataDict['chainStateSetSerial'] = None
      dataDict['access'] = None

      dataDict['inConstructor'] = True
      try:
        
        for key, value in attrlinks.iteritems():
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        del dataDict['inConstructor']
      except:
        print "ERROR in ccp.nmr.NmrConstraint.ChainStateLink.__init__"
        del dataDict['inConstructor']
        raise

      if (notIsReading):
        childrenDict = parent.__dict__.get('chainStateLinks')
        objKey = dataDict.get('chainStateSetSerial')
        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['chainStateSetSerial'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        print '''WARNING Error in clean-up of incorrectly created object. 
        Data may be left in an illegal state'''
        del dataDict['inConstructor']
      raise exc_info[0], exc_info[1], exc_info[2]

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccp.nmr.NmrConstraint.ChainStateLink:
       determines 
    cascading deletes to follow from delete of object.
       *Implementation 
    function* - should be called only by API delete function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
      dataDict.get('topObject').load()

    access = dataDict.get('access')
    if (access is not None):
      topObject = access.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccp.nmr.NmrConstraint.ChainStateLink:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    access = dataDict.get('access')
    if ((access is not None and not (access in objsToBeDeleted))):
      dataObjects = access.__dict__.get('dataObjects')
      dataObjects.remove(self)

    fixedResonance = dataDict.get('fixedResonance')
    if (not (fixedResonance in objsToBeDeleted)):
      objKey = dataDict.get('chainStateSetSerial')
      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = fixedResonance.__dict__.get('chainStateLinks')
        if (self is dd.get(objKey)):
          del dd[objKey]

  addApplicationData = memops.api.Implementation.DataObject.addApplicationData
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccp.nmr.NmrConstraint.ChainStateLink
    """
    dataDict = self.__dict__
    self.checkValid(complete)
  
  def checkValid(self, complete=False):
    """
    CheckValid for ccp.nmr.NmrConstraint.ChainStateLink
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('chainStateSetSerial')
      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('fixedResonance')
        dd = value.__dict__.get('chainStateLinks')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'fixedResonance' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from memops.api.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('chainStateSerial')
      if (isinstance(value, memops.api.Implementation.Int.PythonType)):
        pass
      elif ([x for x in memops.api.Implementation.Int.compatibleTypes if isinstance(value, x)]):
        value = memops.api.Implementation.Int.create(value)
      else:
        raise ApiError("""%s.checkValid: chainStateSerial:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('chainStateSetSerial')
      if (isinstance(value, memops.api.Implementation.Int.PythonType)):
        pass
      elif ([x for x in memops.api.Implementation.Int.compatibleTypes if isinstance(value, x)]):
        value = memops.api.Implementation.Int.create(value)
      else:
        raise ApiError("""%s.checkValid: chainStateSetSerial:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, memops.api.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('access')
      if (value is not None):
        from memops.api.AccessControl import AccessObject as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: access:
           value is not of class memops.AccessControl.AccessObject""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('dataObjects')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: access:
           non-reciprocal link ChainStateLink from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      value = self.getChainState()
      if (value is None):
        raise ApiError("""%s.checkValid: chainState:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      from ccp.api.nmr.Nmr import ChainState as importedType
      if (not isinstance(value, importedType)):
        raise ApiError("""%s.checkValid: chainState:
         value is not of class ccp.nmr.Nmr.ChainState""" % self.qualifiedName
         + ": %s" % (value,)
        )

      xx1 = dataDict.get('topObject')
      xx2 = xx1.__dict__.get('nmrProject')
      yy1 = value.__dict__.get('topObject')
      if (not (xx2 is yy1)):
        raise ApiError("""%s.checkValid: chainState:
         Link chainState between objects from separate partitions
         - ccp.nmr.NmrConstraint.NmrConstraintStore.nmrProject not set correctly""" % self.qualifiedName
         + ": %s:%s" % (self, value)
        )

      value = dataDict.get('fixedResonance')
      if (not isinstance(value, FixedResonance)):
        raise ApiError("""%s.checkValid: fixedResonance:
         value is not of class ccp.nmr.NmrConstraint.FixedResonance""" % self.qualifiedName
         + ": %s" % (value,)
        )

    # check explicit class constraints
    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('chainStateSerial')
    if (value is None):
      raise ApiError("""%s.checkValid: chainStateSerial:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    value = dataDict.get('chainStateSetSerial')
    if (value is None):
      raise ApiError("""%s.checkValid: chainStateSetSerial:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    # check roles
    value = dataDict.get('access')
    value = dataDict.get('fixedResonance')
    if (value is None):
      raise ApiError("""%s.checkValid: fixedResonance:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

  delete = memops.api.Implementation.DataObject.delete

  findAllApplicationData = memops.api.Implementation.DataObject.findAllApplicationData

  findFirstApplicationData = memops.api.Implementation.DataObject.findFirstApplicationData
  
  def get(self, name):
    """
    GetAttr for ccp.nmr.NmrConstraint.ChainStateLink
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getAccess = memops.api.Implementation.DataObject.getAccess

  getApplicationData = memops.api.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.ChainStateLink
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (3 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.ChainStateLink'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (2 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.ChainStateLink'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-2]
      obj2 = obj1.__dict__.get('fixedResonances').get(objKey)

      if (obj2 is not None):
        objKey = fullKey[-1]
        obj3 = obj2.__dict__.get('chainStateLinks').get(objKey)
        result = obj3

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = memops.api.Implementation.MemopsObject.getByNavigation
  
  def getChainState(self):
    """
    getter for derived link chainState
    """
    dataDict = self.__dict__
    result = self.getByNavigation('fixedResonance', 'nmrConstraintStore', 'nmrProject', ('chainStateSets',self.chainStateSetSerial), ('chainStates',self.chainStateSerial),)
    return result
  
  def getChainStateSerial(self):
    """
    Get for ccp.nmr.NmrConstraint.ChainStateLink.chainStateSerial
    """
    dataDict = self.__dict__
    result = dataDict.get('chainStateSerial')
    return result
  
  def getChainStateSetSerial(self):
    """
    Get for ccp.nmr.NmrConstraint.ChainStateLink.chainStateSetSerial
    """
    dataDict = self.__dict__
    result = dataDict.get('chainStateSetSerial')
    return result

  getClassName = memops.api.Implementation.ComplexDataType.getClassName

  getExpandedKey = memops.api.Implementation.MemopsObject.getExpandedKey

  getFieldNames = memops.api.Implementation.ComplexDataType.getFieldNames
  
  def getFixedResonance(self):
    """
    Get for ccp.nmr.NmrConstraint.ChainStateLink.fixedResonance
    """
    dataDict = self.__dict__
    result = dataDict.get('fixedResonance')
    return result
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccp.nmr.NmrConstraint.ChainStateLink
    """
    dataDict = self.__dict__
    result = list()

    obj2 = dataDict.get('fixedResonance')
    obj1 = obj2.__dict__.get('nmrConstraintStore')

    if (useGuid):
      result.append(obj1.__dict__.get('guid'))
    else:
      result.append(obj1.__dict__.get('serial'))

    result.append(obj2.__dict__.get('serial'))
    result.append(dataDict.get('chainStateSetSerial'))

    return result

  getInConstructor = memops.api.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = memops.api.Implementation.MemopsObject.getIsDeleted
  
  def getLocalKey(self):
    """
    GetLocalKey for ccp.nmr.NmrConstraint.ChainStateLink
    """
    dataDict = self.__dict__
    result = dataDict.get('chainStateSetSerial')
    return result

  getMetaclass = memops.api.Implementation.ComplexDataType.getMetaclass

  getPackageName = memops.api.Implementation.ComplexDataType.getPackageName

  getPackageShortName = memops.api.Implementation.ComplexDataType.getPackageShortName
  
  def getParent(self):
    """
    Get for ccp.nmr.NmrConstraint.ChainStateLink.parent
    """
    dataDict = self.__dict__
    result = dataDict.get('fixedResonance')
    return result

  getQualifiedName = memops.api.Implementation.ComplexDataType.getQualifiedName

  getRoot = memops.api.Implementation.MemopsObject.getRoot

  getTopObject = memops.api.Implementation.DataObject.getTopObject

  removeApplicationData = memops.api.Implementation.DataObject.removeApplicationData
  
  def set(self, name, value):
    """
    SetAttr for ccp.nmr.NmrConstraint.ChainStateLink
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setAccess = memops.api.Implementation.DataObject.setAccess

  setApplicationData = memops.api.Implementation.DataObject.setApplicationData
  
  def setChainState(self, value):
    """
    setter for derived, settable link chainState
    """
    dataDict = self.__dict__
    from ccp.api.nmr.Nmr import ChainState as importedType
    if (not isinstance(value, importedType)):
      raise ApiError("""%s.setChainState:
       value is not of class ccp.nmr.Nmr.ChainState""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = self.getChainState()
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setChainState:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setChainState:
       called on deleted object""" % self.qualifiedName
      )

    if (value is not None):
      if (value.__dict__.get('isDeleted')):
        raise ApiError("""%s.setChainState:
         called with deleted value""" % self.qualifiedName
        )

    if (value == currentValue):
      return

    self.chainStateSetSerial = value.chainStateSet.serial
    self.chainStateSerial = value.serial
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

  def setChainStateSerial(self, value):
    """
    Set for ccp.nmr.NmrConstraint.ChainStateLink.chainStateSerial
    """
    dataDict = self.__dict__
    if (isinstance(value, memops.api.Implementation.Int.PythonType)):
      pass
    elif ([x for x in memops.api.Implementation.Int.compatibleTypes if isinstance(value, x)]):
      value = memops.api.Implementation.Int.create(value)
    else:
      raise ApiError("""%s.setChainStateSerial:
       memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('chainStateSerial')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setChainStateSerial:
       called on deleted object""" % self.qualifiedName
      )

    if (value == currentValue):
      return

    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setChainStateSerial:
         cannot set chainStateSerial, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is None):
        raise ApiError("""%s.setChainStateSerial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    dataDict['chainStateSerial'] = value

    # doNotifies
  
  def setChainStateSetSerial(self, value):
    """
    Set for ccp.nmr.NmrConstraint.ChainStateLink.chainStateSetSerial
    """
    dataDict = self.__dict__
    if (isinstance(value, memops.api.Implementation.Int.PythonType)):
      pass
    elif ([x for x in memops.api.Implementation.Int.compatibleTypes if isinstance(value, x)]):
      value = memops.api.Implementation.Int.create(value)
    else:
      raise ApiError("""%s.setChainStateSetSerial:
       memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('chainStateSetSerial')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setChainStateSetSerial:
       called on deleted object""" % self.qualifiedName
      )

    if (value == currentValue):
      return

    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setChainStateSetSerial:
         cannot set chainStateSetSerial, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is None):
        raise ApiError("""%s.setChainStateSetSerial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    dataDict['chainStateSetSerial'] = value

    # doNotifies

  toDetailedString = memops.api.Implementation.ComplexDataType.toDetailedString

  applicationData = memops.api.Implementation.DataObject.applicationData
  
  chainStateSerial = property(getChainStateSerial, setChainStateSerial, None,
  r"""Serial for ChainState linked to
  """)
  
  chainStateSetSerial = property(getChainStateSetSerial, setChainStateSetSerial, None,
  r"""Serial number of ChainStateSet linked to. Note that each FIxedResonance 
  can only link to one ChainsState from each ChainStateSet, so this 
  attribute is the key for the class.
  """)

  className = memops.api.Implementation.ComplexDataType.className

  fieldNames = memops.api.Implementation.ComplexDataType.fieldNames

  inConstructor = memops.api.Implementation.ComplexDataType.inConstructor

  isDeleted = memops.api.Implementation.MemopsObject.isDeleted

  metaclass = memops.api.Implementation.ComplexDataType.metaclass

  packageName = memops.api.Implementation.ComplexDataType.packageName

  packageShortName = memops.api.Implementation.ComplexDataType.packageShortName

  qualifiedName = memops.api.Implementation.ComplexDataType.qualifiedName

  access = memops.api.Implementation.DataObject.access
  
  chainState = property(getChainState, setChainState, None,
  r"""ChainState to which ChainStateLink points
  """)
  
  fixedResonance = property(getFixedResonance,  None, None,
  r"""parent link
  """)
  
  parent = property(getParent, None, None,
  r"""link to parent object - synonym for fixedResonance
  """)

  root = memops.api.Implementation.MemopsObject.root

  topObject = memops.api.Implementation.DataObject.topObject

###############################################################################
class ConditionState(memops.api.Implementation.DataObject):
  r"""Conditions relevant for ConstraintLists
  """
  #   from data model element ccp.nmr.NmrConstraint.ConditionState revision 1.1.2.9
  _metaclass = metaPackage.getElement('ConditionState')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('applicationData', 'className', 'details', 'dynamicAlignment', 'fieldNames', 'inConstructor', 'isDeleted', 'metaclass', 'name', 'packageName', 'packageShortName', 'qualifiedName', 'serial', 'staticAlignment', 'access', 'constraintLists', 'nmrConstraintStore', 'parent', 'root', 'topObject',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccp.nmr.NmrConstraint.ConditionState
    """
    dataDict = self.__dict__
    dataDict['nmrConstraintStore'] = parent
    if (not isinstance(parent, NmrConstraintStore)):
      raise ApiError("""%s.__init__:
       value is not of class ccp.nmr.NmrConstraint.NmrConstraintStore""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:
      if (not ((parent.__dict__.get('isLoaded') or parent.__dict__.get('isReading')))):
        parent.load()

      dataDict['applicationData'] = list()
      dataDict['details'] = None
      dataDict['dynamicAlignment'] = None
      dataDict['name'] = None
      dataDict['serial'] = None
      dataDict['staticAlignment'] = None
      dataDict['access'] = None
      dataDict['constraintLists'] = set()

      dataDict['inConstructor'] = True
      try:
        
        for key, value in attrlinks.iteritems():
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        del dataDict['inConstructor']
      except:
        print "ERROR in ccp.nmr.NmrConstraint.ConditionState.__init__"
        del dataDict['inConstructor']
        raise

      if (notOverride):
        if (dataDict.get('serial') is None):
          dataDict['inConstructor'] = True
          self.setSerial(-1)
          del dataDict['inConstructor']
        else:
          raise ApiError("""%s.__init__:
           Cannot pass in explicit serial if not reading""" % self.qualifiedName
           + ": %s:%s" % (parent, 'ccp.nmr.NmrConstraint.ConditionState')
          )

      if (notIsReading):
        childrenDict = parent.__dict__.get('conditionStates')
        objKey = dataDict.get('serial')
        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['serial'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        print '''WARNING Error in clean-up of incorrectly created object. 
        Data may be left in an illegal state'''
        del dataDict['inConstructor']
      raise exc_info[0], exc_info[1], exc_info[2]

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccp.nmr.NmrConstraint.ConditionState:
       determines 
    cascading deletes to follow from delete of object.
       *Implementation 
    function* - should be called only by API delete function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
      dataDict.get('topObject').load()

    access = dataDict.get('access')
    if (access is not None):
      topObject = access.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccp.nmr.NmrConstraint.ConditionState:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    access = dataDict.get('access')
    if ((access is not None and not (access in objsToBeDeleted))):
      dataObjects = access.__dict__.get('dataObjects')
      dataObjects.remove(self)

    for constraintList in dataDict.get('constraintLists'):
      if (not (constraintList in objsToBeDeleted)):
        constraintList.__dict__['conditionState'] = None

    nmrConstraintStore = dataDict.get('nmrConstraintStore')
    if (not (nmrConstraintStore in objsToBeDeleted)):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = nmrConstraintStore.__dict__.get('conditionStates')
        if (self is dd.get(objKey)):
          del dd[objKey]

  addApplicationData = memops.api.Implementation.DataObject.addApplicationData
  
  def addConstraintList(self, value):
    """
    Add for ccp.nmr.NmrConstraint.ConditionState.constraintLists
    """
    dataDict = self.__dict__
    if (not isinstance(value, AbstractConstraintList)):
      raise ApiError("""%s.addConstraintList:
       value is not of class ccp.nmr.NmrConstraint.AbstractConstraintList""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('constraintLists')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.addConstraintList:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.addConstraintList:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.addConstraintList:
       called with deleted value""" % self.qualifiedName
      )

    if (value in currentValues):
      raise ApiError("""%s.addConstraintList:
       value is in list already""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      if (value is not None):
        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.addConstraintList:
           Link constraintLists between objects from separate partitions
           - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    oldSelf = value.__dict__.get('conditionState')
    if (oldSelf is not None):
      siblingValues = oldSelf.__dict__.get('constraintLists')
      siblingValues.remove(value)

    value.__dict__['conditionState'] = self
    currentValues.add(value)
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('addConstraintList')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccp.nmr.NmrConstraint.ConditionState
    """
    dataDict = self.__dict__
    self.checkValid(complete)
  
  def checkValid(self, complete=False):
    """
    CheckValid for ccp.nmr.NmrConstraint.ConditionState
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('nmrConstraintStore')
        dd = value.__dict__.get('conditionStates')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'nmrConstraintStore' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from memops.api.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('details')
      if (value is not None):
        if (isinstance(value, memops.api.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: details:
           memops.Implementation.Text input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 254):
          raise ApiError("""%s.checkValid: details:
           memops.Implementation.Text maximum length is 254 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: details:
           memops.Implementation.Text: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('dynamicAlignment')
      if (value is not None):
        from memops.api.Implementation import SymmTracelessMatrix as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: dynamicAlignment:
           value is not of class memops.Implementation.SymmTracelessMatrix""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('name')
      if (value is not None):
        if (isinstance(value, memops.api.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: name:
           memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 80):
          raise ApiError("""%s.checkValid: name:
           memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: name:
           memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.splitlines()) <= 1)):
          raise ApiError("""%s.checkValid: name:
           Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, memops.api.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('serial')
      if (value is None):
        raise ApiError("""%s.checkValid: serial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, memops.api.Implementation.Int.PythonType)):
        pass
      elif ([x for x in memops.api.Implementation.Int.compatibleTypes if isinstance(value, x)]):
        value = memops.api.Implementation.Int.create(value)
      else:
        raise ApiError("""%s.checkValid: serial:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('staticAlignment')
      if (value is not None):
        from memops.api.Implementation import SymmTracelessMatrix as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: staticAlignment:
           value is not of class memops.Implementation.SymmTracelessMatrix""" % self.qualifiedName
           + ": %s" % (value,)
          )

      # check roles
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('access')
      if (value is not None):
        from memops.api.AccessControl import AccessObject as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: access:
           value is not of class memops.AccessControl.AccessObject""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('dataObjects')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: access:
           non-reciprocal link ConditionState from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('constraintLists')
      for value in values:
        if (not isinstance(value, AbstractConstraintList)):
          raise ApiError("""%s.checkValid: constraintLists:
           value is not of class ccp.nmr.NmrConstraint.AbstractConstraintList""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('conditionState')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: constraintLists:
           non-reciprocal link ConditionState from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: constraintLists:
           Link constraintLists between objects from separate partitions
           - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      value = dataDict.get('nmrConstraintStore')
      if (not isinstance(value, NmrConstraintStore)):
        raise ApiError("""%s.checkValid: nmrConstraintStore:
         value is not of class ccp.nmr.NmrConstraint.NmrConstraintStore""" % self.qualifiedName
         + ": %s" % (value,)
        )

    # check explicit class constraints
    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('details')
    value = dataDict.get('dynamicAlignment')
    if (value is not None):
      value.checkAllValid(complete)

    value = dataDict.get('name')
    value = dataDict.get('staticAlignment')
    if (value is not None):
      value.checkAllValid(complete)

    # check roles
    value = dataDict.get('access')
    values = dataDict.get('constraintLists')
    value = dataDict.get('nmrConstraintStore')
    if (value is None):
      raise ApiError("""%s.checkValid: nmrConstraintStore:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

  delete = memops.api.Implementation.DataObject.delete

  findAllApplicationData = memops.api.Implementation.DataObject.findAllApplicationData
  
  def findAllConstraintLists(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.ConditionState.constraintLists
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('constraintLists')
      result = set(currentValues)

    else:
      currentValues = dataDict.get('constraintLists')
      result = set()
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('details', 'name', 'serial', 'unit', 'usedForCalculation', 'access', 'conditionState', 'method', 'nmrConstraintStore',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result.add(v)

    return result

  findFirstApplicationData = memops.api.Implementation.DataObject.findFirstApplicationData
  
  def findFirstConstraintList(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.ConditionState.constraintLists
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('constraintLists')
      if (currentValues):
        result = iter(currentValues).next()
      else:
        result = None

    else:
      currentValues = dataDict.get('constraintLists')
      result = None
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('details', 'name', 'serial', 'unit', 'usedForCalculation', 'access', 'conditionState', 'method', 'nmrConstraintStore',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result = v; break

    return result
  
  def get(self, name):
    """
    GetAttr for ccp.nmr.NmrConstraint.ConditionState
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getAccess = memops.api.Implementation.DataObject.getAccess

  getApplicationData = memops.api.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.ConditionState
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (2 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.ConditionState'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (1 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.ConditionState'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-1]
      obj2 = obj1.__dict__.get('conditionStates').get(objKey)
      result = obj2

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = memops.api.Implementation.MemopsObject.getByNavigation

  getClassName = memops.api.Implementation.ComplexDataType.getClassName
  
  def getConstraintLists(self):
    """
    Get for ccp.nmr.NmrConstraint.ConditionState.constraintLists
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('constraintLists')
    result = frozenset(tempVar)
    return result
  
  def getDetails(self):
    """
    Get for ccp.nmr.NmrConstraint.ConditionState.details
    """
    dataDict = self.__dict__
    result = dataDict.get('details')
    return result
  
  def getDynamicAlignment(self):
    """
    Get for ccp.nmr.NmrConstraint.ConditionState.dynamicAlignment
    """
    dataDict = self.__dict__
    result = dataDict.get('dynamicAlignment')
    return result

  getExpandedKey = memops.api.Implementation.MemopsObject.getExpandedKey

  getFieldNames = memops.api.Implementation.ComplexDataType.getFieldNames
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccp.nmr.NmrConstraint.ConditionState
    """
    dataDict = self.__dict__
    result = list()

    obj1 = dataDict.get('nmrConstraintStore')

    if (useGuid):
      result.append(obj1.__dict__.get('guid'))
    else:
      result.append(obj1.__dict__.get('serial'))

    result.append(dataDict.get('serial'))

    return result

  getInConstructor = memops.api.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = memops.api.Implementation.MemopsObject.getIsDeleted
  
  def getLocalKey(self):
    """
    GetLocalKey for ccp.nmr.NmrConstraint.ConditionState
    """
    dataDict = self.__dict__
    result = dataDict.get('serial')
    return result

  getMetaclass = memops.api.Implementation.ComplexDataType.getMetaclass
  
  def getName(self):
    """
    Get for ccp.nmr.NmrConstraint.ConditionState.name
    """
    dataDict = self.__dict__
    result = dataDict.get('name')
    return result
  
  def getNmrConstraintStore(self):
    """
    Get for ccp.nmr.NmrConstraint.ConditionState.nmrConstraintStore
    """
    dataDict = self.__dict__
    result = dataDict.get('nmrConstraintStore')
    return result

  getPackageName = memops.api.Implementation.ComplexDataType.getPackageName

  getPackageShortName = memops.api.Implementation.ComplexDataType.getPackageShortName
  
  def getParent(self):
    """
    Get for ccp.nmr.NmrConstraint.ConditionState.parent
    """
    dataDict = self.__dict__
    result = dataDict.get('nmrConstraintStore')
    return result

  getQualifiedName = memops.api.Implementation.ComplexDataType.getQualifiedName

  getRoot = memops.api.Implementation.MemopsObject.getRoot
  
  def getSerial(self):
    """
    Get for ccp.nmr.NmrConstraint.ConditionState.serial
    """
    dataDict = self.__dict__
    result = dataDict.get('serial')
    return result
  
  def getStaticAlignment(self):
    """
    Get for ccp.nmr.NmrConstraint.ConditionState.staticAlignment
    """
    dataDict = self.__dict__
    result = dataDict.get('staticAlignment')
    return result

  getTopObject = memops.api.Implementation.DataObject.getTopObject

  removeApplicationData = memops.api.Implementation.DataObject.removeApplicationData
  
  def removeConstraintList(self, value):
    """
    Remove for ccp.nmr.NmrConstraint.ConditionState.constraintLists
    """
    dataDict = self.__dict__
    if (not isinstance(value, AbstractConstraintList)):
      raise ApiError("""%s.removeConstraintList:
       value is not of class ccp.nmr.NmrConstraint.AbstractConstraintList""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('constraintLists')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.removeConstraintList:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.removeConstraintList:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.removeConstraintList:
       called with deleted value""" % self.qualifiedName
      )

    if (not (value in currentValues)):
      raise ApiError("""%s.removeConstraintList:
       value not in list""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      pass

    value.__dict__['conditionState'] = None
    currentValues.remove(value)
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('removeConstraintList')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  def set(self, name, value):
    """
    SetAttr for ccp.nmr.NmrConstraint.ConditionState
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setAccess = memops.api.Implementation.DataObject.setAccess

  setApplicationData = memops.api.Implementation.DataObject.setApplicationData
  
  def setConstraintLists(self, values):
    """
    Set for ccp.nmr.NmrConstraint.ConditionState.constraintLists
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setConstraintLists:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      if (not isinstance(value, AbstractConstraintList)):
        raise ApiError("""%s.setConstraintLists:
         value is not of class ccp.nmr.NmrConstraint.AbstractConstraintList""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('constraintLists')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setConstraintLists:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setConstraintLists:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setConstraintLists:
         an object in values is deleted""" % self.qualifiedName
        )

    if (values == currentValues):
      return

    if (notOverride):
      xx1 = dataDict.get('topObject')
      for value in values:
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setConstraintLists:
           Link constraintLists between objects from separate partitions
           - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    for cv in currentValues:
      if (not (cv in values)):
        cv.__dict__['conditionState'] = None

    for cv in values:
      if (not (cv in currentValues)):
        oldSelf = cv.__dict__.get('conditionState')
        if (oldSelf is not None):
          vv = oldSelf.__dict__.get('constraintLists')
          vv.remove(cv)

      cv.__dict__['conditionState'] = self

    dataDict['constraintLists'] = values
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setConstraintLists')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  def setDetails(self, value):
    """
    Set for ccp.nmr.NmrConstraint.ConditionState.details
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, memops.api.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.setDetails:
         memops.Implementation.Text input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 254):
        raise ApiError("""%s.setDetails:
         memops.Implementation.Text maximum length is 254 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.setDetails:
         memops.Implementation.Text: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('details')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setDetails:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setDetails:
       called on deleted object""" % self.qualifiedName
      )

    if (value == currentValue):
      return

    if (notOverride):
      pass

    dataDict['details'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setDetails')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  def setDynamicAlignment(self, value):
    """
    Set for ccp.nmr.NmrConstraint.ConditionState.dynamicAlignment
    """
    dataDict = self.__dict__
    if (value is not None):
      from memops.api.Implementation import SymmTracelessMatrix as importedType
      if (not isinstance(value, importedType)):
        raise ApiError("""%s.setDynamicAlignment:
         value is not of class memops.Implementation.SymmTracelessMatrix""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('dynamicAlignment')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setDynamicAlignment:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setDynamicAlignment:
       called on deleted object""" % self.qualifiedName
      )

    if (value == currentValue):
      return

    if (notOverride):
      pass

    dataDict['dynamicAlignment'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setDynamicAlignment')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  def setName(self, value):
    """
    Set for ccp.nmr.NmrConstraint.ConditionState.name
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, memops.api.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.setName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.setName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.setName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.setName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('name')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setName:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setName:
       called on deleted object""" % self.qualifiedName
      )

    if (value == currentValue):
      return

    if (notOverride):
      pass

    dataDict['name'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setName')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  def setSerial(self, value):
    """
    Set for ccp.nmr.NmrConstraint.ConditionState.serial
    """
    dataDict = self.__dict__
    if (isinstance(value, memops.api.Implementation.Int.PythonType)):
      pass
    elif ([x for x in memops.api.Implementation.Int.compatibleTypes if isinstance(value, x)]):
      value = memops.api.Implementation.Int.create(value)
    else:
      raise ApiError("""%s.setSerial:
       memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('serial')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setSerial:
       called on deleted object""" % self.qualifiedName
      )

    if (value == currentValue):
      return

    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setSerial:
         cannot set serial, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is None):
        raise ApiError("""%s.setSerial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    parent = dataDict.get('nmrConstraintStore')
    oldSerial = parent.__dict__.get('_serialDict').get('conditionStates')
    if (value < 0):
      value = (oldSerial + 1)
      parent.__dict__.get('_serialDict')['conditionStates'] = value
    elif (value > oldSerial):
      parent.__dict__.get('_serialDict')['conditionStates'] = value

    dataDict['serial'] = value

    # doNotifies
  
  def setStaticAlignment(self, value):
    """
    Set for ccp.nmr.NmrConstraint.ConditionState.staticAlignment
    """
    dataDict = self.__dict__
    if (value is not None):
      from memops.api.Implementation import SymmTracelessMatrix as importedType
      if (not isinstance(value, importedType)):
        raise ApiError("""%s.setStaticAlignment:
         value is not of class memops.Implementation.SymmTracelessMatrix""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('staticAlignment')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setStaticAlignment:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setStaticAlignment:
       called on deleted object""" % self.qualifiedName
      )

    if (value == currentValue):
      return

    if (notOverride):
      pass

    dataDict['staticAlignment'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setStaticAlignment')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  def sortedConstraintLists(self):
    """
    Sorted for ccp.nmr.NmrConstraint.ConditionState.constraintLists
    """
    dataDict = self.__dict__
    ll = dataDict.get('constraintLists')
    ll = [(x.getFullKey(),x) for x in ll]
    
    ll.sort()
    result = [x[1] for x in ll]
    return result

  toDetailedString = memops.api.Implementation.ComplexDataType.toDetailedString

  applicationData = memops.api.Implementation.DataObject.applicationData

  className = memops.api.Implementation.ComplexDataType.className
  
  details = property(getDetails, setDetails, None,
  r"""Free text, for notes, explanatory comments, etc.
  """)
  
  dynamicAlignment = property(getDynamicAlignment, setDynamicAlignment, None,
  r"""dynamic alignment tensor
  """)

  fieldNames = memops.api.Implementation.ComplexDataType.fieldNames

  inConstructor = memops.api.Implementation.ComplexDataType.inConstructor

  isDeleted = memops.api.Implementation.MemopsObject.isDeleted

  metaclass = memops.api.Implementation.ComplexDataType.metaclass
  
  name = property(getName, setName, None,
  r"""Name of ConditionSet
  """)

  packageName = memops.api.Implementation.ComplexDataType.packageName

  packageShortName = memops.api.Implementation.ComplexDataType.packageShortName

  qualifiedName = memops.api.Implementation.ComplexDataType.qualifiedName
  
  serial = property(getSerial, setSerial, None,
  r"""Serial number of object. Serves as object main key. Serial numbers of 
  deleted objects are not re-used. Serial numbers can only be set by the 
  implementation. Values are in practice always positive, since negative 
  values are interpreted as a signal to set the next free serial
  """)
  
  staticAlignment = property(getStaticAlignment, setStaticAlignment, None,
  r"""Static alignment tensor
  """)

  access = memops.api.Implementation.DataObject.access
  
  constraintLists = property(getConstraintLists, setConstraintLists, None,
  r"""Constraint lists relevant to condition set
  """)
  
  nmrConstraintStore = property(getNmrConstraintStore,  None, None,
  r"""parent link
  """)
  
  parent = property(getParent, None, None,
  r"""link to parent object - synonym for nmrConstraintStore
  """)

  root = memops.api.Implementation.MemopsObject.root

  topObject = memops.api.Implementation.DataObject.topObject

###############################################################################
class ConstraintGroup(memops.api.Implementation.DataObject):
  r"""Group of constraints, for organisation, annotation, etc. purposes.
  """
  #   from data model element ccp.nmr.NmrConstraint.ConstraintGroup revision 1.37.2.9
  _metaclass = metaPackage.getElement('ConstraintGroup')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('applicationData', 'className', 'details', 'fieldNames', 'inConstructor', 'isDeleted', 'metaclass', 'packageName', 'packageShortName', 'qualifiedName', 'serial', 'access', 'constraints', 'nmrConstraintStore', 'parent', 'root', 'topObject',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccp.nmr.NmrConstraint.ConstraintGroup
    """
    dataDict = self.__dict__
    dataDict['nmrConstraintStore'] = parent
    if (not isinstance(parent, NmrConstraintStore)):
      raise ApiError("""%s.__init__:
       value is not of class ccp.nmr.NmrConstraint.NmrConstraintStore""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:
      if (not ((parent.__dict__.get('isLoaded') or parent.__dict__.get('isReading')))):
        parent.load()

      dataDict['applicationData'] = list()
      dataDict['details'] = None
      dataDict['serial'] = None
      dataDict['access'] = None
      dataDict['constraints'] = set()

      dataDict['inConstructor'] = True
      try:
        
        for key, value in attrlinks.iteritems():
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        del dataDict['inConstructor']
      except:
        print "ERROR in ccp.nmr.NmrConstraint.ConstraintGroup.__init__"
        del dataDict['inConstructor']
        raise

      if (notOverride):
        if (dataDict.get('serial') is None):
          dataDict['inConstructor'] = True
          self.setSerial(-1)
          del dataDict['inConstructor']
        else:
          raise ApiError("""%s.__init__:
           Cannot pass in explicit serial if not reading""" % self.qualifiedName
           + ": %s:%s" % (parent, 'ccp.nmr.NmrConstraint.ConstraintGroup')
          )

      if (notIsReading):
        childrenDict = parent.__dict__.get('constraintGroups')
        objKey = dataDict.get('serial')
        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['serial'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        print '''WARNING Error in clean-up of incorrectly created object. 
        Data may be left in an illegal state'''
        del dataDict['inConstructor']
      raise exc_info[0], exc_info[1], exc_info[2]

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccp.nmr.NmrConstraint.ConstraintGroup:
       determines 
    cascading deletes to follow from delete of object.
       *Implementation 
    function* - should be called only by API delete function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
      dataDict.get('topObject').load()

    access = dataDict.get('access')
    if (access is not None):
      topObject = access.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccp.nmr.NmrConstraint.ConstraintGroup:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    access = dataDict.get('access')
    if ((access is not None and not (access in objsToBeDeleted))):
      dataObjects = access.__dict__.get('dataObjects')
      dataObjects.remove(self)

    for constraint in dataDict.get('constraints'):
      if (not (constraint in objsToBeDeleted)):
        constraintGroups = constraint.__dict__.get('constraintGroups')
        constraintGroups.remove(self)

    nmrConstraintStore = dataDict.get('nmrConstraintStore')
    if (not (nmrConstraintStore in objsToBeDeleted)):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = nmrConstraintStore.__dict__.get('constraintGroups')
        if (self is dd.get(objKey)):
          del dd[objKey]

  addApplicationData = memops.api.Implementation.DataObject.addApplicationData
  
  def addConstraint(self, value):
    """
    Add for ccp.nmr.NmrConstraint.ConstraintGroup.constraints
    """
    dataDict = self.__dict__
    if (not isinstance(value, AbstractConstraint)):
      raise ApiError("""%s.addConstraint:
       value is not of class ccp.nmr.NmrConstraint.AbstractConstraint""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('constraints')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.addConstraint:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.addConstraint:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.addConstraint:
       called with deleted value""" % self.qualifiedName
      )

    if (value in currentValues):
      raise ApiError("""%s.addConstraint:
       value is in list already""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      if (value is not None):
        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.addConstraint:
           Link constraints between objects from separate partitions
           - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    oldSelves = value.__dict__.get('constraintGroups')
    oldSelves.add(self)
    currentValues.add(value)
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('addConstraint')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccp.nmr.NmrConstraint.ConstraintGroup
    """
    dataDict = self.__dict__
    self.checkValid(complete)
  
  def checkValid(self, complete=False):
    """
    CheckValid for ccp.nmr.NmrConstraint.ConstraintGroup
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('nmrConstraintStore')
        dd = value.__dict__.get('constraintGroups')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'nmrConstraintStore' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from memops.api.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('details')
      if (value is not None):
        if (isinstance(value, memops.api.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: details:
           memops.Implementation.Text input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 254):
          raise ApiError("""%s.checkValid: details:
           memops.Implementation.Text maximum length is 254 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: details:
           memops.Implementation.Text: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, memops.api.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('serial')
      if (value is None):
        raise ApiError("""%s.checkValid: serial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, memops.api.Implementation.Int.PythonType)):
        pass
      elif ([x for x in memops.api.Implementation.Int.compatibleTypes if isinstance(value, x)]):
        value = memops.api.Implementation.Int.create(value)
      else:
        raise ApiError("""%s.checkValid: serial:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('access')
      if (value is not None):
        from memops.api.AccessControl import AccessObject as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: access:
           value is not of class memops.AccessControl.AccessObject""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('dataObjects')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: access:
           non-reciprocal link ConstraintGroup from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('constraints')
      for value in values:
        if (not isinstance(value, AbstractConstraint)):
          raise ApiError("""%s.checkValid: constraints:
           value is not of class ccp.nmr.NmrConstraint.AbstractConstraint""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('constraintGroups')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: constraints:
           non-reciprocal link ConstraintGroup from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      value = dataDict.get('nmrConstraintStore')
      if (not isinstance(value, NmrConstraintStore)):
        raise ApiError("""%s.checkValid: nmrConstraintStore:
         value is not of class ccp.nmr.NmrConstraint.NmrConstraintStore""" % self.qualifiedName
         + ": %s" % (value,)
        )

    # check explicit class constraints
    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('details')
    # check roles
    value = dataDict.get('access')
    values = dataDict.get('constraints')
    value = dataDict.get('nmrConstraintStore')
    if (value is None):
      raise ApiError("""%s.checkValid: nmrConstraintStore:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

  delete = memops.api.Implementation.DataObject.delete

  findAllApplicationData = memops.api.Implementation.DataObject.findAllApplicationData
  
  def findAllConstraints(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.ConstraintGroup.constraints
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('constraints')
      result = set(currentValues)

    else:
      currentValues = dataDict.get('constraints')
      result = set()
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('details', 'origData', 'serial', 'weight', 'access', 'method', 'parentList',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result.add(v)

    return result

  findFirstApplicationData = memops.api.Implementation.DataObject.findFirstApplicationData
  
  def findFirstConstraint(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.ConstraintGroup.constraints
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('constraints')
      if (currentValues):
        result = iter(currentValues).next()
      else:
        result = None

    else:
      currentValues = dataDict.get('constraints')
      result = None
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('details', 'origData', 'serial', 'weight', 'access', 'method', 'parentList',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result = v; break

    return result
  
  def get(self, name):
    """
    GetAttr for ccp.nmr.NmrConstraint.ConstraintGroup
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getAccess = memops.api.Implementation.DataObject.getAccess

  getApplicationData = memops.api.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.ConstraintGroup
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (2 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.ConstraintGroup'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (1 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.ConstraintGroup'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-1]
      obj2 = obj1.__dict__.get('constraintGroups').get(objKey)
      result = obj2

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = memops.api.Implementation.MemopsObject.getByNavigation

  getClassName = memops.api.Implementation.ComplexDataType.getClassName
  
  def getConstraints(self):
    """
    Get for ccp.nmr.NmrConstraint.ConstraintGroup.constraints
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('constraints')
    result = frozenset(tempVar)
    return result
  
  def getDetails(self):
    """
    Get for ccp.nmr.NmrConstraint.ConstraintGroup.details
    """
    dataDict = self.__dict__
    result = dataDict.get('details')
    return result

  getExpandedKey = memops.api.Implementation.MemopsObject.getExpandedKey

  getFieldNames = memops.api.Implementation.ComplexDataType.getFieldNames
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccp.nmr.NmrConstraint.ConstraintGroup
    """
    dataDict = self.__dict__
    result = list()

    obj1 = dataDict.get('nmrConstraintStore')

    if (useGuid):
      result.append(obj1.__dict__.get('guid'))
    else:
      result.append(obj1.__dict__.get('serial'))

    result.append(dataDict.get('serial'))

    return result

  getInConstructor = memops.api.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = memops.api.Implementation.MemopsObject.getIsDeleted
  
  def getLocalKey(self):
    """
    GetLocalKey for ccp.nmr.NmrConstraint.ConstraintGroup
    """
    dataDict = self.__dict__
    result = dataDict.get('serial')
    return result

  getMetaclass = memops.api.Implementation.ComplexDataType.getMetaclass
  
  def getNmrConstraintStore(self):
    """
    Get for ccp.nmr.NmrConstraint.ConstraintGroup.nmrConstraintStore
    """
    dataDict = self.__dict__
    result = dataDict.get('nmrConstraintStore')
    return result

  getPackageName = memops.api.Implementation.ComplexDataType.getPackageName

  getPackageShortName = memops.api.Implementation.ComplexDataType.getPackageShortName
  
  def getParent(self):
    """
    Get for ccp.nmr.NmrConstraint.ConstraintGroup.parent
    """
    dataDict = self.__dict__
    result = dataDict.get('nmrConstraintStore')
    return result

  getQualifiedName = memops.api.Implementation.ComplexDataType.getQualifiedName

  getRoot = memops.api.Implementation.MemopsObject.getRoot
  
  def getSerial(self):
    """
    Get for ccp.nmr.NmrConstraint.ConstraintGroup.serial
    """
    dataDict = self.__dict__
    result = dataDict.get('serial')
    return result

  getTopObject = memops.api.Implementation.DataObject.getTopObject

  removeApplicationData = memops.api.Implementation.DataObject.removeApplicationData
  
  def removeConstraint(self, value):
    """
    Remove for ccp.nmr.NmrConstraint.ConstraintGroup.constraints
    """
    dataDict = self.__dict__
    if (not isinstance(value, AbstractConstraint)):
      raise ApiError("""%s.removeConstraint:
       value is not of class ccp.nmr.NmrConstraint.AbstractConstraint""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('constraints')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.removeConstraint:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.removeConstraint:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.removeConstraint:
       called with deleted value""" % self.qualifiedName
      )

    if (not (value in currentValues)):
      raise ApiError("""%s.removeConstraint:
       value not in list""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      pass

    oldSelves = value.__dict__.get('constraintGroups')
    oldSelves.remove(self)
    currentValues.remove(value)
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('removeConstraint')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  def set(self, name, value):
    """
    SetAttr for ccp.nmr.NmrConstraint.ConstraintGroup
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setAccess = memops.api.Implementation.DataObject.setAccess

  setApplicationData = memops.api.Implementation.DataObject.setApplicationData
  
  def setConstraints(self, values):
    """
    Set for ccp.nmr.NmrConstraint.ConstraintGroup.constraints
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setConstraints:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      if (not isinstance(value, AbstractConstraint)):
        raise ApiError("""%s.setConstraints:
         value is not of class ccp.nmr.NmrConstraint.AbstractConstraint""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('constraints')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setConstraints:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setConstraints:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setConstraints:
         an object in values is deleted""" % self.qualifiedName
        )

    if (values == currentValues):
      return

    if (notOverride):
      xx1 = dataDict.get('topObject')
      for value in values:
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setConstraints:
           Link constraints between objects from separate partitions
           - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    for cv in currentValues:
      if (not (cv in values)):
        oldSelves = cv.__dict__.get('constraintGroups')
        oldSelves.remove(self)

    for cv in values:
      if (not (cv in currentValues)):
        oldSelves = cv.__dict__.get('constraintGroups')
        oldSelves.add(self)

    dataDict['constraints'] = values
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setConstraints')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  def setDetails(self, value):
    """
    Set for ccp.nmr.NmrConstraint.ConstraintGroup.details
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, memops.api.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.setDetails:
         memops.Implementation.Text input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 254):
        raise ApiError("""%s.setDetails:
         memops.Implementation.Text maximum length is 254 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.setDetails:
         memops.Implementation.Text: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('details')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setDetails:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setDetails:
       called on deleted object""" % self.qualifiedName
      )

    if (value == currentValue):
      return

    if (notOverride):
      pass

    dataDict['details'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setDetails')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  def setSerial(self, value):
    """
    Set for ccp.nmr.NmrConstraint.ConstraintGroup.serial
    """
    dataDict = self.__dict__
    if (isinstance(value, memops.api.Implementation.Int.PythonType)):
      pass
    elif ([x for x in memops.api.Implementation.Int.compatibleTypes if isinstance(value, x)]):
      value = memops.api.Implementation.Int.create(value)
    else:
      raise ApiError("""%s.setSerial:
       memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('serial')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setSerial:
       called on deleted object""" % self.qualifiedName
      )

    if (value == currentValue):
      return

    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setSerial:
         cannot set serial, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is None):
        raise ApiError("""%s.setSerial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    parent = dataDict.get('nmrConstraintStore')
    oldSerial = parent.__dict__.get('_serialDict').get('constraintGroups')
    if (value < 0):
      value = (oldSerial + 1)
      parent.__dict__.get('_serialDict')['constraintGroups'] = value
    elif (value > oldSerial):
      parent.__dict__.get('_serialDict')['constraintGroups'] = value

    dataDict['serial'] = value

    # doNotifies
  
  def sortedConstraints(self):
    """
    Sorted for ccp.nmr.NmrConstraint.ConstraintGroup.constraints
    """
    dataDict = self.__dict__
    ll = dataDict.get('constraints')
    ll = [(x.getFullKey(),x) for x in ll]
    
    ll.sort()
    result = [x[1] for x in ll]
    return result

  toDetailedString = memops.api.Implementation.ComplexDataType.toDetailedString

  applicationData = memops.api.Implementation.DataObject.applicationData

  className = memops.api.Implementation.ComplexDataType.className
  
  details = property(getDetails, setDetails, None,
  r"""Free text, for notes, explanatory comments, etc.
  """)

  fieldNames = memops.api.Implementation.ComplexDataType.fieldNames

  inConstructor = memops.api.Implementation.ComplexDataType.inConstructor

  isDeleted = memops.api.Implementation.MemopsObject.isDeleted

  metaclass = memops.api.Implementation.ComplexDataType.metaclass

  packageName = memops.api.Implementation.ComplexDataType.packageName

  packageShortName = memops.api.Implementation.ComplexDataType.packageShortName

  qualifiedName = memops.api.Implementation.ComplexDataType.qualifiedName
  
  serial = property(getSerial, setSerial, None,
  r"""Serial number of object. Serves as object main key. Serial numbers of 
  deleted objects are not re-used. Serial numbers can only be set by the 
  implementation. Values are in practice always positive, since negative 
  values are interpreted as a signal to set the next free serial
  """)

  access = memops.api.Implementation.DataObject.access
  
  constraints = property(getConstraints, setConstraints, None,
  r"""Constraints included in constraintGroup
  """)
  
  nmrConstraintStore = property(getNmrConstraintStore,  None, None,
  r"""parent link
  """)
  
  parent = property(getParent, None, None,
  r"""link to parent object - synonym for nmrConstraintStore
  """)

  root = memops.api.Implementation.MemopsObject.root

  topObject = memops.api.Implementation.DataObject.topObject

###############################################################################
class ConstraintPeakContrib(memops.api.Implementation.DataObject):
  r"""Connecting class, connecting AbstractConstraint to AbstractPeak. 
Necessary to avoid direct link between the classes, which would be 
inappropriate whenever peaks were deleted.
  """
  #   from data model element ccp.nmr.NmrConstraint.ConstraintPeakContrib revision 1.40.2.9
  _metaclass = metaPackage.getElement('ConstraintPeakContrib')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('applicationData', 'className', 'dataSourceSerial', 'experimentSerial', 'fieldNames', 'inConstructor', 'isDeleted', 'metaclass', 'packageName', 'packageShortName', 'peakListSerial', 'peakSerial', 'qualifiedName', 'access', 'constraint', 'parent', 'peak', 'root', 'topObject',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccp.nmr.NmrConstraint.ConstraintPeakContrib
    """
    dataDict = self.__dict__
    dataDict['constraint'] = parent
    if (not isinstance(parent, AbstractConstraint)):
      raise ApiError("""%s.__init__:
       value is not of class ccp.nmr.NmrConstraint.AbstractConstraint""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:

      dataDict['applicationData'] = list()
      dataDict['dataSourceSerial'] = None
      dataDict['experimentSerial'] = None
      dataDict['peakListSerial'] = None
      dataDict['peakSerial'] = None
      dataDict['access'] = None

      dataDict['inConstructor'] = True
      try:
        
        for key, value in attrlinks.iteritems():
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        del dataDict['inConstructor']
      except:
        print "ERROR in ccp.nmr.NmrConstraint.ConstraintPeakContrib.__init__"
        del dataDict['inConstructor']
        raise

      if (notIsReading):
        childrenDict = parent.__dict__.get('peakContribs')
        ll = list()
        objKey = dataDict.get('experimentSerial')
        ll.append(objKey)
        if (objKey is not None):
          objKey = dataDict.get('dataSourceSerial')
          ll.append(objKey)
          if (objKey is not None):
            objKey = dataDict.get('peakListSerial')
            ll.append(objKey)
            if (objKey is not None):
              objKey = dataDict.get('peakSerial')
              ll.append(objKey)
              if (objKey is not None):
                objKey = tuple(ll)

        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['experimentSerial', 'dataSourceSerial', 'peakListSerial', 'peakSerial'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        print '''WARNING Error in clean-up of incorrectly created object. 
        Data may be left in an illegal state'''
        del dataDict['inConstructor']
      raise exc_info[0], exc_info[1], exc_info[2]

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccp.nmr.NmrConstraint.ConstraintPeakContrib:
       
    determines cascading deletes to follow from delete of object.
       
    *Implementation function* - should be called only by API delete 
    function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
      dataDict.get('topObject').load()

    access = dataDict.get('access')
    if (access is not None):
      topObject = access.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccp.nmr.NmrConstraint.ConstraintPeakContrib:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    access = dataDict.get('access')
    if ((access is not None and not (access in objsToBeDeleted))):
      dataObjects = access.__dict__.get('dataObjects')
      dataObjects.remove(self)

    constraint = dataDict.get('constraint')
    if (not (constraint in objsToBeDeleted)):
      ll = list()
      objKey = dataDict.get('experimentSerial')
      ll.append(objKey)
      if (objKey is not None):
        objKey = dataDict.get('dataSourceSerial')
        ll.append(objKey)
        if (objKey is not None):
          objKey = dataDict.get('peakListSerial')
          ll.append(objKey)
          if (objKey is not None):
            objKey = dataDict.get('peakSerial')
            ll.append(objKey)
            if (objKey is not None):
              objKey = tuple(ll)

      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = constraint.__dict__.get('peakContribs')
        if (self is dd.get(objKey)):
          del dd[objKey]

  addApplicationData = memops.api.Implementation.DataObject.addApplicationData
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccp.nmr.NmrConstraint.ConstraintPeakContrib
    """
    dataDict = self.__dict__
    self.checkValid(complete)
  
  def checkValid(self, complete=False):
    """
    CheckValid for ccp.nmr.NmrConstraint.ConstraintPeakContrib
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      ll = list()
      objKey = dataDict.get('experimentSerial')
      ll.append(objKey)
      if (objKey is not None):
        objKey = dataDict.get('dataSourceSerial')
        ll.append(objKey)
        if (objKey is not None):
          objKey = dataDict.get('peakListSerial')
          ll.append(objKey)
          if (objKey is not None):
            objKey = dataDict.get('peakSerial')
            ll.append(objKey)
            if (objKey is not None):
              objKey = tuple(ll)

      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('constraint')
        dd = value.__dict__.get('peakContribs')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'constraint' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from memops.api.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('dataSourceSerial')
      if (isinstance(value, memops.api.Implementation.Int.PythonType)):
        pass
      elif ([x for x in memops.api.Implementation.Int.compatibleTypes if isinstance(value, x)]):
        value = memops.api.Implementation.Int.create(value)
      else:
        raise ApiError("""%s.checkValid: dataSourceSerial:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('experimentSerial')
      if (isinstance(value, memops.api.Implementation.Int.PythonType)):
        pass
      elif ([x for x in memops.api.Implementation.Int.compatibleTypes if isinstance(value, x)]):
        value = memops.api.Implementation.Int.create(value)
      else:
        raise ApiError("""%s.checkValid: experimentSerial:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('peakListSerial')
      if (isinstance(value, memops.api.Implementation.Int.PythonType)):
        pass
      elif ([x for x in memops.api.Implementation.Int.compatibleTypes if isinstance(value, x)]):
        value = memops.api.Implementation.Int.create(value)
      else:
        raise ApiError("""%s.checkValid: peakListSerial:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('peakSerial')
      if (isinstance(value, memops.api.Implementation.Int.PythonType)):
        pass
      elif ([x for x in memops.api.Implementation.Int.compatibleTypes if isinstance(value, x)]):
        value = memops.api.Implementation.Int.create(value)
      else:
        raise ApiError("""%s.checkValid: peakSerial:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, memops.api.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('access')
      if (value is not None):
        from memops.api.AccessControl import AccessObject as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: access:
           value is not of class memops.AccessControl.AccessObject""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('dataObjects')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: access:
           non-reciprocal link ConstraintPeakContrib from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      value = dataDict.get('constraint')
      if (not isinstance(value, AbstractConstraint)):
        raise ApiError("""%s.checkValid: constraint:
         value is not of class ccp.nmr.NmrConstraint.AbstractConstraint""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = self.getPeak()
      if (value is not None):
        from ccp.api.nmr.Nmr import Peak as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: peak:
           value is not of class ccp.nmr.Nmr.Peak""" % self.qualifiedName
           + ": %s" % (value,)
          )

        xx1 = dataDict.get('topObject')
        xx2 = xx1.__dict__.get('nmrProject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx2 is yy1)):
          raise ApiError("""%s.checkValid: peak:
           Link peak between objects from separate partitions
           - ccp.nmr.NmrConstraint.NmrConstraintStore.nmrProject not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    # check explicit class constraints
    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('dataSourceSerial')
    if (value is None):
      raise ApiError("""%s.checkValid: dataSourceSerial:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    value = dataDict.get('experimentSerial')
    if (value is None):
      raise ApiError("""%s.checkValid: experimentSerial:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    value = dataDict.get('peakListSerial')
    if (value is None):
      raise ApiError("""%s.checkValid: peakListSerial:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    value = dataDict.get('peakSerial')
    if (value is None):
      raise ApiError("""%s.checkValid: peakSerial:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    # check roles
    value = dataDict.get('access')
    value = dataDict.get('constraint')
    if (value is None):
      raise ApiError("""%s.checkValid: constraint:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

  delete = memops.api.Implementation.DataObject.delete

  findAllApplicationData = memops.api.Implementation.DataObject.findAllApplicationData

  findFirstApplicationData = memops.api.Implementation.DataObject.findFirstApplicationData
  
  def get(self, name):
    """
    GetAttr for ccp.nmr.NmrConstraint.ConstraintPeakContrib
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getAccess = memops.api.Implementation.DataObject.getAccess

  getApplicationData = memops.api.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.ConstraintPeakContrib
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (7 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.ConstraintPeakContrib'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (6 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.ConstraintPeakContrib'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-6]
      obj2 = obj1.__dict__.get('constraintLists').get(objKey)

      if (obj2 is not None):
        objKey = fullKey[-5]
        obj3 = obj2.__dict__.get('constraints').get(objKey)

        if (obj3 is not None):
          ll = list()
          objKey = fullKey[-4]
          ll.append(objKey)
          if (objKey is not None):
            objKey = fullKey[-3]
            ll.append(objKey)
            if (objKey is not None):
              objKey = fullKey[-2]
              ll.append(objKey)
              if (objKey is not None):
                objKey = fullKey[-1]
                ll.append(objKey)
                if (objKey is not None):
                  objKey = tuple(ll)

          obj4 = obj3.__dict__.get('peakContribs').get(objKey)
          result = obj4

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = memops.api.Implementation.MemopsObject.getByNavigation

  getClassName = memops.api.Implementation.ComplexDataType.getClassName
  
  def getConstraint(self):
    """
    Get for ccp.nmr.NmrConstraint.ConstraintPeakContrib.constraint
    """
    dataDict = self.__dict__
    result = dataDict.get('constraint')
    return result
  
  def getDataSourceSerial(self):
    """
    Get for ccp.nmr.NmrConstraint.ConstraintPeakContrib.dataSourceSerial
    """
    dataDict = self.__dict__
    result = dataDict.get('dataSourceSerial')
    return result

  getExpandedKey = memops.api.Implementation.MemopsObject.getExpandedKey
  
  def getExperimentSerial(self):
    """
    Get for ccp.nmr.NmrConstraint.ConstraintPeakContrib.experimentSerial
    """
    dataDict = self.__dict__
    result = dataDict.get('experimentSerial')
    return result

  getFieldNames = memops.api.Implementation.ComplexDataType.getFieldNames
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccp.nmr.NmrConstraint.ConstraintPeakContrib
    """
    dataDict = self.__dict__
    result = list()

    obj3 = dataDict.get('constraint')
    obj2 = obj3.__dict__.get('parentList')
    obj1 = obj2.__dict__.get('nmrConstraintStore')

    if (useGuid):
      result.append(obj1.__dict__.get('guid'))
    else:
      result.append(obj1.__dict__.get('serial'))

    result.append(obj2.__dict__.get('serial'))
    result.append(obj3.__dict__.get('serial'))
    result.append(dataDict.get('experimentSerial'))
    result.append(dataDict.get('dataSourceSerial'))
    result.append(dataDict.get('peakListSerial'))
    result.append(dataDict.get('peakSerial'))

    return result

  getInConstructor = memops.api.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = memops.api.Implementation.MemopsObject.getIsDeleted
  
  def getLocalKey(self):
    """
    GetLocalKey for ccp.nmr.NmrConstraint.ConstraintPeakContrib
    """
    dataDict = self.__dict__
    ll = list()
    result = dataDict.get('experimentSerial')
    ll.append(result)
    if (result is not None):
      result = dataDict.get('dataSourceSerial')
      ll.append(result)
      if (result is not None):
        result = dataDict.get('peakListSerial')
        ll.append(result)
        if (result is not None):
          result = dataDict.get('peakSerial')
          ll.append(result)
          if (result is not None):
            result = tuple(ll)

    return result

  getMetaclass = memops.api.Implementation.ComplexDataType.getMetaclass

  getPackageName = memops.api.Implementation.ComplexDataType.getPackageName

  getPackageShortName = memops.api.Implementation.ComplexDataType.getPackageShortName
  
  def getParent(self):
    """
    Get for ccp.nmr.NmrConstraint.ConstraintPeakContrib.parent
    """
    dataDict = self.__dict__
    result = dataDict.get('constraint')
    return result
  
  def getPeak(self):
    """
    getter for derived link peak
    """
    dataDict = self.__dict__
    result = self.getByNavigation('constraint', 'parentList', 'nmrConstraintStore', 'nmrProject', ('experiments',self.experimentSerial), ('dataSources',self.dataSourceSerial), ('peakLists',self.peakListSerial), ('peaks',self.peakSerial),)
    return result
  
  def getPeakListSerial(self):
    """
    Get for ccp.nmr.NmrConstraint.ConstraintPeakContrib.peakListSerial
    """
    dataDict = self.__dict__
    result = dataDict.get('peakListSerial')
    return result
  
  def getPeakSerial(self):
    """
    Get for ccp.nmr.NmrConstraint.ConstraintPeakContrib.peakSerial
    """
    dataDict = self.__dict__
    result = dataDict.get('peakSerial')
    return result

  getQualifiedName = memops.api.Implementation.ComplexDataType.getQualifiedName

  getRoot = memops.api.Implementation.MemopsObject.getRoot

  getTopObject = memops.api.Implementation.DataObject.getTopObject

  removeApplicationData = memops.api.Implementation.DataObject.removeApplicationData
  
  def set(self, name, value):
    """
    SetAttr for ccp.nmr.NmrConstraint.ConstraintPeakContrib
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setAccess = memops.api.Implementation.DataObject.setAccess

  setApplicationData = memops.api.Implementation.DataObject.setApplicationData
  
  def setDataSourceSerial(self, value):
    """
    Set for ccp.nmr.NmrConstraint.ConstraintPeakContrib.dataSourceSerial
    """
    dataDict = self.__dict__
    if (isinstance(value, memops.api.Implementation.Int.PythonType)):
      pass
    elif ([x for x in memops.api.Implementation.Int.compatibleTypes if isinstance(value, x)]):
      value = memops.api.Implementation.Int.create(value)
    else:
      raise ApiError("""%s.setDataSourceSerial:
       memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('dataSourceSerial')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setDataSourceSerial:
       called on deleted object""" % self.qualifiedName
      )

    if (value == currentValue):
      return

    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setDataSourceSerial:
         cannot set dataSourceSerial, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is None):
        raise ApiError("""%s.setDataSourceSerial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    dataDict['dataSourceSerial'] = value

    # doNotifies
  
  def setExperimentSerial(self, value):
    """
    Set for ccp.nmr.NmrConstraint.ConstraintPeakContrib.experimentSerial
    """
    dataDict = self.__dict__
    if (isinstance(value, memops.api.Implementation.Int.PythonType)):
      pass
    elif ([x for x in memops.api.Implementation.Int.compatibleTypes if isinstance(value, x)]):
      value = memops.api.Implementation.Int.create(value)
    else:
      raise ApiError("""%s.setExperimentSerial:
       memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('experimentSerial')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setExperimentSerial:
       called on deleted object""" % self.qualifiedName
      )

    if (value == currentValue):
      return

    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setExperimentSerial:
         cannot set experimentSerial, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is None):
        raise ApiError("""%s.setExperimentSerial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    dataDict['experimentSerial'] = value

    # doNotifies
  
  def setPeak(self, value):
    """
    setter for derived link peak
    """
    dataDict = self.__dict__
    if (value is not None):
      from ccp.api.nmr.Nmr import Peak as importedType
      if (not isinstance(value, importedType)):
        raise ApiError("""%s.setPeak:
         value is not of class ccp.nmr.Nmr.Peak""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = self.getPeak()
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setPeak:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setPeak:
       called on deleted object""" % self.qualifiedName
      )

    if (value is not None):
      if (value.__dict__.get('isDeleted')):
        raise ApiError("""%s.setPeak:
         called with deleted value""" % self.qualifiedName
        )

    if (value == currentValue):
      return

    self.peakSerial = value.serial
    pl = value.peakList
    self.peakListSerial = pl.serial
    ds = pl.dataSource
    self.dataSourceSerial = ds.serial
    self.experimentSerial = ds.experiment.serial
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

  def setPeakListSerial(self, value):
    """
    Set for ccp.nmr.NmrConstraint.ConstraintPeakContrib.peakListSerial
    """
    dataDict = self.__dict__
    if (isinstance(value, memops.api.Implementation.Int.PythonType)):
      pass
    elif ([x for x in memops.api.Implementation.Int.compatibleTypes if isinstance(value, x)]):
      value = memops.api.Implementation.Int.create(value)
    else:
      raise ApiError("""%s.setPeakListSerial:
       memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('peakListSerial')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setPeakListSerial:
       called on deleted object""" % self.qualifiedName
      )

    if (value == currentValue):
      return

    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setPeakListSerial:
         cannot set peakListSerial, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is None):
        raise ApiError("""%s.setPeakListSerial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    dataDict['peakListSerial'] = value

    # doNotifies
  
  def setPeakSerial(self, value):
    """
    Set for ccp.nmr.NmrConstraint.ConstraintPeakContrib.peakSerial
    """
    dataDict = self.__dict__
    if (isinstance(value, memops.api.Implementation.Int.PythonType)):
      pass
    elif ([x for x in memops.api.Implementation.Int.compatibleTypes if isinstance(value, x)]):
      value = memops.api.Implementation.Int.create(value)
    else:
      raise ApiError("""%s.setPeakSerial:
       memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('peakSerial')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setPeakSerial:
       called on deleted object""" % self.qualifiedName
      )

    if (value == currentValue):
      return

    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setPeakSerial:
         cannot set peakSerial, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is None):
        raise ApiError("""%s.setPeakSerial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    dataDict['peakSerial'] = value

    # doNotifies

  toDetailedString = memops.api.Implementation.ComplexDataType.toDetailedString

  applicationData = memops.api.Implementation.DataObject.applicationData

  className = memops.api.Implementation.ComplexDataType.className
  
  dataSourceSerial = property(getDataSourceSerial, setDataSourceSerial, None,
  r"""Serial number for DataSource containing peak
  """)
  
  experimentSerial = property(getExperimentSerial, setExperimentSerial, None,
  r"""Serial number for Experiment containing peak
  """)

  fieldNames = memops.api.Implementation.ComplexDataType.fieldNames

  inConstructor = memops.api.Implementation.ComplexDataType.inConstructor

  isDeleted = memops.api.Implementation.MemopsObject.isDeleted

  metaclass = memops.api.Implementation.ComplexDataType.metaclass

  packageName = memops.api.Implementation.ComplexDataType.packageName

  packageShortName = memops.api.Implementation.ComplexDataType.packageShortName
  
  peakListSerial = property(getPeakListSerial, setPeakListSerial, None,
  r"""Serial number for peakList containing peak
  """)
  
  peakSerial = property(getPeakSerial, setPeakSerial, None,
  r"""Serial number for Peak
  """)

  qualifiedName = memops.api.Implementation.ComplexDataType.qualifiedName

  access = memops.api.Implementation.DataObject.access
  
  constraint = property(getConstraint,  None, None,
  r"""parent link
  """)
  
  parent = property(getParent, None, None,
  r"""link to parent object - synonym for constraint
  """)
  
  peak = property(getPeak, setPeak, None,
  r"""peak connected to by ConstraintPeakContrib.
  """)

  root = memops.api.Implementation.MemopsObject.root

  topObject = memops.api.Implementation.DataObject.topObject

###############################################################################
class DihedralConstraintItem(memops.api.Implementation.DataObject):
  r"""Range of dihedral angle values allowed for a Dihedral angle constraint. 
One of possibly several ranges allowed for a given (unambiguously 
assigned) constraint.
  """
  #   from data model element ccp.nmr.NmrConstraint.DihedralConstraintItem revision 1.36.2.9
  _metaclass = metaPackage.getElement('DihedralConstraintItem')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('applicationData', 'className', 'error', 'fieldNames', 'inConstructor', 'isDeleted', 'lowerLimit', 'metaclass', 'packageName', 'packageShortName', 'qualifiedName', 'serial', 'targetValue', 'upperLimit', 'access', 'constraint', 'parent', 'root', 'topObject',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccp.nmr.NmrConstraint.DihedralConstraintItem
    """
    dataDict = self.__dict__
    dataDict['constraint'] = parent
    if (not isinstance(parent, DihedralConstraint)):
      raise ApiError("""%s.__init__:
       value is not of class ccp.nmr.NmrConstraint.DihedralConstraint""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:

      dataDict['applicationData'] = list()
      dataDict['error'] = None
      dataDict['lowerLimit'] = None
      dataDict['serial'] = None
      dataDict['targetValue'] = None
      dataDict['upperLimit'] = None
      dataDict['access'] = None

      dataDict['inConstructor'] = True
      try:
        
        for key, value in attrlinks.iteritems():
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        del dataDict['inConstructor']
      except:
        print "ERROR in ccp.nmr.NmrConstraint.DihedralConstraintItem.__init__"
        del dataDict['inConstructor']
        raise

      if (notOverride):
        if (dataDict.get('serial') is None):
          dataDict['inConstructor'] = True
          self.setSerial(-1)
          del dataDict['inConstructor']
        else:
          raise ApiError("""%s.__init__:
           Cannot pass in explicit serial if not reading""" % self.qualifiedName
           + ": %s:%s" % (parent, 'ccp.nmr.NmrConstraint.DihedralConstraintItem')
          )

      if (notIsReading):
        childrenDict = parent.__dict__.get('items')
        objKey = dataDict.get('serial')
        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['serial'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        print '''WARNING Error in clean-up of incorrectly created object. 
        Data may be left in an illegal state'''
        del dataDict['inConstructor']
      raise exc_info[0], exc_info[1], exc_info[2]

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccp.nmr.NmrConstraint.DihedralConstraintItem:
       
    determines cascading deletes to follow from delete of object.
       
    *Implementation function* - should be called only by API delete 
    function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
      dataDict.get('topObject').load()

    access = dataDict.get('access')
    if (access is not None):
      topObject = access.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccp.nmr.NmrConstraint.DihedralConstraintItem:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    access = dataDict.get('access')
    if ((access is not None and not (access in objsToBeDeleted))):
      dataObjects = access.__dict__.get('dataObjects')
      dataObjects.remove(self)

    constraint = dataDict.get('constraint')
    if (not (constraint in objsToBeDeleted)):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = constraint.__dict__.get('items')
        if (self is dd.get(objKey)):
          del dd[objKey]

  addApplicationData = memops.api.Implementation.DataObject.addApplicationData
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccp.nmr.NmrConstraint.DihedralConstraintItem
    """
    dataDict = self.__dict__
    self.checkValid(complete)
  
  def checkValid(self, complete=False):
    """
    CheckValid for ccp.nmr.NmrConstraint.DihedralConstraintItem
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('constraint')
        dd = value.__dict__.get('items')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'constraint' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from memops.api.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('error')
      if (value is not None):
        if (isinstance(value, memops.api.Implementation.Float.PythonType)):
          pass
        elif ([x for x in memops.api.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = memops.api.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: error:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: error:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('lowerLimit')
      if (isinstance(value, memops.api.Implementation.Float.PythonType)):
        pass
      elif ([x for x in memops.api.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = memops.api.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.checkValid: lowerLimit:
         memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.checkValid: lowerLimit:
         Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, memops.api.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('serial')
      if (value is None):
        raise ApiError("""%s.checkValid: serial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, memops.api.Implementation.Int.PythonType)):
        pass
      elif ([x for x in memops.api.Implementation.Int.compatibleTypes if isinstance(value, x)]):
        value = memops.api.Implementation.Int.create(value)
      else:
        raise ApiError("""%s.checkValid: serial:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('targetValue')
      if (value is not None):
        if (isinstance(value, memops.api.Implementation.Float.PythonType)):
          pass
        elif ([x for x in memops.api.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = memops.api.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: targetValue:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: targetValue:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('upperLimit')
      if (isinstance(value, memops.api.Implementation.Float.PythonType)):
        pass
      elif ([x for x in memops.api.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = memops.api.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.checkValid: upperLimit:
         memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.checkValid: upperLimit:
         Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('access')
      if (value is not None):
        from memops.api.AccessControl import AccessObject as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: access:
           value is not of class memops.AccessControl.AccessObject""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('dataObjects')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: access:
           non-reciprocal link DihedralConstraintItem from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      value = dataDict.get('constraint')
      if (not isinstance(value, DihedralConstraint)):
        raise ApiError("""%s.checkValid: constraint:
         value is not of class ccp.nmr.NmrConstraint.DihedralConstraint""" % self.qualifiedName
         + ": %s" % (value,)
        )

    # check explicit class constraints
    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('error')
    value = dataDict.get('lowerLimit')
    if (value is None):
      raise ApiError("""%s.checkValid: lowerLimit:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    value = dataDict.get('targetValue')
    value = dataDict.get('upperLimit')
    if (value is None):
      raise ApiError("""%s.checkValid: upperLimit:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    # check roles
    value = dataDict.get('access')
    value = dataDict.get('constraint')
    if (value is None):
      raise ApiError("""%s.checkValid: constraint:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

  delete = memops.api.Implementation.DataObject.delete

  findAllApplicationData = memops.api.Implementation.DataObject.findAllApplicationData

  findFirstApplicationData = memops.api.Implementation.DataObject.findFirstApplicationData
  
  def get(self, name):
    """
    GetAttr for ccp.nmr.NmrConstraint.DihedralConstraintItem
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getAccess = memops.api.Implementation.DataObject.getAccess

  getApplicationData = memops.api.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.DihedralConstraintItem
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (4 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.DihedralConstraintItem'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (3 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.DihedralConstraintItem'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-3]
      obj2 = obj1.__dict__.get('constraintLists').get(objKey)

      if (obj2 is not None):
        objKey = fullKey[-2]
        obj3 = obj2.__dict__.get('constraints').get(objKey)

        if (obj3 is not None):
          objKey = fullKey[-1]
          obj4 = obj3.__dict__.get('items').get(objKey)
          result = obj4

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = memops.api.Implementation.MemopsObject.getByNavigation

  getClassName = memops.api.Implementation.ComplexDataType.getClassName
  
  def getConstraint(self):
    """
    Get for ccp.nmr.NmrConstraint.DihedralConstraintItem.constraint
    """
    dataDict = self.__dict__
    result = dataDict.get('constraint')
    return result
  
  def getError(self):
    """
    Get for ccp.nmr.NmrConstraint.DihedralConstraintItem.error
    """
    dataDict = self.__dict__
    result = dataDict.get('error')
    return result

  getExpandedKey = memops.api.Implementation.MemopsObject.getExpandedKey

  getFieldNames = memops.api.Implementation.ComplexDataType.getFieldNames
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccp.nmr.NmrConstraint.DihedralConstraintItem
    """
    dataDict = self.__dict__
    result = list()

    obj3 = dataDict.get('constraint')
    obj2 = obj3.__dict__.get('parentList')
    obj1 = obj2.__dict__.get('nmrConstraintStore')

    if (useGuid):
      result.append(obj1.__dict__.get('guid'))
    else:
      result.append(obj1.__dict__.get('serial'))

    result.append(obj2.__dict__.get('serial'))
    result.append(obj3.__dict__.get('serial'))
    result.append(dataDict.get('serial'))

    return result

  getInConstructor = memops.api.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = memops.api.Implementation.MemopsObject.getIsDeleted
  
  def getLocalKey(self):
    """
    GetLocalKey for ccp.nmr.NmrConstraint.DihedralConstraintItem
    """
    dataDict = self.__dict__
    result = dataDict.get('serial')
    return result
  
  def getLowerLimit(self):
    """
    Get for ccp.nmr.NmrConstraint.DihedralConstraintItem.lowerLimit
    """
    dataDict = self.__dict__
    result = dataDict.get('lowerLimit')
    return result

  getMetaclass = memops.api.Implementation.ComplexDataType.getMetaclass

  getPackageName = memops.api.Implementation.ComplexDataType.getPackageName

  getPackageShortName = memops.api.Implementation.ComplexDataType.getPackageShortName
  
  def getParent(self):
    """
    Get for ccp.nmr.NmrConstraint.DihedralConstraintItem.parent
    """
    dataDict = self.__dict__
    result = dataDict.get('constraint')
    return result

  getQualifiedName = memops.api.Implementation.ComplexDataType.getQualifiedName

  getRoot = memops.api.Implementation.MemopsObject.getRoot
  
  def getSerial(self):
    """
    Get for ccp.nmr.NmrConstraint.DihedralConstraintItem.serial
    """
    dataDict = self.__dict__
    result = dataDict.get('serial')
    return result
  
  def getTargetValue(self):
    """
    Get for ccp.nmr.NmrConstraint.DihedralConstraintItem.targetValue
    """
    dataDict = self.__dict__
    result = dataDict.get('targetValue')
    return result

  getTopObject = memops.api.Implementation.DataObject.getTopObject
  
  def getUpperLimit(self):
    """
    Get for ccp.nmr.NmrConstraint.DihedralConstraintItem.upperLimit
    """
    dataDict = self.__dict__
    result = dataDict.get('upperLimit')
    return result

  removeApplicationData = memops.api.Implementation.DataObject.removeApplicationData
  
  def set(self, name, value):
    """
    SetAttr for ccp.nmr.NmrConstraint.DihedralConstraintItem
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setAccess = memops.api.Implementation.DataObject.setAccess

  setApplicationData = memops.api.Implementation.DataObject.setApplicationData
  
  def setError(self, value):
    """
    Set for ccp.nmr.NmrConstraint.DihedralConstraintItem.error
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, memops.api.Implementation.Float.PythonType)):
        pass
      elif ([x for x in memops.api.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = memops.api.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.setError:
         memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.setError:
         Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('error')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setError:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setError:
       called on deleted object""" % self.qualifiedName
      )

    if (value == currentValue):
      return

    if (notOverride):
      pass

    dataDict['error'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setError')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  def setLowerLimit(self, value):
    """
    Set for ccp.nmr.NmrConstraint.DihedralConstraintItem.lowerLimit
    """
    dataDict = self.__dict__
    if (isinstance(value, memops.api.Implementation.Float.PythonType)):
      pass
    elif ([x for x in memops.api.Implementation.Float.compatibleTypes if isinstance(value, x)]):
      value = memops.api.Implementation.Float.create(value)
    else:
      raise ApiError("""%s.setLowerLimit:
       memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (value - value == 0.0)):
      raise ApiError("""%s.setLowerLimit:
       Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('lowerLimit')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setLowerLimit:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setLowerLimit:
       called on deleted object""" % self.qualifiedName
      )

    if (value == currentValue):
      return

    if (notOverride):
      if (value is None):
        raise ApiError("""%s.setLowerLimit:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    dataDict['lowerLimit'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setLowerLimit')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  def setSerial(self, value):
    """
    Set for ccp.nmr.NmrConstraint.DihedralConstraintItem.serial
    """
    dataDict = self.__dict__
    if (isinstance(value, memops.api.Implementation.Int.PythonType)):
      pass
    elif ([x for x in memops.api.Implementation.Int.compatibleTypes if isinstance(value, x)]):
      value = memops.api.Implementation.Int.create(value)
    else:
      raise ApiError("""%s.setSerial:
       memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('serial')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setSerial:
       called on deleted object""" % self.qualifiedName
      )

    if (value == currentValue):
      return

    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setSerial:
         cannot set serial, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is None):
        raise ApiError("""%s.setSerial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    parent = dataDict.get('constraint')
    oldSerial = parent.__dict__.get('_serialDict').get('items')
    if (value < 0):
      value = (oldSerial + 1)
      parent.__dict__.get('_serialDict')['items'] = value
    elif (value > oldSerial):
      parent.__dict__.get('_serialDict')['items'] = value

    dataDict['serial'] = value

    # doNotifies
  
  def setTargetValue(self, value):
    """
    Set for ccp.nmr.NmrConstraint.DihedralConstraintItem.targetValue
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, memops.api.Implementation.Float.PythonType)):
        pass
      elif ([x for x in memops.api.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = memops.api.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.setTargetValue:
         memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.setTargetValue:
         Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('targetValue')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setTargetValue:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setTargetValue:
       called on deleted object""" % self.qualifiedName
      )

    if (value == currentValue):
      return

    if (notOverride):
      pass

    dataDict['targetValue'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setTargetValue')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  def setUpperLimit(self, value):
    """
    Set for ccp.nmr.NmrConstraint.DihedralConstraintItem.upperLimit
    """
    dataDict = self.__dict__
    if (isinstance(value, memops.api.Implementation.Float.PythonType)):
      pass
    elif ([x for x in memops.api.Implementation.Float.compatibleTypes if isinstance(value, x)]):
      value = memops.api.Implementation.Float.create(value)
    else:
      raise ApiError("""%s.setUpperLimit:
       memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (value - value == 0.0)):
      raise ApiError("""%s.setUpperLimit:
       Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('upperLimit')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setUpperLimit:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setUpperLimit:
       called on deleted object""" % self.qualifiedName
      )

    if (value == currentValue):
      return

    if (notOverride):
      if (value is None):
        raise ApiError("""%s.setUpperLimit:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    dataDict['upperLimit'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setUpperLimit')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  toDetailedString = memops.api.Implementation.ComplexDataType.toDetailedString

  applicationData = memops.api.Implementation.DataObject.applicationData

  className = memops.api.Implementation.ComplexDataType.className
  
  error = property(getError, setError, None,
  r"""Uncertainty (estimated standard devaition) of targetValue
  """)

  fieldNames = memops.api.Implementation.ComplexDataType.fieldNames

  inConstructor = memops.api.Implementation.ComplexDataType.inConstructor

  isDeleted = memops.api.Implementation.MemopsObject.isDeleted
  
  lowerLimit = property(getLowerLimit, setLowerLimit, None,
  r"""Lower Angle Limit (in degrees). Energy penalty is zero between 
  upperLimit and lowerLimit.
  """)

  metaclass = memops.api.Implementation.ComplexDataType.metaclass

  packageName = memops.api.Implementation.ComplexDataType.packageName

  packageShortName = memops.api.Implementation.ComplexDataType.packageShortName

  qualifiedName = memops.api.Implementation.ComplexDataType.qualifiedName
  
  serial = property(getSerial, setSerial, None,
  r"""The serial number is the key for class DihedralConstraintItem and 
  together with the parent object serves as a unique identifier for the 
  DihedralConstraintItem.
  Serial numbers are generated by the API. Serial 
  numbers of deleted objects are not reused.
  """)
  
  targetValue = property(getTargetValue, setTargetValue, None,
  r"""Desired value of constrained parameter
  """)
  
  upperLimit = property(getUpperLimit, setUpperLimit, None,
  r"""Upper angle limit (in degrees). Energy penalty is zero between 
  upperLimit and lowerLimit.
  """)

  access = memops.api.Implementation.DataObject.access
  
  constraint = property(getConstraint,  None, None,
  r"""parent link
  """)
  
  parent = property(getParent, None, None,
  r"""link to parent object - synonym for constraint
  """)

  root = memops.api.Implementation.MemopsObject.root

  topObject = memops.api.Implementation.DataObject.topObject

###############################################################################
class FixedAtomSet(memops.api.Implementation.DataObject):
  r"""Fixed version of AtomSet. When a Structure Generation run is started, 
AtomSets and ResonanceSets are copied to FixedAtomSets and 
FixedResonanceSets in order to preserve the Resonance-Atom assignment 
valid for a StructureGeneration and the associated ConstraintLists.
  """
  #   from data model element ccp.nmr.NmrConstraint.FixedAtomSet revision 1.37.2.9
  _metaclass = metaPackage.getElement('FixedAtomSet')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('applicationData', 'className', 'fieldNames', 'inConstructor', 'isDeleted', 'metaclass', 'name', 'packageName', 'packageShortName', 'qualifiedName', 'serial', 'access', 'atoms', 'nmrConstraintStore', 'parent', 'resonanceSets', 'root', 'topObject',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccp.nmr.NmrConstraint.FixedAtomSet
    """
    dataDict = self.__dict__
    dataDict['nmrConstraintStore'] = parent
    if (not isinstance(parent, NmrConstraintStore)):
      raise ApiError("""%s.__init__:
       value is not of class ccp.nmr.NmrConstraint.NmrConstraintStore""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:
      if (not ((parent.__dict__.get('isLoaded') or parent.__dict__.get('isReading')))):
        parent.load()

      dataDict['applicationData'] = list()
      dataDict['name'] = None
      dataDict['serial'] = None
      dataDict['access'] = None
      dataDict['atoms'] = set()
      dataDict['resonanceSets'] = set()

      dataDict['inConstructor'] = True
      try:
        
        for key, value in attrlinks.iteritems():
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        del dataDict['inConstructor']
      except:
        print "ERROR in ccp.nmr.NmrConstraint.FixedAtomSet.__init__"
        del dataDict['inConstructor']
        raise

      if (notOverride):
        if (dataDict.get('serial') is None):
          dataDict['inConstructor'] = True
          self.setSerial(-1)
          del dataDict['inConstructor']
        else:
          raise ApiError("""%s.__init__:
           Cannot pass in explicit serial if not reading""" % self.qualifiedName
           + ": %s:%s" % (parent, 'ccp.nmr.NmrConstraint.FixedAtomSet')
          )

      if (notIsReading):
        childrenDict = parent.__dict__.get('fixedAtomSets')
        objKey = dataDict.get('serial')
        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['serial'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        print '''WARNING Error in clean-up of incorrectly created object. 
        Data may be left in an illegal state'''
        del dataDict['inConstructor']
      raise exc_info[0], exc_info[1], exc_info[2]

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccp.nmr.NmrConstraint.FixedAtomSet:
       determines 
    cascading deletes to follow from delete of object.
       *Implementation 
    function* - should be called only by API delete function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
      dataDict.get('topObject').load()

    access = dataDict.get('access')
    if (access is not None):
      topObject = access.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    atoms = dataDict.get('atoms')
    pass
    for atom in atoms:
      topObject = atom.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    resonanceSets = dataDict.get('resonanceSets')
    for resonanceSet in resonanceSets:
      if (not (resonanceSet in objsToBeDeleted)):
        backlink = resonanceSet.__dict__.get('atomSets')
        key = (resonanceSet, 'atomSets')
        nFound = linkCounter.get(key)
        if (nFound is None):
          nFound = 1
        else:
          nFound = nFound + 1
          del linkCounter[key]

        if (len(backlink) - nFound < 1):
          objsToBeDeleted.add(resonanceSet)
          objsToBeChecked.append(resonanceSet)
        else:
          linkCounter[key] = nFound

    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccp.nmr.NmrConstraint.FixedAtomSet:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    access = dataDict.get('access')
    if ((access is not None and not (access in objsToBeDeleted))):
      dataObjects = access.__dict__.get('dataObjects')
      dataObjects.remove(self)

    for atom in dataDict.get('atoms'):
      if (not (atom in objsToBeDeleted)):
        fixedAtomSets = atom.__dict__.get('fixedAtomSets')
        fixedAtomSets.remove(self)

    for resonanceSet in dataDict.get('resonanceSets'):
      if (not (resonanceSet in objsToBeDeleted)):
        atomSets = resonanceSet.__dict__.get('atomSets')
        atomSets.remove(self)

    nmrConstraintStore = dataDict.get('nmrConstraintStore')
    if (not (nmrConstraintStore in objsToBeDeleted)):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = nmrConstraintStore.__dict__.get('fixedAtomSets')
        if (self is dd.get(objKey)):
          del dd[objKey]

  addApplicationData = memops.api.Implementation.DataObject.addApplicationData
  
  def addAtom(self, value):
    """
    Add for ccp.nmr.NmrConstraint.FixedAtomSet.atoms
    """
    dataDict = self.__dict__
    from ccp.api.molecule.MolSystem import Atom as importedType
    if (not isinstance(value, importedType)):
      raise ApiError("""%s.addAtom:
       value is not of class ccp.molecule.MolSystem.Atom""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('atoms')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      topObject = value.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)
      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.addAtom:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.addAtom:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.addAtom:
       called with deleted value""" % self.qualifiedName
      )

    if (value in currentValues):
      raise ApiError("""%s.addAtom:
       value is in list already""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      if (value is not None):
        xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.addAtom:
           Link atoms between objects from separate partitions
           - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    oldSelves = value.__dict__.get('fixedAtomSets')
    oldSelves.add(self)
    currentValues.add(value)
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('addAtom')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  def addResonanceSet(self, value):
    """
    Add for ccp.nmr.NmrConstraint.FixedAtomSet.resonanceSets
    """
    dataDict = self.__dict__
    if (not isinstance(value, FixedResonanceSet)):
      raise ApiError("""%s.addResonanceSet:
       value is not of class ccp.nmr.NmrConstraint.FixedResonanceSet""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('resonanceSets')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.addResonanceSet:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.addResonanceSet:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.addResonanceSet:
       called with deleted value""" % self.qualifiedName
      )

    if (value in currentValues):
      raise ApiError("""%s.addResonanceSet:
       value is in list already""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      if (value is not None):
        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.addResonanceSet:
           Link resonanceSets between objects from separate partitions
           - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    oldSelves = value.__dict__.get('atomSets')
    oldSelves.add(self)
    currentValues.add(value)
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('addResonanceSet')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccp.nmr.NmrConstraint.FixedAtomSet
    """
    dataDict = self.__dict__
    self.checkValid(complete)
  
  def checkValid(self, complete=False):
    """
    CheckValid for ccp.nmr.NmrConstraint.FixedAtomSet
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('nmrConstraintStore')
        dd = value.__dict__.get('fixedAtomSets')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'nmrConstraintStore' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from memops.api.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('name')
      if (value is not None):
        if (isinstance(value, memops.api.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: name:
           memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 32):
          raise ApiError("""%s.checkValid: name:
           memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: name:
           memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.split()) == 1)):
          raise ApiError("""%s.checkValid: name:
           Word constraint contains_no_white_space violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, memops.api.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('serial')
      if (value is None):
        raise ApiError("""%s.checkValid: serial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, memops.api.Implementation.Int.PythonType)):
        pass
      elif ([x for x in memops.api.Implementation.Int.compatibleTypes if isinstance(value, x)]):
        value = memops.api.Implementation.Int.create(value)
      else:
        raise ApiError("""%s.checkValid: serial:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('access')
      if (value is not None):
        from memops.api.AccessControl import AccessObject as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: access:
           value is not of class memops.AccessControl.AccessObject""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('dataObjects')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: access:
           non-reciprocal link FixedAtomSet from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('atoms')
      for value in values:
        from ccp.api.molecule.MolSystem import Atom as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: atoms:
           value is not of class ccp.molecule.MolSystem.Atom""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('fixedAtomSets')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: atoms:
           non-reciprocal link FixedAtomSet from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: atoms:
           Link atoms between objects from separate partitions
           - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      value = dataDict.get('nmrConstraintStore')
      if (not isinstance(value, NmrConstraintStore)):
        raise ApiError("""%s.checkValid: nmrConstraintStore:
         value is not of class ccp.nmr.NmrConstraint.NmrConstraintStore""" % self.qualifiedName
         + ": %s" % (value,)
        )

      values = dataDict.get('resonanceSets')
      for value in values:
        if (not isinstance(value, FixedResonanceSet)):
          raise ApiError("""%s.checkValid: resonanceSets:
           value is not of class ccp.nmr.NmrConstraint.FixedResonanceSet""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('atomSets')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: resonanceSets:
           non-reciprocal link FixedAtomSet from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

    # check explicit class constraints
    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('name')
    # check roles
    value = dataDict.get('access')
    values = dataDict.get('atoms')
    if (len(values) < 1):
      raise ApiError("""%s.checkValid: atoms:
       locard: values must be of length >= 1""" % self.qualifiedName
       + ": %s" % (self,)
      )

    value = dataDict.get('nmrConstraintStore')
    if (value is None):
      raise ApiError("""%s.checkValid: nmrConstraintStore:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    values = dataDict.get('resonanceSets')

  delete = memops.api.Implementation.DataObject.delete

  findAllApplicationData = memops.api.Implementation.DataObject.findAllApplicationData
  
  def findAllAtoms(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.FixedAtomSet.atoms
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('atoms')
      result = set(currentValues)

    else:
      currentValues = dataDict.get('atoms')
      result = set()
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('name', 'access', 'atomSet', 'residue',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result.add(v)

    return result
  
  def findAllResonanceSets(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.FixedAtomSet.resonanceSets
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('resonanceSets')
      result = set(currentValues)

    else:
      currentValues = dataDict.get('resonanceSets')
      result = set()
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('serial', 'access', 'nmrConstraintStore',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result.add(v)

    return result

  findFirstApplicationData = memops.api.Implementation.DataObject.findFirstApplicationData
  
  def findFirstAtom(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.FixedAtomSet.atoms
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('atoms')
      if (currentValues):
        result = iter(currentValues).next()
      else:
        result = None

    else:
      currentValues = dataDict.get('atoms')
      result = None
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('name', 'access', 'atomSet', 'residue',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result = v; break

    return result
  
  def findFirstResonanceSet(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.FixedAtomSet.resonanceSets
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('resonanceSets')
      if (currentValues):
        result = iter(currentValues).next()
      else:
        result = None

    else:
      currentValues = dataDict.get('resonanceSets')
      result = None
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('serial', 'access', 'nmrConstraintStore',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result = v; break

    return result
  
  def get(self, name):
    """
    GetAttr for ccp.nmr.NmrConstraint.FixedAtomSet
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getAccess = memops.api.Implementation.DataObject.getAccess

  getApplicationData = memops.api.Implementation.DataObject.getApplicationData
  
  def getAtoms(self):
    """
    Get for ccp.nmr.NmrConstraint.FixedAtomSet.atoms
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('atoms')
    result = frozenset(tempVar)
    return result
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.FixedAtomSet
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (2 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.FixedAtomSet'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (1 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.FixedAtomSet'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-1]
      obj2 = obj1.__dict__.get('fixedAtomSets').get(objKey)
      result = obj2

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = memops.api.Implementation.MemopsObject.getByNavigation

  getClassName = memops.api.Implementation.ComplexDataType.getClassName

  getExpandedKey = memops.api.Implementation.MemopsObject.getExpandedKey

  getFieldNames = memops.api.Implementation.ComplexDataType.getFieldNames
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccp.nmr.NmrConstraint.FixedAtomSet
    """
    dataDict = self.__dict__
    result = list()

    obj1 = dataDict.get('nmrConstraintStore')

    if (useGuid):
      result.append(obj1.__dict__.get('guid'))
    else:
      result.append(obj1.__dict__.get('serial'))

    result.append(dataDict.get('serial'))

    return result

  getInConstructor = memops.api.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = memops.api.Implementation.MemopsObject.getIsDeleted
  
  def getLocalKey(self):
    """
    GetLocalKey for ccp.nmr.NmrConstraint.FixedAtomSet
    """
    dataDict = self.__dict__
    result = dataDict.get('serial')
    return result

  getMetaclass = memops.api.Implementation.ComplexDataType.getMetaclass
  
  def getName(self):
    """
    Get for ccp.nmr.NmrConstraint.FixedAtomSet.name
    """
    dataDict = self.__dict__
    result = dataDict.get('name')
    return result
  
  def getNmrConstraintStore(self):
    """
    Get for ccp.nmr.NmrConstraint.FixedAtomSet.nmrConstraintStore
    """
    dataDict = self.__dict__
    result = dataDict.get('nmrConstraintStore')
    return result

  getPackageName = memops.api.Implementation.ComplexDataType.getPackageName

  getPackageShortName = memops.api.Implementation.ComplexDataType.getPackageShortName
  
  def getParent(self):
    """
    Get for ccp.nmr.NmrConstraint.FixedAtomSet.parent
    """
    dataDict = self.__dict__
    result = dataDict.get('nmrConstraintStore')
    return result

  getQualifiedName = memops.api.Implementation.ComplexDataType.getQualifiedName
  
  def getResonanceSets(self):
    """
    Get for ccp.nmr.NmrConstraint.FixedAtomSet.resonanceSets
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('resonanceSets')
    result = frozenset(tempVar)
    return result

  getRoot = memops.api.Implementation.MemopsObject.getRoot
  
  def getSerial(self):
    """
    Get for ccp.nmr.NmrConstraint.FixedAtomSet.serial
    """
    dataDict = self.__dict__
    result = dataDict.get('serial')
    return result

  getTopObject = memops.api.Implementation.DataObject.getTopObject

  removeApplicationData = memops.api.Implementation.DataObject.removeApplicationData
  
  def removeAtom(self, value):
    """
    Remove for ccp.nmr.NmrConstraint.FixedAtomSet.atoms
    """
    dataDict = self.__dict__
    from ccp.api.molecule.MolSystem import Atom as importedType
    if (not isinstance(value, importedType)):
      raise ApiError("""%s.removeAtom:
       value is not of class ccp.molecule.MolSystem.Atom""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('atoms')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      topObject = value.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)
      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.removeAtom:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.removeAtom:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.removeAtom:
       called with deleted value""" % self.qualifiedName
      )

    if (not (value in currentValues)):
      raise ApiError("""%s.removeAtom:
       value not in list""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      if (len(currentValues) < (1 + 1)):
        raise ApiError("""%s.removeAtom:
         locard: currentValues: cannot remove value""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    oldSelves = value.__dict__.get('fixedAtomSets')
    oldSelves.remove(self)
    currentValues.remove(value)
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('removeAtom')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  def removeResonanceSet(self, value):
    """
    Remove for ccp.nmr.NmrConstraint.FixedAtomSet.resonanceSets
    """
    dataDict = self.__dict__
    if (not isinstance(value, FixedResonanceSet)):
      raise ApiError("""%s.removeResonanceSet:
       value is not of class ccp.nmr.NmrConstraint.FixedResonanceSet""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('resonanceSets')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.removeResonanceSet:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.removeResonanceSet:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.removeResonanceSet:
       called with deleted value""" % self.qualifiedName
      )

    if (not (value in currentValues)):
      raise ApiError("""%s.removeResonanceSet:
       value not in list""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      oldSelves = value.__dict__.get('atomSets')
      if (len(oldSelves) < (1 + 1)):
        raise ApiError("""%s.removeResonanceSet:
         locard: oldSelves: cannot remove value""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    oldSelves = value.__dict__.get('atomSets')
    oldSelves.remove(self)
    currentValues.remove(value)
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('removeResonanceSet')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  def set(self, name, value):
    """
    SetAttr for ccp.nmr.NmrConstraint.FixedAtomSet
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setAccess = memops.api.Implementation.DataObject.setAccess

  setApplicationData = memops.api.Implementation.DataObject.setApplicationData
  
  def setAtoms(self, values):
    """
    Set for ccp.nmr.NmrConstraint.FixedAtomSet.atoms
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setAtoms:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      from ccp.api.molecule.MolSystem import Atom as importedType
      if (not isinstance(value, importedType)):
        raise ApiError("""%s.setAtoms:
         value is not of class ccp.molecule.MolSystem.Atom""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('atoms')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      for pv in currentValues:
        if (not (pv in values)):
          topObject = pv.__dict__.get('topObject')
          topObjectsToCheck.add(topObject)

      for pv in values:
        if (not (pv in currentValues)):
          topObject = pv.__dict__.get('topObject')
          topObjectsToCheck.add(topObject)

      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setAtoms:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setAtoms:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setAtoms:
         an object in values is deleted""" % self.qualifiedName
        )

    if (values == currentValues):
      return

    if (notOverride):
      if (len(values) < 1):
        raise ApiError("""%s.setAtoms:
         locard: values must be of length >= 1""" % self.qualifiedName
         + ": %s" % (self,)
        )

      xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
      for value in values:
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setAtoms:
           Link atoms between objects from separate partitions
           - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    for cv in currentValues:
      if (not (cv in values)):
        oldSelves = cv.__dict__.get('fixedAtomSets')
        oldSelves.remove(self)

    for cv in values:
      if (not (cv in currentValues)):
        oldSelves = cv.__dict__.get('fixedAtomSets')
        oldSelves.add(self)

    dataDict['atoms'] = values
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setAtoms')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  def setName(self, value):
    """
    Set for ccp.nmr.NmrConstraint.FixedAtomSet.name
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, memops.api.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.setName:
         memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 32):
        raise ApiError("""%s.setName:
         memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.setName:
         memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.split()) == 1)):
        raise ApiError("""%s.setName:
         Word constraint contains_no_white_space violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('name')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setName:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setName:
       called on deleted object""" % self.qualifiedName
      )

    if (value == currentValue):
      return

    if (notOverride):
      pass

    dataDict['name'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setName')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  def setResonanceSets(self, values):
    """
    Set for ccp.nmr.NmrConstraint.FixedAtomSet.resonanceSets
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setResonanceSets:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      if (not isinstance(value, FixedResonanceSet)):
        raise ApiError("""%s.setResonanceSets:
         value is not of class ccp.nmr.NmrConstraint.FixedResonanceSet""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('resonanceSets')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setResonanceSets:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setResonanceSets:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setResonanceSets:
         an object in values is deleted""" % self.qualifiedName
        )

    if (values == currentValues):
      return

    if (notOverride):
      for cv in currentValues:
        if (not (cv in values)):
          oldSelves = cv.__dict__.get('atomSets')
          if (len(oldSelves) < (1 + 1)):
            raise ApiError("""%s.setResonanceSets:
             locard: oldSelves: cannot remove value""" % self.qualifiedName
             + ": %s" % (self,)
            )

      xx1 = dataDict.get('topObject')
      for value in values:
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setResonanceSets:
           Link resonanceSets between objects from separate partitions
           - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    for cv in currentValues:
      if (not (cv in values)):
        oldSelves = cv.__dict__.get('atomSets')
        oldSelves.remove(self)

    for cv in values:
      if (not (cv in currentValues)):
        oldSelves = cv.__dict__.get('atomSets')
        oldSelves.add(self)

    dataDict['resonanceSets'] = values
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setResonanceSets')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  def setSerial(self, value):
    """
    Set for ccp.nmr.NmrConstraint.FixedAtomSet.serial
    """
    dataDict = self.__dict__
    if (isinstance(value, memops.api.Implementation.Int.PythonType)):
      pass
    elif ([x for x in memops.api.Implementation.Int.compatibleTypes if isinstance(value, x)]):
      value = memops.api.Implementation.Int.create(value)
    else:
      raise ApiError("""%s.setSerial:
       memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('serial')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setSerial:
       called on deleted object""" % self.qualifiedName
      )

    if (value == currentValue):
      return

    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setSerial:
         cannot set serial, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is None):
        raise ApiError("""%s.setSerial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    parent = dataDict.get('nmrConstraintStore')
    oldSerial = parent.__dict__.get('_serialDict').get('fixedAtomSets')
    if (value < 0):
      value = (oldSerial + 1)
      parent.__dict__.get('_serialDict')['fixedAtomSets'] = value
    elif (value > oldSerial):
      parent.__dict__.get('_serialDict')['fixedAtomSets'] = value

    dataDict['serial'] = value

    # doNotifies
  
  def sortedAtoms(self):
    """
    Sorted for ccp.nmr.NmrConstraint.FixedAtomSet.atoms
    """
    dataDict = self.__dict__
    ll = dataDict.get('atoms')
    ll = [(x.getFullKey(),x) for x in ll]
    
    ll.sort()
    result = [x[1] for x in ll]
    return result
  
  def sortedResonanceSets(self):
    """
    Sorted for ccp.nmr.NmrConstraint.FixedAtomSet.resonanceSets
    """
    dataDict = self.__dict__
    ll = dataDict.get('resonanceSets')
    ll = [(x.getFullKey(),x) for x in ll]
    
    ll.sort()
    result = [x[1] for x in ll]
    return result

  toDetailedString = memops.api.Implementation.ComplexDataType.toDetailedString

  applicationData = memops.api.Implementation.DataObject.applicationData

  className = memops.api.Implementation.ComplexDataType.className

  fieldNames = memops.api.Implementation.ComplexDataType.fieldNames

  inConstructor = memops.api.Implementation.ComplexDataType.inConstructor

  isDeleted = memops.api.Implementation.MemopsObject.isDeleted

  metaclass = memops.api.Implementation.ComplexDataType.metaclass
  
  name = property(getName, setName, None,
  r"""name of FixedAtomSet
  """)

  packageName = memops.api.Implementation.ComplexDataType.packageName

  packageShortName = memops.api.Implementation.ComplexDataType.packageShortName

  qualifiedName = memops.api.Implementation.ComplexDataType.qualifiedName
  
  serial = property(getSerial, setSerial, None,
  r"""Serial number of object. Serves as object main key. Serial numbers of 
  deleted objects are not re-used. Serial numbers can only be set by the 
  implementation. Values are in practice always positive, since negative 
  values are interpreted as a signal to set the next free serial
  """)

  access = memops.api.Implementation.DataObject.access
  
  atoms = property(getAtoms, setAtoms, None,
  r"""Atoms making up FixedAtomSet
  """)
  
  nmrConstraintStore = property(getNmrConstraintStore,  None, None,
  r"""parent link
  """)
  
  parent = property(getParent, None, None,
  r"""link to parent object - synonym for nmrConstraintStore
  """)
  
  resonanceSets = property(getResonanceSets, setResonanceSets, None,
  r"""FixedResonanceSets associated with FixedAtomSet.
  """)

  root = memops.api.Implementation.MemopsObject.root

  topObject = memops.api.Implementation.DataObject.topObject

###############################################################################
class FixedResonance(memops.api.Implementation.DataObject):
  r"""Permanent, unchanging copy of Nmr.Resonance.
  """
  #   from data model element ccp.nmr.NmrConstraint.FixedResonance revision 1.42.2.9
  _metaclass = metaPackage.getElement('FixedResonance')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('applicationData', 'className', 'details', 'fieldNames', 'inConstructor', 'isDeleted', 'isotopeCode', 'metaclass', 'name', 'packageName', 'packageShortName', 'qualifiedName', 'resonanceSerial', 'serial', 'access', 'chainStateLinks', 'chemShiftConstraints', 'csaConstraints', 'dihedralConstraints', 'isotope', 'nmrConstraintStore', 'pairwiseConstraintItems', 'parent', 'resCoords', 'resonance', 'resonanceSet', 'root', 'topObject',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccp.nmr.NmrConstraint.FixedResonance
    """
    dataDict = self.__dict__
    dataDict['nmrConstraintStore'] = parent
    if (not isinstance(parent, NmrConstraintStore)):
      raise ApiError("""%s.__init__:
       value is not of class ccp.nmr.NmrConstraint.NmrConstraintStore""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:
      if (not ((parent.__dict__.get('isLoaded') or parent.__dict__.get('isReading')))):
        parent.load()

      dataDict['applicationData'] = list()
      dataDict['details'] = None
      dataDict['isotopeCode'] = None
      dataDict['name'] = None
      dataDict['resonanceSerial'] = None
      dataDict['serial'] = None
      dataDict['access'] = None
      dataDict['chainStateLinks'] = {}
      dataDict['chemShiftConstraints'] = set()
      dataDict['csaConstraints'] = set()
      dataDict['dihedralConstraints'] = set()
      dataDict['pairwiseConstraintItems'] = set()
      dataDict['resCoords'] = set()
      dataDict['resonanceSet'] = None

      dataDict['inConstructor'] = True
      try:
        
        for key, value in attrlinks.iteritems():
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        del dataDict['inConstructor']
      except:
        print "ERROR in ccp.nmr.NmrConstraint.FixedResonance.__init__"
        del dataDict['inConstructor']
        raise

      if (notOverride):
        if (dataDict.get('serial') is None):
          dataDict['inConstructor'] = True
          self.setSerial(-1)
          del dataDict['inConstructor']
        else:
          raise ApiError("""%s.__init__:
           Cannot pass in explicit serial if not reading""" % self.qualifiedName
           + ": %s:%s" % (parent, 'ccp.nmr.NmrConstraint.FixedResonance')
          )

      if (notIsReading):
        childrenDict = parent.__dict__.get('fixedResonances')
        objKey = dataDict.get('serial')
        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['serial'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        print '''WARNING Error in clean-up of incorrectly created object. 
        Data may be left in an illegal state'''
        del dataDict['inConstructor']
      raise exc_info[0], exc_info[1], exc_info[2]

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccp.nmr.NmrConstraint.FixedResonance:
       determines 
    cascading deletes to follow from delete of object.
       *Implementation 
    function* - should be called only by API delete function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
      dataDict.get('topObject').load()

    access = dataDict.get('access')
    if (access is not None):
      topObject = access.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    chainStateLinks = dataDict.get('chainStateLinks').values()
    for chainStateLink in chainStateLinks:
      if (not (chainStateLink in objsToBeDeleted)):
        objsToBeDeleted.add(chainStateLink)
        objsToBeChecked.append(chainStateLink)

    chemShiftConstraints = dataDict.get('chemShiftConstraints')
    for chemShiftConstraint in chemShiftConstraints:
      if (not (chemShiftConstraint in objsToBeDeleted)):
        objsToBeDeleted.add(chemShiftConstraint)
        objsToBeChecked.append(chemShiftConstraint)

    csaConstraints = dataDict.get('csaConstraints')
    for csaConstraint in csaConstraints:
      if (not (csaConstraint in objsToBeDeleted)):
        objsToBeDeleted.add(csaConstraint)
        objsToBeChecked.append(csaConstraint)

    dihedralConstraints = dataDict.get('dihedralConstraints')
    for dihedralConstraint in dihedralConstraints:
      if (not (dihedralConstraint in objsToBeDeleted)):
        objsToBeDeleted.add(dihedralConstraint)
        objsToBeChecked.append(dihedralConstraint)

    pairwiseConstraintItems = dataDict.get('pairwiseConstraintItems')
    for pairwiseConstraintItem in pairwiseConstraintItems:
      if (not (pairwiseConstraintItem in objsToBeDeleted)):
        objsToBeDeleted.add(pairwiseConstraintItem)
        objsToBeChecked.append(pairwiseConstraintItem)

    resCoords = dataDict.get('resCoords')
    for resCoord in resCoords:
      if (not (resCoord in objsToBeDeleted)):
        objsToBeDeleted.add(resCoord)
        objsToBeChecked.append(resCoord)

    resonanceSet = dataDict.get('resonanceSet')
    if (resonanceSet is not None):
      if (not (resonanceSet in objsToBeDeleted)):
        backlink = resonanceSet.__dict__.get('resonances')
        key = (resonanceSet, 'resonances')
        nFound = linkCounter.get(key)
        if (nFound is None):
          nFound = 1
        else:
          nFound = nFound + 1
          del linkCounter[key]

        if (len(backlink) - nFound < 1):
          objsToBeDeleted.add(resonanceSet)
          objsToBeChecked.append(resonanceSet)
        else:
          linkCounter[key] = nFound

    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccp.nmr.NmrConstraint.FixedResonance:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    access = dataDict.get('access')
    if ((access is not None and not (access in objsToBeDeleted))):
      dataObjects = access.__dict__.get('dataObjects')
      dataObjects.remove(self)

    resonanceSet = dataDict.get('resonanceSet')
    if ((resonanceSet is not None and not (resonanceSet in objsToBeDeleted))):
      resonances = resonanceSet.__dict__.get('resonances')
      resonances.remove(self)

    nmrConstraintStore = dataDict.get('nmrConstraintStore')
    if (not (nmrConstraintStore in objsToBeDeleted)):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = nmrConstraintStore.__dict__.get('fixedResonances')
        if (self is dd.get(objKey)):
          del dd[objKey]

  addApplicationData = memops.api.Implementation.DataObject.addApplicationData
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccp.nmr.NmrConstraint.FixedResonance
    """
    dataDict = self.__dict__
    self.checkValid(complete)
    values = dataDict.get('chainStateLinks').values()
    for value in values:
      value.checkAllValid(complete)

  def checkValid(self, complete=False):
    """
    CheckValid for ccp.nmr.NmrConstraint.FixedResonance
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('nmrConstraintStore')
        dd = value.__dict__.get('fixedResonances')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'nmrConstraintStore' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from memops.api.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('details')
      if (value is not None):
        if (isinstance(value, memops.api.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: details:
           memops.Implementation.Text input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 254):
          raise ApiError("""%s.checkValid: details:
           memops.Implementation.Text maximum length is 254 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: details:
           memops.Implementation.Text: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('isotopeCode')
      if (isinstance(value, memops.api.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: isotopeCode:
         memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 32):
        raise ApiError("""%s.checkValid: isotopeCode:
         memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: isotopeCode:
         memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.split()) == 1)):
        raise ApiError("""%s.checkValid: isotopeCode:
         Word constraint contains_no_white_space violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('name')
      if (value is not None):
        if (isinstance(value, memops.api.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: name:
           memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 32):
          raise ApiError("""%s.checkValid: name:
           memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: name:
           memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.split()) == 1)):
          raise ApiError("""%s.checkValid: name:
           Word constraint contains_no_white_space violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, memops.api.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('resonanceSerial')
      if (value is not None):
        if (isinstance(value, memops.api.Implementation.Int.PythonType)):
          pass
        elif ([x for x in memops.api.Implementation.Int.compatibleTypes if isinstance(value, x)]):
          value = memops.api.Implementation.Int.create(value)
        else:
          raise ApiError("""%s.checkValid: resonanceSerial:
           memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('serial')
      if (value is None):
        raise ApiError("""%s.checkValid: serial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, memops.api.Implementation.Int.PythonType)):
        pass
      elif ([x for x in memops.api.Implementation.Int.compatibleTypes if isinstance(value, x)]):
        value = memops.api.Implementation.Int.create(value)
      else:
        raise ApiError("""%s.checkValid: serial:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('access')
      if (value is not None):
        from memops.api.AccessControl import AccessObject as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: access:
           value is not of class memops.AccessControl.AccessObject""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('dataObjects')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: access:
           non-reciprocal link FixedResonance from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('chainStateLinks').values()
      for value in values:
        if (not isinstance(value, ChainStateLink)):
          raise ApiError("""%s.checkValid: chainStateLinks:
           value is not of class ccp.nmr.NmrConstraint.ChainStateLink""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('fixedResonance')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: chainStateLinks:
           non-reciprocal link FixedResonance from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('chemShiftConstraints')
      for value in values:
        if (not isinstance(value, ChemShiftConstraint)):
          raise ApiError("""%s.checkValid: chemShiftConstraints:
           value is not of class ccp.nmr.NmrConstraint.ChemShiftConstraint""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('resonance')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: chemShiftConstraints:
           non-reciprocal link FixedResonance from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: chemShiftConstraints:
           Link chemShiftConstraints between objects from separate partitions
           - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = dataDict.get('csaConstraints')
      for value in values:
        if (not isinstance(value, CsaConstraint)):
          raise ApiError("""%s.checkValid: csaConstraints:
           value is not of class ccp.nmr.NmrConstraint.CsaConstraint""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('resonance')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: csaConstraints:
           non-reciprocal link FixedResonance from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: csaConstraints:
           Link csaConstraints between objects from separate partitions
           - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = dataDict.get('dihedralConstraints')
      for value in values:
        if (not isinstance(value, DihedralConstraint)):
          raise ApiError("""%s.checkValid: dihedralConstraints:
           value is not of class ccp.nmr.NmrConstraint.DihedralConstraint""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('resonances')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: dihedralConstraints:
           non-reciprocal link FixedResonance from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: dihedralConstraints:
           Link dihedralConstraints between objects from separate partitions
           - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      value = self.getIsotope()
      if (value is not None):
        from ccp.api.molecule.ChemElement import Isotope as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: isotope:
           value is not of class ccp.molecule.ChemElement.Isotope""" % self.qualifiedName
           + ": %s" % (value,)
          )

        xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: isotope:
           Link isotope between objects from separate partitions
           - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      value = dataDict.get('nmrConstraintStore')
      if (not isinstance(value, NmrConstraintStore)):
        raise ApiError("""%s.checkValid: nmrConstraintStore:
         value is not of class ccp.nmr.NmrConstraint.NmrConstraintStore""" % self.qualifiedName
         + ": %s" % (value,)
        )

      values = dataDict.get('pairwiseConstraintItems')
      for value in values:
        if (not isinstance(value, PairwiseConstraintItem)):
          raise ApiError("""%s.checkValid: pairwiseConstraintItems:
           value is not of class ccp.nmr.NmrConstraint.PairwiseConstraintItem""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('resonances')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: pairwiseConstraintItems:
           non-reciprocal link FixedResonance from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: pairwiseConstraintItems:
           Link pairwiseConstraintItems between objects from separate partitions
           - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = dataDict.get('resCoords')
      for value in values:
        if (not isinstance(value, ResCoord)):
          raise ApiError("""%s.checkValid: resCoords:
           value is not of class ccp.nmr.NmrConstraint.ResCoord""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('resonance')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: resCoords:
           non-reciprocal link FixedResonance from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: resCoords:
           Link resCoords between objects from separate partitions
           - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      value = self.getResonance()
      if (value is not None):
        from ccp.api.nmr.Nmr import Resonance as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: resonance:
           value is not of class ccp.nmr.Nmr.Resonance""" % self.qualifiedName
           + ": %s" % (value,)
          )

        xx1 = dataDict.get('topObject')
        xx2 = xx1.__dict__.get('nmrProject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx2 is yy1)):
          raise ApiError("""%s.checkValid: resonance:
           Link resonance between objects from separate partitions
           - ccp.nmr.NmrConstraint.NmrConstraintStore.nmrProject not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      value = dataDict.get('resonanceSet')
      if (value is not None):
        if (not isinstance(value, FixedResonanceSet)):
          raise ApiError("""%s.checkValid: resonanceSet:
           value is not of class ccp.nmr.NmrConstraint.FixedResonanceSet""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('resonances')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: resonanceSet:
           non-reciprocal link FixedResonance from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

    # check explicit class constraints
    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('details')
    value = dataDict.get('isotopeCode')
    if (value is None):
      raise ApiError("""%s.checkValid: isotopeCode:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    value = dataDict.get('name')
    value = dataDict.get('resonanceSerial')
    # check roles
    value = dataDict.get('access')
    values = dataDict.get('chainStateLinks').values()
    values = dataDict.get('chemShiftConstraints')
    for value in values:
      (self, value) = (value, self)
      if (not (value.isotopeCode == self.parentList.isotopeCode)):
        raise ApiError("""%s.checkValid: chemShiftConstraints:
         resonance constraint value_isotopeCode_eq_self_parentList_isotopeCode violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      (value, self) = (self, value)

    values = dataDict.get('csaConstraints')
    values = dataDict.get('dihedralConstraints')
    value = dataDict.get('nmrConstraintStore')
    if (value is None):
      raise ApiError("""%s.checkValid: nmrConstraintStore:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    values = dataDict.get('pairwiseConstraintItems')
    values = dataDict.get('resCoords')
    value = dataDict.get('resonanceSet')

  delete = memops.api.Implementation.DataObject.delete

  findAllApplicationData = memops.api.Implementation.DataObject.findAllApplicationData
  
  def findAllChainStateLinks(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.FixedResonance.chainStateLinks
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('chainStateLinks').values()
      result = set(currentValues)

    else:
      currentValues = dataDict.get('chainStateLinks').values()
      result = set()
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('chainStateSerial', 'chainStateSetSerial', 'access', 'fixedResonance',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result.add(v)

    return result
  
  def findAllChemShiftConstraints(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.FixedResonance.chemShiftConstraints
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('chemShiftConstraints')
      result = set(currentValues)

    else:
      currentValues = dataDict.get('chemShiftConstraints')
      result = set()
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('details', 'error', 'lowerLimit', 'origData', 'serial', 'targetValue', 'upperLimit', 'weight', 'access', 'method', 'parentList', 'resonance',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result.add(v)

    return result
  
  def findAllCsaConstraints(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.FixedResonance.csaConstraints
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('csaConstraints')
      result = set(currentValues)

    else:
      currentValues = dataDict.get('csaConstraints')
      result = set()
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('details', 'error', 'lowerLimit', 'origData', 'serial', 'targetValue', 'upperLimit', 'weight', 'access', 'method', 'parentList', 'resonance',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result.add(v)

    return result
  
  def findAllDihedralConstraints(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.FixedResonance.dihedralConstraints
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('dihedralConstraints')
      result = set(currentValues)

    else:
      currentValues = dataDict.get('dihedralConstraints')
      result = set()
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('details', 'origData', 'serial', 'weight', 'access', 'method', 'parentList',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result.add(v)

    return result
  
  def findAllPairwiseConstraintItems(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.FixedResonance.pairwiseConstraintItems
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('pairwiseConstraintItems')
      result = set(currentValues)

    else:
      currentValues = dataDict.get('pairwiseConstraintItems')
      result = set()
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('access', 'firstResonance',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result.add(v)

    return result
  
  def findAllResCoords(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.FixedResonance.resCoords
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('resCoords')
      result = set(currentValues)

    else:
      currentValues = dataDict.get('resCoords')
      result = set()
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('x', 'y', 'z', 'access', 'resonance', 'structure',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result.add(v)

    return result

  findFirstApplicationData = memops.api.Implementation.DataObject.findFirstApplicationData
  
  def findFirstChainStateLink(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.FixedResonance.chainStateLinks
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('chainStateLinks').values()
      if (currentValues):
        result = iter(currentValues).next()
      else:
        result = None

    else:
      objKey = conditions.get('chainStateSetSerial')
      if (objKey is not None):
        result = dataDict.get('chainStateLinks').get(objKey)

        if (result is None):
          return result

        elif (len(conditions) <= 1):
          return result

        else:
          currentValues = set()
          currentValues.add(result)

      else:
        currentValues = dataDict.get('chainStateLinks').values()

      result = None
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('chainStateSerial', 'chainStateSetSerial', 'access', 'fixedResonance',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result = v; break

    return result
  
  def findFirstChemShiftConstraint(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.FixedResonance.chemShiftConstraints
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('chemShiftConstraints')
      if (currentValues):
        result = iter(currentValues).next()
      else:
        result = None

    else:
      currentValues = dataDict.get('chemShiftConstraints')
      result = None
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('details', 'error', 'lowerLimit', 'origData', 'serial', 'targetValue', 'upperLimit', 'weight', 'access', 'method', 'parentList', 'resonance',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result = v; break

    return result
  
  def findFirstCsaConstraint(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.FixedResonance.csaConstraints
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('csaConstraints')
      if (currentValues):
        result = iter(currentValues).next()
      else:
        result = None

    else:
      currentValues = dataDict.get('csaConstraints')
      result = None
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('details', 'error', 'lowerLimit', 'origData', 'serial', 'targetValue', 'upperLimit', 'weight', 'access', 'method', 'parentList', 'resonance',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result = v; break

    return result
  
  def findFirstDihedralConstraint(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.FixedResonance.dihedralConstraints
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('dihedralConstraints')
      if (currentValues):
        result = iter(currentValues).next()
      else:
        result = None

    else:
      currentValues = dataDict.get('dihedralConstraints')
      result = None
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('details', 'origData', 'serial', 'weight', 'access', 'method', 'parentList',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result = v; break

    return result
  
  def findFirstPairwiseConstraintItem(self, **conditions):
    """
    FindFirst for
    ccp.nmr.NmrConstraint.FixedResonance.pairwiseConstraintItems
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('pairwiseConstraintItems')
      if (currentValues):
        result = iter(currentValues).next()
      else:
        result = None

    else:
      currentValues = dataDict.get('pairwiseConstraintItems')
      result = None
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('access', 'firstResonance',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result = v; break

    return result
  
  def findFirstResCoord(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.FixedResonance.resCoords
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('resCoords')
      if (currentValues):
        result = iter(currentValues).next()
      else:
        result = None

    else:
      currentValues = dataDict.get('resCoords')
      result = None
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('x', 'y', 'z', 'access', 'resonance', 'structure',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result = v; break

    return result
  
  def get(self, name):
    """
    GetAttr for ccp.nmr.NmrConstraint.FixedResonance
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getAccess = memops.api.Implementation.DataObject.getAccess

  getApplicationData = memops.api.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.FixedResonance
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (2 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.FixedResonance'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (1 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.FixedResonance'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-1]
      obj2 = obj1.__dict__.get('fixedResonances').get(objKey)
      result = obj2

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = memops.api.Implementation.MemopsObject.getByNavigation
  
  def getChainStateLinks(self):
    """
    Get for ccp.nmr.NmrConstraint.FixedResonance.chainStateLinks
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('chainStateLinks').values()
    result = frozenset(tempVar)
    return result
  
  def getChemShiftConstraints(self):
    """
    Get for ccp.nmr.NmrConstraint.FixedResonance.chemShiftConstraints
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('chemShiftConstraints')
    result = frozenset(tempVar)
    return result

  getClassName = memops.api.Implementation.ComplexDataType.getClassName
  
  def getCsaConstraints(self):
    """
    Get for ccp.nmr.NmrConstraint.FixedResonance.csaConstraints
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('csaConstraints')
    result = frozenset(tempVar)
    return result
  
  def getDetails(self):
    """
    Get for ccp.nmr.NmrConstraint.FixedResonance.details
    """
    dataDict = self.__dict__
    result = dataDict.get('details')
    return result
  
  def getDihedralConstraints(self):
    """
    Get for ccp.nmr.NmrConstraint.FixedResonance.dihedralConstraints
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('dihedralConstraints')
    result = frozenset(tempVar)
    return result

  getExpandedKey = memops.api.Implementation.MemopsObject.getExpandedKey

  getFieldNames = memops.api.Implementation.ComplexDataType.getFieldNames
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccp.nmr.NmrConstraint.FixedResonance
    """
    dataDict = self.__dict__
    result = list()

    obj1 = dataDict.get('nmrConstraintStore')

    if (useGuid):
      result.append(obj1.__dict__.get('guid'))
    else:
      result.append(obj1.__dict__.get('serial'))

    result.append(dataDict.get('serial'))

    return result

  getInConstructor = memops.api.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = memops.api.Implementation.MemopsObject.getIsDeleted
  
  def getIsotope(self):
    """
    getter for derived link Isotope
    """
    dataDict = self.__dict__
    ss = self.isotopeCode
    if ss == 'unknown':
      return None
    if ss[-2] in '0123456789':
      firstLetter = -1
    else:
      firstLetter = -2
    atomSymbol = ss[firstLetter:].capitalize()
    massNumber = int(ss[:firstLetter])
    
    result = ccp.api.molecule.ChemElement.Isotope.getByKey(self.root.currentChemElementStore,(atomSymbol, massNumber))
    return result
  
  def getIsotopeCode(self):
    """
    Get for ccp.nmr.NmrConstraint.FixedResonance.isotopeCode
    """
    dataDict = self.__dict__
    result = dataDict.get('isotopeCode')
    return result
  
  def getLocalKey(self):
    """
    GetLocalKey for ccp.nmr.NmrConstraint.FixedResonance
    """
    dataDict = self.__dict__
    result = dataDict.get('serial')
    return result

  getMetaclass = memops.api.Implementation.ComplexDataType.getMetaclass
  
  def getName(self):
    """
    Get for ccp.nmr.NmrConstraint.FixedResonance.name
    """
    dataDict = self.__dict__
    result = dataDict.get('name')
    return result
  
  def getNmrConstraintStore(self):
    """
    Get for ccp.nmr.NmrConstraint.FixedResonance.nmrConstraintStore
    """
    dataDict = self.__dict__
    result = dataDict.get('nmrConstraintStore')
    return result

  getPackageName = memops.api.Implementation.ComplexDataType.getPackageName

  getPackageShortName = memops.api.Implementation.ComplexDataType.getPackageShortName
  
  def getPairwiseConstraintItems(self):
    """
    Get for ccp.nmr.NmrConstraint.FixedResonance.pairwiseConstraintItems
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('pairwiseConstraintItems')
    result = frozenset(tempVar)
    return result
  
  def getParent(self):
    """
    Get for ccp.nmr.NmrConstraint.FixedResonance.parent
    """
    dataDict = self.__dict__
    result = dataDict.get('nmrConstraintStore')
    return result

  getQualifiedName = memops.api.Implementation.ComplexDataType.getQualifiedName
  
  def getResCoords(self):
    """
    Get for ccp.nmr.NmrConstraint.FixedResonance.resCoords
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('resCoords')
    result = frozenset(tempVar)
    return result
  
  def getResonance(self):
    """
    getter for derived link resonance
    """
    dataDict = self.__dict__
    result = self.getByNavigation('nmrConstraintStore', 'nmrProject', ('resonances',self.resonanceSerial),)
    return result
  
  def getResonanceSerial(self):
    """
    Get for ccp.nmr.NmrConstraint.FixedResonance.resonanceSerial
    """
    dataDict = self.__dict__
    result = dataDict.get('resonanceSerial')
    return result
  
  def getResonanceSet(self):
    """
    Get for ccp.nmr.NmrConstraint.FixedResonance.resonanceSet
    """
    dataDict = self.__dict__
    result = dataDict.get('resonanceSet')
    return result

  getRoot = memops.api.Implementation.MemopsObject.getRoot
  
  def getSerial(self):
    """
    Get for ccp.nmr.NmrConstraint.FixedResonance.serial
    """
    dataDict = self.__dict__
    result = dataDict.get('serial')
    return result

  getTopObject = memops.api.Implementation.DataObject.getTopObject
  
  def newChainStateLink(self, **attrlinks):
    """
    Factory function to create ccp.nmr.NmrConstraint.ChainStateLink
    """
    return ChainStateLink(self, **attrlinks)

  removeApplicationData = memops.api.Implementation.DataObject.removeApplicationData
  
  def set(self, name, value):
    """
    SetAttr for ccp.nmr.NmrConstraint.FixedResonance
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setAccess = memops.api.Implementation.DataObject.setAccess

  setApplicationData = memops.api.Implementation.DataObject.setApplicationData
  
  def setChemShiftConstraints(self, values):
    """
    Set for ccp.nmr.NmrConstraint.FixedResonance.chemShiftConstraints
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setChemShiftConstraints:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      if (not isinstance(value, ChemShiftConstraint)):
        raise ApiError("""%s.setChemShiftConstraints:
         value is not of class ccp.nmr.NmrConstraint.ChemShiftConstraint""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('chemShiftConstraints')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setChemShiftConstraints:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setChemShiftConstraints:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setChemShiftConstraints:
         an object in values is deleted""" % self.qualifiedName
        )

    if (values == currentValues):
      return

    if (notOverride):
      for cv in currentValues:
        if (not (cv in values)):
          raise ApiError("""%s.setChemShiftConstraints:
           locard resonance: cannot set because some of current values not in values""" % self.qualifiedName
           + ": %s" % (self,)
          )

      xx1 = dataDict.get('topObject')
      for value in values:
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setChemShiftConstraints:
           Link chemShiftConstraints between objects from separate partitions
           - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      if (notInConstructor):
        for value in values:
          (self, value) = (value, self)
          if (not (value.isotopeCode == self.parentList.isotopeCode)):
            raise ApiError("""%s.setChemShiftConstraints:
             resonance constraint value_isotopeCode_eq_self_parentList_isotopeCode violated by value""" % self.qualifiedName
             + ": %s" % (value,)
            )

          (value, self) = (self, value)

    for cv in values:
      cv.__dict__['resonance'] = self

    dataDict['chemShiftConstraints'] = values
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setChemShiftConstraints')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  def setCsaConstraints(self, values):
    """
    Set for ccp.nmr.NmrConstraint.FixedResonance.csaConstraints
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setCsaConstraints:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      if (not isinstance(value, CsaConstraint)):
        raise ApiError("""%s.setCsaConstraints:
         value is not of class ccp.nmr.NmrConstraint.CsaConstraint""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('csaConstraints')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setCsaConstraints:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setCsaConstraints:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setCsaConstraints:
         an object in values is deleted""" % self.qualifiedName
        )

    if (values == currentValues):
      return

    if (notOverride):
      for cv in currentValues:
        if (not (cv in values)):
          raise ApiError("""%s.setCsaConstraints:
           locard resonance: cannot set because some of current values not in values""" % self.qualifiedName
           + ": %s" % (self,)
          )

      xx1 = dataDict.get('topObject')
      for value in values:
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setCsaConstraints:
           Link csaConstraints between objects from separate partitions
           - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    for cv in values:
      cv.__dict__['resonance'] = self

    dataDict['csaConstraints'] = values
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setCsaConstraints')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  def setDetails(self, value):
    """
    Set for ccp.nmr.NmrConstraint.FixedResonance.details
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, memops.api.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.setDetails:
         memops.Implementation.Text input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 254):
        raise ApiError("""%s.setDetails:
         memops.Implementation.Text maximum length is 254 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.setDetails:
         memops.Implementation.Text: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('details')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setDetails:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setDetails:
       called on deleted object""" % self.qualifiedName
      )

    if (value == currentValue):
      return

    if (notOverride):
      pass

    dataDict['details'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setDetails')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  def setDihedralConstraints(self, values):
    """
    Set for ccp.nmr.NmrConstraint.FixedResonance.dihedralConstraints
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setDihedralConstraints:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      if (not isinstance(value, DihedralConstraint)):
        raise ApiError("""%s.setDihedralConstraints:
         value is not of class ccp.nmr.NmrConstraint.DihedralConstraint""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('dihedralConstraints')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setDihedralConstraints:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setDihedralConstraints:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setDihedralConstraints:
         an object in values is deleted""" % self.qualifiedName
        )

    if (values == currentValues):
      return

    if (notOverride):
      for cv in currentValues:
        if (not (cv in values)):
          oldSelves = cv.__dict__.get('resonances')
          if (len(oldSelves) < (4 + 1)):
            raise ApiError("""%s.setDihedralConstraints:
             locard: oldSelves: cannot remove value""" % self.qualifiedName
             + ": %s" % (self,)
            )

      for cv in values:
        if (not (cv in currentValues)):
          oldSelves = cv.__dict__.get('resonances')
          if (len(oldSelves) >= 4):
            raise ApiError("""%s.setDihedralConstraints:
             hicard: oldSelves: cannot add value""" % self.qualifiedName
             + ": %s" % (self,)
            )

      xx1 = dataDict.get('topObject')
      for value in values:
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setDihedralConstraints:
           Link dihedralConstraints between objects from separate partitions
           - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    for cv in currentValues:
      if (not (cv in values)):
        oldSelves = cv.__dict__.get('resonances')
        oldSelves.remove(self)

    for cv in values:
      if (not (cv in currentValues)):
        oldSelves = cv.__dict__.get('resonances')
        oldSelves.append(self)

    dataDict['dihedralConstraints'] = values
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setDihedralConstraints')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  def setIsotopeCode(self, value):
    """
    Set for ccp.nmr.NmrConstraint.FixedResonance.isotopeCode
    """
    dataDict = self.__dict__
    if (isinstance(value, memops.api.Implementation.String.PythonType)):
      pass
    else:
      raise ApiError("""%s.setIsotopeCode:
       memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    _lenValue = len(value)
    if (_lenValue > 32):
      raise ApiError("""%s.setIsotopeCode:
       memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (_lenValue < 1):
      raise ApiError("""%s.setIsotopeCode:
       memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (len(value.split()) == 1)):
      raise ApiError("""%s.setIsotopeCode:
       Word constraint contains_no_white_space violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('isotopeCode')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setIsotopeCode:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setIsotopeCode:
       called on deleted object""" % self.qualifiedName
      )

    if (value == currentValue):
      return

    if (notOverride):
      if (value is None):
        raise ApiError("""%s.setIsotopeCode:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    dataDict['isotopeCode'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setIsotopeCode')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  def setName(self, value):
    """
    Set for ccp.nmr.NmrConstraint.FixedResonance.name
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, memops.api.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.setName:
         memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 32):
        raise ApiError("""%s.setName:
         memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.setName:
         memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.split()) == 1)):
        raise ApiError("""%s.setName:
         Word constraint contains_no_white_space violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('name')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setName:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setName:
       called on deleted object""" % self.qualifiedName
      )

    if (value == currentValue):
      return

    if (notOverride):
      pass

    dataDict['name'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setName')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  def setPairwiseConstraintItems(self, values):
    """
    Set for ccp.nmr.NmrConstraint.FixedResonance.pairwiseConstraintItems
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setPairwiseConstraintItems:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      if (not isinstance(value, PairwiseConstraintItem)):
        raise ApiError("""%s.setPairwiseConstraintItems:
         value is not of class ccp.nmr.NmrConstraint.PairwiseConstraintItem""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('pairwiseConstraintItems')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setPairwiseConstraintItems:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setPairwiseConstraintItems:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setPairwiseConstraintItems:
         an object in values is deleted""" % self.qualifiedName
        )

    if (values == currentValues):
      return

    if (notOverride):
      for cv in currentValues:
        if (not (cv in values)):
          oldSelves = cv.__dict__.get('resonances')
          if (len(oldSelves) < (2 + 1)):
            raise ApiError("""%s.setPairwiseConstraintItems:
             locard: oldSelves: cannot remove value""" % self.qualifiedName
             + ": %s" % (self,)
            )

      for cv in values:
        if (not (cv in currentValues)):
          oldSelves = cv.__dict__.get('resonances')
          if (len(oldSelves) >= 2):
            raise ApiError("""%s.setPairwiseConstraintItems:
             hicard: oldSelves: cannot add value""" % self.qualifiedName
             + ": %s" % (self,)
            )

      xx1 = dataDict.get('topObject')
      for value in values:
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setPairwiseConstraintItems:
           Link pairwiseConstraintItems between objects from separate partitions
           - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    for cv in currentValues:
      if (not (cv in values)):
        oldSelves = cv.__dict__.get('resonances')
        oldSelves.remove(self)

    for cv in values:
      if (not (cv in currentValues)):
        oldSelves = cv.__dict__.get('resonances')
        oldSelves.add(self)

    dataDict['pairwiseConstraintItems'] = values
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setPairwiseConstraintItems')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  def setResCoords(self, values):
    """
    Set for ccp.nmr.NmrConstraint.FixedResonance.resCoords
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setResCoords:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      if (not isinstance(value, ResCoord)):
        raise ApiError("""%s.setResCoords:
         value is not of class ccp.nmr.NmrConstraint.ResCoord""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('resCoords')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setResCoords:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setResCoords:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setResCoords:
         an object in values is deleted""" % self.qualifiedName
        )

    if (values == currentValues):
      return

    if (notOverride):
      for cv in currentValues:
        if (not (cv in values)):
          raise ApiError("""%s.setResCoords:
           locard resonance: cannot set because some of current values not in values""" % self.qualifiedName
           + ": %s" % (self,)
          )

      xx1 = dataDict.get('topObject')
      for value in values:
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setResCoords:
           Link resCoords between objects from separate partitions
           - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    for cv in values:
      cv.__dict__['resonance'] = self

    dataDict['resCoords'] = values
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setResCoords')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  def setResonanceSerial(self, value):
    """
    Set for ccp.nmr.NmrConstraint.FixedResonance.resonanceSerial
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, memops.api.Implementation.Int.PythonType)):
        pass
      elif ([x for x in memops.api.Implementation.Int.compatibleTypes if isinstance(value, x)]):
        value = memops.api.Implementation.Int.create(value)
      else:
        raise ApiError("""%s.setResonanceSerial:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('resonanceSerial')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setResonanceSerial:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setResonanceSerial:
       called on deleted object""" % self.qualifiedName
      )

    if (value == currentValue):
      return

    if (notOverride):
      pass

    dataDict['resonanceSerial'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setResonanceSerial')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  def setResonanceSet(self, value):
    """
    Set for ccp.nmr.NmrConstraint.FixedResonance.resonanceSet
    """
    dataDict = self.__dict__
    if (value is not None):
      if (not isinstance(value, FixedResonanceSet)):
        raise ApiError("""%s.setResonanceSet:
         value is not of class ccp.nmr.NmrConstraint.FixedResonanceSet""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('resonanceSet')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setResonanceSet:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setResonanceSet:
       called on deleted object""" % self.qualifiedName
      )

    if (value is not None):
      if (value.__dict__.get('isDeleted')):
        raise ApiError("""%s.setResonanceSet:
         called with deleted value""" % self.qualifiedName
        )

    if (value == currentValue):
      return

    if (notOverride):
      if (currentValue is not None):
        oldSelves = currentValue.__dict__.get('resonances')
        if (len(oldSelves) < (1 + 1)):
          raise ApiError("""%s.setResonanceSet:
           locard: oldSelves: cannot remove value""" % self.qualifiedName
           + ": %s" % (self,)
          )

      if (value is not None):
        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setResonanceSet:
           Link resonanceSet between objects from separate partitions
           - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    if (currentValue is not None):
      if (notIsReading):
        oldSelves = currentValue.__dict__.get('resonances')
        oldSelves.remove(self)
      else:
        raise ApiError("""%s.setResonanceSet:
         Read link 'resonanceSet' incompatible with pre-existing link""" % self.qualifiedName
         + ": %s" % (self,)
        )

    if (value is not None):
      newSelves = value.__dict__.get('resonances')
      newSelves.add(self)

    dataDict['resonanceSet'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setResonanceSet')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  def setSerial(self, value):
    """
    Set for ccp.nmr.NmrConstraint.FixedResonance.serial
    """
    dataDict = self.__dict__
    if (isinstance(value, memops.api.Implementation.Int.PythonType)):
      pass
    elif ([x for x in memops.api.Implementation.Int.compatibleTypes if isinstance(value, x)]):
      value = memops.api.Implementation.Int.create(value)
    else:
      raise ApiError("""%s.setSerial:
       memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('serial')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setSerial:
       called on deleted object""" % self.qualifiedName
      )

    if (value == currentValue):
      return

    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setSerial:
         cannot set serial, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is None):
        raise ApiError("""%s.setSerial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    parent = dataDict.get('nmrConstraintStore')
    oldSerial = parent.__dict__.get('_serialDict').get('fixedResonances')
    if (value < 0):
      value = (oldSerial + 1)
      parent.__dict__.get('_serialDict')['fixedResonances'] = value
    elif (value > oldSerial):
      parent.__dict__.get('_serialDict')['fixedResonances'] = value

    dataDict['serial'] = value

    # doNotifies
  
  def sortedChainStateLinks(self):
    """
    Sorted for ccp.nmr.NmrConstraint.FixedResonance.chainStateLinks
    """
    dataDict = self.__dict__
    sortdd = dataDict.get('chainStateLinks')
    
    ll = sortdd.keys()
    ll.sort()
    result = [sortdd[x] for x in ll]
    return result
  
  def sortedChemShiftConstraints(self):
    """
    Sorted for ccp.nmr.NmrConstraint.FixedResonance.chemShiftConstraints
    """
    dataDict = self.__dict__
    ll = dataDict.get('chemShiftConstraints')
    ll = [(x.getFullKey(),x) for x in ll]
    
    ll.sort()
    result = [x[1] for x in ll]
    return result
  
  def sortedCsaConstraints(self):
    """
    Sorted for ccp.nmr.NmrConstraint.FixedResonance.csaConstraints
    """
    dataDict = self.__dict__
    ll = dataDict.get('csaConstraints')
    ll = [(x.getFullKey(),x) for x in ll]
    
    ll.sort()
    result = [x[1] for x in ll]
    return result
  
  def sortedDihedralConstraints(self):
    """
    Sorted for ccp.nmr.NmrConstraint.FixedResonance.dihedralConstraints
    """
    dataDict = self.__dict__
    ll = dataDict.get('dihedralConstraints')
    ll = [(x.getFullKey(),x) for x in ll]
    
    ll.sort()
    result = [x[1] for x in ll]
    return result
  
  def sortedPairwiseConstraintItems(self):
    """
    Sorted for ccp.nmr.NmrConstraint.FixedResonance.pairwiseConstraintItems
    """
    dataDict = self.__dict__
    ll = dataDict.get('pairwiseConstraintItems')
    ll = [(repr(x),x) for x in ll]
    
    ll.sort()
    result = [x[1] for x in ll]
    return result
  
  def sortedResCoords(self):
    """
    Sorted for ccp.nmr.NmrConstraint.FixedResonance.resCoords
    """
    dataDict = self.__dict__
    ll = dataDict.get('resCoords')
    ll = [(x.getFullKey(),x) for x in ll]
    
    ll.sort()
    result = [x[1] for x in ll]
    return result

  toDetailedString = memops.api.Implementation.ComplexDataType.toDetailedString

  applicationData = memops.api.Implementation.DataObject.applicationData

  className = memops.api.Implementation.ComplexDataType.className
  
  details = property(getDetails, setDetails, None,
  r"""Free text, for notes, explanatory comments, etc.
  """)

  fieldNames = memops.api.Implementation.ComplexDataType.fieldNames

  inConstructor = memops.api.Implementation.ComplexDataType.inConstructor

  isDeleted = memops.api.Implementation.MemopsObject.isDeleted
  
  isotopeCode = property(getIsotopeCode, setIsotopeCode, None,
  r"""Isotope code of corresponding isotope. E.g. 1H, 2H, 3He, 13C, ..
  """)

  metaclass = memops.api.Implementation.ComplexDataType.metaclass
  
  name = property(getName, setName, None,
  r"""Name of Resonance
  """)

  packageName = memops.api.Implementation.ComplexDataType.packageName

  packageShortName = memops.api.Implementation.ComplexDataType.packageShortName

  qualifiedName = memops.api.Implementation.ComplexDataType.qualifiedName
  
  resonanceSerial = property(getResonanceSerial, setResonanceSerial, None,
  r"""Serial of corresponding Nmr.Resonance
  """)
  
  serial = property(getSerial, setSerial, None,
  r"""Serial number of object. Serves as object main key. Serial numbers of 
  deleted objects are not re-used. Serial numbers can only be set by the 
  implementation. Values are in practice always positive, since negative 
  values are interpreted as a signal to set the next free serial
  """)

  access = memops.api.Implementation.DataObject.access
  
  chainStateLinks = property(getChainStateLinks,  None, None,
  r"""child link to class ChainStateLink
  """)
  
  chemShiftConstraints = property(getChemShiftConstraints, setChemShiftConstraints, None,
  r"""Chemical shift constraints involving FIxedResonance
  """)
  
  csaConstraints = property(getCsaConstraints, setCsaConstraints, None,
  r"""
  """)
  
  dihedralConstraints = property(getDihedralConstraints, setDihedralConstraints, None,
  r"""Dihedral angle constraints involving FixedResonance.
  """)
  
  isotope = property(getIsotope, None, None,
  r"""Isotope corresponding to FixedResonance
  """)
  
  nmrConstraintStore = property(getNmrConstraintStore,  None, None,
  r"""parent link
  """)
  
  pairwiseConstraintItems = property(getPairwiseConstraintItems, setPairwiseConstraintItems, None,
  r"""PairWiseConstraintItems that involve FixedResonance
  """)
  
  parent = property(getParent, None, None,
  r"""link to parent object - synonym for nmrConstraintStore
  """)
  
  resCoords = property(getResCoords, setResCoords, None,
  r"""Coordinate records (ResCoords) from resonance-only structures relevant 
  for FixedResonance
  """)
  
  resonance = property(getResonance, None, None,
  r"""Resonance corresponding to FixedResonance, and from which it was 
  created.
  """)
  
  resonanceSet = property(getResonanceSet, setResonanceSet, None,
  r"""FixedResonanceSet (part of assignment for Constraint Lists) involving 
  Resonance.
  """)

  root = memops.api.Implementation.MemopsObject.root

  topObject = memops.api.Implementation.DataObject.topObject

###############################################################################
class FixedResonanceSet(memops.api.Implementation.DataObject):
  r"""Fixed version of ResonanceSet. When a Structure Generation run is 
started, AtomSets and ResonanceSets are copied to FixedAtomSets and 
FixedResonanceSets in order to preserve the Resonance-Atom assignment 
valid for a StructureGeneration and the associated ConstraintLists.
  """
  #   from data model element ccp.nmr.NmrConstraint.FixedResonanceSet revision 1.37.2.9
  _metaclass = metaPackage.getElement('FixedResonanceSet')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('applicationData', 'className', 'fieldNames', 'inConstructor', 'isDeleted', 'metaclass', 'packageName', 'packageShortName', 'qualifiedName', 'serial', 'access', 'atomSets', 'nmrConstraintStore', 'parent', 'resonances', 'root', 'topObject',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccp.nmr.NmrConstraint.FixedResonanceSet
    """
    dataDict = self.__dict__
    dataDict['nmrConstraintStore'] = parent
    if (not isinstance(parent, NmrConstraintStore)):
      raise ApiError("""%s.__init__:
       value is not of class ccp.nmr.NmrConstraint.NmrConstraintStore""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:
      if (not ((parent.__dict__.get('isLoaded') or parent.__dict__.get('isReading')))):
        parent.load()

      dataDict['applicationData'] = list()
      dataDict['serial'] = None
      dataDict['access'] = None
      dataDict['atomSets'] = set()
      dataDict['resonances'] = set()

      dataDict['inConstructor'] = True
      try:
        
        for key, value in attrlinks.iteritems():
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        del dataDict['inConstructor']
      except:
        print "ERROR in ccp.nmr.NmrConstraint.FixedResonanceSet.__init__"
        del dataDict['inConstructor']
        raise

      if (notOverride):
        if (dataDict.get('serial') is None):
          dataDict['inConstructor'] = True
          self.setSerial(-1)
          del dataDict['inConstructor']
        else:
          raise ApiError("""%s.__init__:
           Cannot pass in explicit serial if not reading""" % self.qualifiedName
           + ": %s:%s" % (parent, 'ccp.nmr.NmrConstraint.FixedResonanceSet')
          )

      if (notIsReading):
        childrenDict = parent.__dict__.get('fixedResonanceSets')
        objKey = dataDict.get('serial')
        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['serial'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        print '''WARNING Error in clean-up of incorrectly created object. 
        Data may be left in an illegal state'''
        del dataDict['inConstructor']
      raise exc_info[0], exc_info[1], exc_info[2]

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccp.nmr.NmrConstraint.FixedResonanceSet:
       determines 
    cascading deletes to follow from delete of object.
       *Implementation 
    function* - should be called only by API delete function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
      dataDict.get('topObject').load()

    access = dataDict.get('access')
    if (access is not None):
      topObject = access.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccp.nmr.NmrConstraint.FixedResonanceSet:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    access = dataDict.get('access')
    if ((access is not None and not (access in objsToBeDeleted))):
      dataObjects = access.__dict__.get('dataObjects')
      dataObjects.remove(self)

    for atomSet in dataDict.get('atomSets'):
      if (not (atomSet in objsToBeDeleted)):
        resonanceSets = atomSet.__dict__.get('resonanceSets')
        resonanceSets.remove(self)

    for resonance in dataDict.get('resonances'):
      if (not (resonance in objsToBeDeleted)):
        resonance.__dict__['resonanceSet'] = None

    nmrConstraintStore = dataDict.get('nmrConstraintStore')
    if (not (nmrConstraintStore in objsToBeDeleted)):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = nmrConstraintStore.__dict__.get('fixedResonanceSets')
        if (self is dd.get(objKey)):
          del dd[objKey]

  addApplicationData = memops.api.Implementation.DataObject.addApplicationData
  
  def addAtomSet(self, value):
    """
    Add for ccp.nmr.NmrConstraint.FixedResonanceSet.atomSets
    """
    dataDict = self.__dict__
    if (not isinstance(value, FixedAtomSet)):
      raise ApiError("""%s.addAtomSet:
       value is not of class ccp.nmr.NmrConstraint.FixedAtomSet""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('atomSets')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.addAtomSet:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.addAtomSet:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.addAtomSet:
       called with deleted value""" % self.qualifiedName
      )

    if (value in currentValues):
      raise ApiError("""%s.addAtomSet:
       value is in list already""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      if (value is not None):
        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.addAtomSet:
           Link atomSets between objects from separate partitions
           - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    oldSelves = value.__dict__.get('resonanceSets')
    oldSelves.add(self)
    currentValues.add(value)
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('addAtomSet')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  def addResonance(self, value):
    """
    Add for ccp.nmr.NmrConstraint.FixedResonanceSet.resonances
    """
    dataDict = self.__dict__
    if (not isinstance(value, FixedResonance)):
      raise ApiError("""%s.addResonance:
       value is not of class ccp.nmr.NmrConstraint.FixedResonance""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('resonances')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.addResonance:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.addResonance:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.addResonance:
       called with deleted value""" % self.qualifiedName
      )

    if (value in currentValues):
      raise ApiError("""%s.addResonance:
       value is in list already""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      oldSelf = value.__dict__.get('resonanceSet')
      if (oldSelf is not None):
        siblingValues = oldSelf.__dict__.get('resonances')
        if (len(siblingValues) < (1 + 1)):
          raise ApiError("""%s.addResonance:
           locard: siblingValues: cannot remove value""" % self.qualifiedName
           + ": %s" % (self,)
          )

      if (value is not None):
        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.addResonance:
           Link resonances between objects from separate partitions
           - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    oldSelf = value.__dict__.get('resonanceSet')
    if (oldSelf is not None):
      siblingValues = oldSelf.__dict__.get('resonances')
      siblingValues.remove(value)

    value.__dict__['resonanceSet'] = self
    currentValues.add(value)
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('addResonance')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccp.nmr.NmrConstraint.FixedResonanceSet
    """
    dataDict = self.__dict__
    self.checkValid(complete)
  
  def checkValid(self, complete=False):
    """
    CheckValid for ccp.nmr.NmrConstraint.FixedResonanceSet
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('nmrConstraintStore')
        dd = value.__dict__.get('fixedResonanceSets')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'nmrConstraintStore' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from memops.api.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, memops.api.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('serial')
      if (value is None):
        raise ApiError("""%s.checkValid: serial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, memops.api.Implementation.Int.PythonType)):
        pass
      elif ([x for x in memops.api.Implementation.Int.compatibleTypes if isinstance(value, x)]):
        value = memops.api.Implementation.Int.create(value)
      else:
        raise ApiError("""%s.checkValid: serial:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('access')
      if (value is not None):
        from memops.api.AccessControl import AccessObject as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: access:
           value is not of class memops.AccessControl.AccessObject""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('dataObjects')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: access:
           non-reciprocal link FixedResonanceSet from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('atomSets')
      for value in values:
        if (not isinstance(value, FixedAtomSet)):
          raise ApiError("""%s.checkValid: atomSets:
           value is not of class ccp.nmr.NmrConstraint.FixedAtomSet""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('resonanceSets')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: atomSets:
           non-reciprocal link FixedResonanceSet from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: atomSets:
           Link atomSets between objects from separate partitions
           - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      value = dataDict.get('nmrConstraintStore')
      if (not isinstance(value, NmrConstraintStore)):
        raise ApiError("""%s.checkValid: nmrConstraintStore:
         value is not of class ccp.nmr.NmrConstraint.NmrConstraintStore""" % self.qualifiedName
         + ": %s" % (value,)
        )

      values = dataDict.get('resonances')
      for value in values:
        if (not isinstance(value, FixedResonance)):
          raise ApiError("""%s.checkValid: resonances:
           value is not of class ccp.nmr.NmrConstraint.FixedResonance""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('resonanceSet')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: resonances:
           non-reciprocal link FixedResonanceSet from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: resonances:
           Link resonances between objects from separate partitions
           - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    # check explicit class constraints
    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    # check roles
    value = dataDict.get('access')
    values = dataDict.get('atomSets')
    if (len(values) < 1):
      raise ApiError("""%s.checkValid: atomSets:
       locard: values must be of length >= 1""" % self.qualifiedName
       + ": %s" % (self,)
      )

    value = dataDict.get('nmrConstraintStore')
    if (value is None):
      raise ApiError("""%s.checkValid: nmrConstraintStore:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    values = dataDict.get('resonances')
    if (len(values) < 1):
      raise ApiError("""%s.checkValid: resonances:
       locard: values must be of length >= 1""" % self.qualifiedName
       + ": %s" % (self,)
      )

  delete = memops.api.Implementation.DataObject.delete

  findAllApplicationData = memops.api.Implementation.DataObject.findAllApplicationData
  
  def findAllAtomSets(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.FixedResonanceSet.atomSets
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('atomSets')
      result = set(currentValues)

    else:
      currentValues = dataDict.get('atomSets')
      result = set()
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('name', 'serial', 'access', 'nmrConstraintStore',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result.add(v)

    return result
  
  def findAllResonances(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.FixedResonanceSet.resonances
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('resonances')
      result = set(currentValues)

    else:
      currentValues = dataDict.get('resonances')
      result = set()
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('details', 'isotopeCode', 'name', 'resonanceSerial', 'serial', 'access', 'nmrConstraintStore', 'resonanceSet',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result.add(v)

    return result

  findFirstApplicationData = memops.api.Implementation.DataObject.findFirstApplicationData
  
  def findFirstAtomSet(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.FixedResonanceSet.atomSets
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('atomSets')
      if (currentValues):
        result = iter(currentValues).next()
      else:
        result = None

    else:
      currentValues = dataDict.get('atomSets')
      result = None
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('name', 'serial', 'access', 'nmrConstraintStore',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result = v; break

    return result
  
  def findFirstResonance(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.FixedResonanceSet.resonances
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('resonances')
      if (currentValues):
        result = iter(currentValues).next()
      else:
        result = None

    else:
      currentValues = dataDict.get('resonances')
      result = None
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('details', 'isotopeCode', 'name', 'resonanceSerial', 'serial', 'access', 'nmrConstraintStore', 'resonanceSet',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result = v; break

    return result
  
  def get(self, name):
    """
    GetAttr for ccp.nmr.NmrConstraint.FixedResonanceSet
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getAccess = memops.api.Implementation.DataObject.getAccess

  getApplicationData = memops.api.Implementation.DataObject.getApplicationData
  
  def getAtomSets(self):
    """
    Get for ccp.nmr.NmrConstraint.FixedResonanceSet.atomSets
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('atomSets')
    result = frozenset(tempVar)
    return result
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.FixedResonanceSet
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (2 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.FixedResonanceSet'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (1 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.FixedResonanceSet'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-1]
      obj2 = obj1.__dict__.get('fixedResonanceSets').get(objKey)
      result = obj2

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = memops.api.Implementation.MemopsObject.getByNavigation

  getClassName = memops.api.Implementation.ComplexDataType.getClassName

  getExpandedKey = memops.api.Implementation.MemopsObject.getExpandedKey

  getFieldNames = memops.api.Implementation.ComplexDataType.getFieldNames
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccp.nmr.NmrConstraint.FixedResonanceSet
    """
    dataDict = self.__dict__
    result = list()

    obj1 = dataDict.get('nmrConstraintStore')

    if (useGuid):
      result.append(obj1.__dict__.get('guid'))
    else:
      result.append(obj1.__dict__.get('serial'))

    result.append(dataDict.get('serial'))

    return result

  getInConstructor = memops.api.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = memops.api.Implementation.MemopsObject.getIsDeleted
  
  def getLocalKey(self):
    """
    GetLocalKey for ccp.nmr.NmrConstraint.FixedResonanceSet
    """
    dataDict = self.__dict__
    result = dataDict.get('serial')
    return result

  getMetaclass = memops.api.Implementation.ComplexDataType.getMetaclass
  
  def getNmrConstraintStore(self):
    """
    Get for ccp.nmr.NmrConstraint.FixedResonanceSet.nmrConstraintStore
    """
    dataDict = self.__dict__
    result = dataDict.get('nmrConstraintStore')
    return result

  getPackageName = memops.api.Implementation.ComplexDataType.getPackageName

  getPackageShortName = memops.api.Implementation.ComplexDataType.getPackageShortName
  
  def getParent(self):
    """
    Get for ccp.nmr.NmrConstraint.FixedResonanceSet.parent
    """
    dataDict = self.__dict__
    result = dataDict.get('nmrConstraintStore')
    return result

  getQualifiedName = memops.api.Implementation.ComplexDataType.getQualifiedName
  
  def getResonances(self):
    """
    Get for ccp.nmr.NmrConstraint.FixedResonanceSet.resonances
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('resonances')
    result = frozenset(tempVar)
    return result

  getRoot = memops.api.Implementation.MemopsObject.getRoot
  
  def getSerial(self):
    """
    Get for ccp.nmr.NmrConstraint.FixedResonanceSet.serial
    """
    dataDict = self.__dict__
    result = dataDict.get('serial')
    return result

  getTopObject = memops.api.Implementation.DataObject.getTopObject

  removeApplicationData = memops.api.Implementation.DataObject.removeApplicationData
  
  def removeAtomSet(self, value):
    """
    Remove for ccp.nmr.NmrConstraint.FixedResonanceSet.atomSets
    """
    dataDict = self.__dict__
    if (not isinstance(value, FixedAtomSet)):
      raise ApiError("""%s.removeAtomSet:
       value is not of class ccp.nmr.NmrConstraint.FixedAtomSet""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('atomSets')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.removeAtomSet:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.removeAtomSet:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.removeAtomSet:
       called with deleted value""" % self.qualifiedName
      )

    if (not (value in currentValues)):
      raise ApiError("""%s.removeAtomSet:
       value not in list""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      if (len(currentValues) < (1 + 1)):
        raise ApiError("""%s.removeAtomSet:
         locard: currentValues: cannot remove value""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    oldSelves = value.__dict__.get('resonanceSets')
    oldSelves.remove(self)
    currentValues.remove(value)
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('removeAtomSet')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  def removeResonance(self, value):
    """
    Remove for ccp.nmr.NmrConstraint.FixedResonanceSet.resonances
    """
    dataDict = self.__dict__
    if (not isinstance(value, FixedResonance)):
      raise ApiError("""%s.removeResonance:
       value is not of class ccp.nmr.NmrConstraint.FixedResonance""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('resonances')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.removeResonance:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.removeResonance:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.removeResonance:
       called with deleted value""" % self.qualifiedName
      )

    if (not (value in currentValues)):
      raise ApiError("""%s.removeResonance:
       value not in list""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      if (len(currentValues) < (1 + 1)):
        raise ApiError("""%s.removeResonance:
         locard: currentValues: cannot remove value""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    value.__dict__['resonanceSet'] = None
    currentValues.remove(value)
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('removeResonance')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  def set(self, name, value):
    """
    SetAttr for ccp.nmr.NmrConstraint.FixedResonanceSet
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setAccess = memops.api.Implementation.DataObject.setAccess

  setApplicationData = memops.api.Implementation.DataObject.setApplicationData
  
  def setAtomSets(self, values):
    """
    Set for ccp.nmr.NmrConstraint.FixedResonanceSet.atomSets
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setAtomSets:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      if (not isinstance(value, FixedAtomSet)):
        raise ApiError("""%s.setAtomSets:
         value is not of class ccp.nmr.NmrConstraint.FixedAtomSet""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('atomSets')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setAtomSets:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setAtomSets:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setAtomSets:
         an object in values is deleted""" % self.qualifiedName
        )

    if (values == currentValues):
      return

    if (notOverride):
      if (len(values) < 1):
        raise ApiError("""%s.setAtomSets:
         locard: values must be of length >= 1""" % self.qualifiedName
         + ": %s" % (self,)
        )

      xx1 = dataDict.get('topObject')
      for value in values:
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setAtomSets:
           Link atomSets between objects from separate partitions
           - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    for cv in currentValues:
      if (not (cv in values)):
        oldSelves = cv.__dict__.get('resonanceSets')
        oldSelves.remove(self)

    for cv in values:
      if (not (cv in currentValues)):
        oldSelves = cv.__dict__.get('resonanceSets')
        oldSelves.add(self)

    dataDict['atomSets'] = values
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setAtomSets')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  def setResonances(self, values):
    """
    Set for ccp.nmr.NmrConstraint.FixedResonanceSet.resonances
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setResonances:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      if (not isinstance(value, FixedResonance)):
        raise ApiError("""%s.setResonances:
         value is not of class ccp.nmr.NmrConstraint.FixedResonance""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('resonances')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setResonances:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setResonances:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setResonances:
         an object in values is deleted""" % self.qualifiedName
        )

    if (values == currentValues):
      return

    if (notOverride):
      if (len(values) < 1):
        raise ApiError("""%s.setResonances:
         locard: values must be of length >= 1""" % self.qualifiedName
         + ": %s" % (self,)
        )

      oldSelves = {}
      for cv in values:
        if (not (cv in currentValues)):
          oldSelf = cv.__dict__.get('resonanceSet')
          if (oldSelf is not None):
            knt = oldSelves.get(oldSelf)
            if (knt is None):
              knt = 1
            else:
              knt = knt + 1

            oldSelves[oldSelf] = knt

      for osv in oldSelves.keys():
        siblingValues = osv.__dict__.get('resonances')
        knt = oldSelves.get(osv)
        if (len(siblingValues) < (1 + knt)):
          raise ApiError("""%s.setResonances:
           locard: siblingValues: cannot remove value""" % self.qualifiedName
           + ": %s" % (self,)
          )

      xx1 = dataDict.get('topObject')
      for value in values:
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setResonances:
           Link resonances between objects from separate partitions
           - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    for cv in currentValues:
      if (not (cv in values)):
        cv.__dict__['resonanceSet'] = None

    for cv in values:
      if (not (cv in currentValues)):
        oldSelf = cv.__dict__.get('resonanceSet')
        if (oldSelf is not None):
          vv = oldSelf.__dict__.get('resonances')
          vv.remove(cv)

      cv.__dict__['resonanceSet'] = self

    dataDict['resonances'] = values
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setResonances')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  def setSerial(self, value):
    """
    Set for ccp.nmr.NmrConstraint.FixedResonanceSet.serial
    """
    dataDict = self.__dict__
    if (isinstance(value, memops.api.Implementation.Int.PythonType)):
      pass
    elif ([x for x in memops.api.Implementation.Int.compatibleTypes if isinstance(value, x)]):
      value = memops.api.Implementation.Int.create(value)
    else:
      raise ApiError("""%s.setSerial:
       memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('serial')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setSerial:
       called on deleted object""" % self.qualifiedName
      )

    if (value == currentValue):
      return

    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setSerial:
         cannot set serial, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is None):
        raise ApiError("""%s.setSerial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    parent = dataDict.get('nmrConstraintStore')
    oldSerial = parent.__dict__.get('_serialDict').get('fixedResonanceSets')
    if (value < 0):
      value = (oldSerial + 1)
      parent.__dict__.get('_serialDict')['fixedResonanceSets'] = value
    elif (value > oldSerial):
      parent.__dict__.get('_serialDict')['fixedResonanceSets'] = value

    dataDict['serial'] = value

    # doNotifies
  
  def sortedAtomSets(self):
    """
    Sorted for ccp.nmr.NmrConstraint.FixedResonanceSet.atomSets
    """
    dataDict = self.__dict__
    ll = dataDict.get('atomSets')
    ll = [(x.getFullKey(),x) for x in ll]
    
    ll.sort()
    result = [x[1] for x in ll]
    return result
  
  def sortedResonances(self):
    """
    Sorted for ccp.nmr.NmrConstraint.FixedResonanceSet.resonances
    """
    dataDict = self.__dict__
    ll = dataDict.get('resonances')
    ll = [(x.getFullKey(),x) for x in ll]
    
    ll.sort()
    result = [x[1] for x in ll]
    return result

  toDetailedString = memops.api.Implementation.ComplexDataType.toDetailedString

  applicationData = memops.api.Implementation.DataObject.applicationData

  className = memops.api.Implementation.ComplexDataType.className

  fieldNames = memops.api.Implementation.ComplexDataType.fieldNames

  inConstructor = memops.api.Implementation.ComplexDataType.inConstructor

  isDeleted = memops.api.Implementation.MemopsObject.isDeleted

  metaclass = memops.api.Implementation.ComplexDataType.metaclass

  packageName = memops.api.Implementation.ComplexDataType.packageName

  packageShortName = memops.api.Implementation.ComplexDataType.packageShortName

  qualifiedName = memops.api.Implementation.ComplexDataType.qualifiedName
  
  serial = property(getSerial, setSerial, None,
  r"""Serial number of object. Serves as object main key. Serial numbers of 
  deleted objects are not re-used. Serial numbers can only be set by the 
  implementation. Values are in practice always positive, since negative 
  values are interpreted as a signal to set the next free serial
  """)

  access = memops.api.Implementation.DataObject.access
  
  atomSets = property(getAtomSets, setAtomSets, None,
  r"""FixedAtomSets making up FixedResonanceSet
  """)
  
  nmrConstraintStore = property(getNmrConstraintStore,  None, None,
  r"""parent link
  """)
  
  parent = property(getParent, None, None,
  r"""link to parent object - synonym for nmrConstraintStore
  """)
  
  resonances = property(getResonances, setResonances, None,
  r"""FixedResonances making up FixedResonanceSet
  """)

  root = memops.api.Implementation.MemopsObject.root

  topObject = memops.api.Implementation.DataObject.topObject

###############################################################################
class NmrConstraintStore(memops.api.Implementation.TopObject):
  r"""Collection of Nmr constraints used together, and associated information. 
This class serves as TopObject. 
  """
  #   from data model element ccp.nmr.NmrConstraint.NmrConstraintStore revision 1.47.2.9
  _metaclass = metaPackage.getElement('NmrConstraintStore')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('applicationData', 'className', 'createdBy', 'fieldNames', 'guid', 'inConstructor', 'isDeleted', 'isLoaded', 'isModifiable', 'isModified', 'isReading', 'lastUnlockedBy', 'metaclass', 'packageName', 'packageShortName', 'qualifiedName', 'serial', 'access', 'activeRepositories', 'additionalStructureAnalyses', 'chainStates', 'conditionStates', 'constraintGroups', 'constraintLists', 'dangleChains', 'fixedAtomSets', 'fixedResonanceSets', 'fixedResonances', 'inputToNmrRuns', 'memopsRoot', 'nmrProject', 'outputFromNmrRun', 'packageLocator', 'parent', 'resStructures', 'root', 'structureAnalyses', 'structureGenerations', 'topObject', 'validationStores', 'violationLists',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccp.nmr.NmrConstraint.NmrConstraintStore
    """
    dataDict = self.__dict__
    dataDict['memopsRoot'] = parent
    from memops.api.Implementation import MemopsRoot as importedType
    if (not isinstance(parent, importedType)):
      raise ApiError("""%s.__init__:
       value is not of class memops.Implementation.MemopsRoot""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    topObject = self
    dataDict['topObject'] = topObject
    if (attrlinks.get('isReading', False)):
      del attrlinks['isReading']
      dataDict['isLoaded'] = False
      dataDict['isModified'] = False
      dataDict['isReading'] = True
    elif (parent.__dict__.get('isReading')):
      dataDict['isLoaded'] = False
      dataDict['isModified'] = False
      dataDict['isReading'] = True
    else:
      dataDict['isLoaded'] = True
      dataDict['isModified'] = True
      dataDict['isReading'] = False

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    try:
      if (not (dataDict.get('isReading'))):
        parent.refreshTopObjects('ccp.nmr.NmrConstraint')

      dataDict['applicationData'] = list()
      dataDict['createdBy'] = None
      dataDict['guid'] = None
      dataDict['isModifiable'] = True
      dataDict['lastUnlockedBy'] = None
      dataDict['serial'] = None
      dataDict['access'] = None
      dataDict['additionalStructureAnalyses'] = set()
      dataDict['chainStates'] = set()
      dataDict['conditionStates'] = {}
      dataDict['constraintGroups'] = {}
      dataDict['constraintLists'] = {}
      dataDict['dangleChains'] = set()
      dataDict['fixedAtomSets'] = {}
      dataDict['fixedResonanceSets'] = {}
      dataDict['fixedResonances'] = {}
      dataDict['inputToNmrRuns'] = set()
      dataDict['nmrProject'] = None
      dataDict['outputFromNmrRun'] = None
      dataDict['resStructures'] = {}
      dataDict['structureAnalyses'] = set()
      dataDict['structureGenerations'] = set()
      dataDict['validationStores'] = set()
      dataDict['violationLists'] = {}
      dataDict['activeRepositories'] = list()

      dataDict['inConstructor'] = True
      try:
        
        for key, value in attrlinks.iteritems():
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        del dataDict['inConstructor']
      except:
        print "ERROR in ccp.nmr.NmrConstraint.NmrConstraintStore.__init__"
        del dataDict['inConstructor']
        raise

      if (notOverride):
        if (dataDict.get('serial') is None):
          dataDict['inConstructor'] = True
          self.setSerial(-1)
          del dataDict['inConstructor']
        else:
          raise ApiError("""%s.__init__:
           Cannot pass in explicit serial if not reading""" % self.qualifiedName
           + ": %s:%s" % (parent, 'ccp.nmr.NmrConstraint.NmrConstraintStore')
          )

      serialDict = {}
      serialDict['conditionStates'] = 0
      serialDict['constraintGroups'] = 0
      serialDict['constraintLists'] = 0
      serialDict['fixedAtomSets'] = 0
      serialDict['fixedResonanceSets'] = 0
      serialDict['fixedResonances'] = 0
      serialDict['resStructures'] = 0
      serialDict['violationLists'] = 0
      dataDict['_serialDict'] = serialDict

      if (notIsReading):
        childrenDict = parent.__dict__.get('nmrConstraintStores')
        objKey = dataDict.get('serial')
        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['serial'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notIsReading):
        guid = dataDict.get('guid')
        if (guid is None):
          guid = root.newGuid()
          dataDict['guid'] = guid

        dd = root.__dict__.get('topObjects')
        if (dd.get(guid) is None):
          dd[guid] = self
        else:
          raise ApiError("""%s.__init__:
           Creating TopObject with preexisting guid""" % self.qualifiedName
           + ": %s" % (self,)
          )

        dataDict['createdBy'] = root.__dict__.get('currentUserId')

      if (notOverride):
        self.checkValid()

      if ((notIsReading or root.__dict__.get('currentNmrConstraintStore') is None)):
        root.__dict__['currentNmrConstraintStore'] = self

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        print '''WARNING Error in clean-up of incorrectly created object. 
        Data may be left in an illegal state'''
        del dataDict['inConstructor']
      raise exc_info[0], exc_info[1], exc_info[2]

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccp.nmr.NmrConstraint.NmrConstraintStore:
       determines 
    cascading deletes to follow from delete of object.
       *Implementation 
    function* - should be called only by API delete function.
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    objsToBeDeleted.add(self)
    if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
      dataDict.get('topObject').load()

    access = dataDict.get('access')
    if (access is not None):
      topObject = access.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    additionalStructureAnalyses = dataDict.get('additionalStructureAnalyses')
    pass
    for additionalStructureAnalysis in additionalStructureAnalyses:
      topObject = additionalStructureAnalysis.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    chainStates = dataDict.get('chainStates')
    pass
    for chainState in chainStates:
      topObject = chainState.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    conditionStates = dataDict.get('conditionStates').values()
    for conditionState in conditionStates:
      if (not (conditionState in objsToBeDeleted)):
        objsToBeDeleted.add(conditionState)
        objsToBeChecked.append(conditionState)

    constraintGroups = dataDict.get('constraintGroups').values()
    for constraintGroup in constraintGroups:
      if (not (constraintGroup in objsToBeDeleted)):
        objsToBeDeleted.add(constraintGroup)
        objsToBeChecked.append(constraintGroup)

    constraintLists = dataDict.get('constraintLists').values()
    for constraintList in constraintLists:
      if (not (constraintList in objsToBeDeleted)):
        objsToBeDeleted.add(constraintList)
        objsToBeChecked.append(constraintList)

    root = dataDict.get('memopsRoot')
    root.refreshTopObjects('cambridge.Dangle')
    tobjList = root.__dict__.get('dangleStores').values()
    for tobj in tobjList:
      if (not (tobj.__dict__.get('isLoaded'))):
        tobj.load()

    dangleChains = dataDict.get('dangleChains')
    pass
    for dangleChain in dangleChains:
      topObject = dangleChain.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    fixedAtomSets = dataDict.get('fixedAtomSets').values()
    for fixedAtomSet in fixedAtomSets:
      if (not (fixedAtomSet in objsToBeDeleted)):
        objsToBeDeleted.add(fixedAtomSet)
        objsToBeChecked.append(fixedAtomSet)

    fixedResonanceSets = dataDict.get('fixedResonanceSets').values()
    for fixedResonanceSet in fixedResonanceSets:
      if (not (fixedResonanceSet in objsToBeDeleted)):
        objsToBeDeleted.add(fixedResonanceSet)
        objsToBeChecked.append(fixedResonanceSet)

    fixedResonances = dataDict.get('fixedResonances').values()
    for fixedResonance in fixedResonances:
      if (not (fixedResonance in objsToBeDeleted)):
        objsToBeDeleted.add(fixedResonance)
        objsToBeChecked.append(fixedResonance)

    root = dataDict.get('memopsRoot')
    root.refreshTopObjects('molsim.NmrSim')
    tobjList = root.__dict__.get('nmrSimStores').values()
    for tobj in tobjList:
      if (not (tobj.__dict__.get('isLoaded'))):
        tobj.load()

    inputToNmrRuns = dataDict.get('inputToNmrRuns')
    for inputToNmrRun in inputToNmrRuns:
      if (not (inputToNmrRun in objsToBeDeleted)):
        objsToBeDeleted.add(inputToNmrRun)
        objsToBeChecked.append(inputToNmrRun)

    for inputToNmrRun in inputToNmrRuns:
      topObject = inputToNmrRun.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    memopsRoot = dataDict.get('memopsRoot')
    if (memopsRoot is not None):
      topObject = memopsRoot.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    nmrProject = dataDict.get('nmrProject')
    if (nmrProject is not None):
      topObject = nmrProject.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    if (dataDict.get('outputFromNmrRun') is None):
      root = dataDict.get('memopsRoot')
      root.refreshTopObjects('molsim.NmrSim')
      tobjList = root.__dict__.get('nmrSimStores').values()
      for tobj in tobjList:
        if (not (tobj.__dict__.get('isLoaded'))):
          tobj.load()

    outputFromNmrRun = dataDict.get('outputFromNmrRun')
    if (outputFromNmrRun is not None):
      topObject = outputFromNmrRun.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    resStructures = dataDict.get('resStructures').values()
    for resStructure in resStructures:
      if (not (resStructure in objsToBeDeleted)):
        objsToBeDeleted.add(resStructure)
        objsToBeChecked.append(resStructure)

    structureAnalyses = dataDict.get('structureAnalyses')
    pass
    for structureAnalysis in structureAnalyses:
      topObject = structureAnalysis.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    structureGenerations = dataDict.get('structureGenerations')
    pass
    for structureGeneration in structureGenerations:
      topObject = structureGeneration.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    validationStores = dataDict.get('validationStores')
    pass
    for validationStore in validationStores:
      topObject = validationStore.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    violationLists = dataDict.get('violationLists').values()
    for violationList in violationLists:
      if (not (violationList in objsToBeDeleted)):
        objsToBeDeleted.add(violationList)
        objsToBeChecked.append(violationList)

    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccp.nmr.NmrConstraint.NmrConstraintStore:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    memopsRoot = dataDict.get('memopsRoot')
    if (self is memopsRoot.__dict__.get('currentNmrConstraintStore')):
      memopsRoot.__dict__['currentNmrConstraintStore'] = None

    access = dataDict.get('access')
    if ((access is not None and not (access in objsToBeDeleted))):
      dataObjects = access.__dict__.get('dataObjects')
      dataObjects.remove(self)

    for additionalStructureAnalysis in dataDict.get('additionalStructureAnalyses'):
      if (not (additionalStructureAnalysis in objsToBeDeleted)):
        additionalConstraintStores = additionalStructureAnalysis.__dict__.get('additionalConstraintStores')
        additionalConstraintStores.remove(self)

    for chainState in dataDict.get('chainStates'):
      if (not (chainState in objsToBeDeleted)):
        nmrConstraintStores = chainState.__dict__.get('nmrConstraintStores')
        nmrConstraintStores.remove(self)

    for dangleChain in dataDict.get('dangleChains'):
      if (not (dangleChain in objsToBeDeleted)):
        dangleChain.__dict__['nmrConstraintStore'] = None

    nmrProject = dataDict.get('nmrProject')
    if ((nmrProject is not None and not (nmrProject in objsToBeDeleted))):
      nmrConstraintStores = nmrProject.__dict__.get('nmrConstraintStores')
      nmrConstraintStores.remove(self)

    outputFromNmrRun = dataDict.get('outputFromNmrRun')
    if ((outputFromNmrRun is not None and not (outputFromNmrRun in objsToBeDeleted))):
      outputFromNmrRun.__dict__['outputConstraintStore'] = None

    for structureAnalysis in dataDict.get('structureAnalyses'):
      if (not (structureAnalysis in objsToBeDeleted)):
        structureAnalysis.__dict__['nmrConstraintStore'] = None

    for structureGeneration in dataDict.get('structureGenerations'):
      if (not (structureGeneration in objsToBeDeleted)):
        structureGeneration.__dict__['nmrConstraintStore'] = None

    for validationStore in dataDict.get('validationStores'):
      if (not (validationStore in objsToBeDeleted)):
        validationStore.__dict__['nmrConstraintStore'] = None

    memopsRoot = dataDict.get('memopsRoot')
    if (not (memopsRoot in objsToBeDeleted)):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = memopsRoot.__dict__.get('nmrConstraintStores')
        if (self is dd.get(objKey)):
          del dd[objKey]

    dataDict['conditionStates'] = {}
    dataDict['constraintGroups'] = {}
    dataDict['constraintLists'] = {}
    dataDict['fixedAtomSets'] = {}
    dataDict['fixedResonanceSets'] = {}
    dataDict['fixedResonances'] = {}
    dataDict['resStructures'] = {}
    dataDict['violationLists'] = {}
  
  def addAdditionalStructureAnalysis(self, value):
    """
    Add for
    ccp.nmr.NmrConstraint.NmrConstraintStore.additionalStructureAnalyses
    """
    dataDict = self.__dict__
    from ccp.api.nmr.Nmr import StructureAnalysis as importedType
    if (not isinstance(value, importedType)):
      raise ApiError("""%s.addAdditionalStructureAnalysis:
       value is not of class ccp.nmr.Nmr.StructureAnalysis""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    currentValues = dataDict.get('additionalStructureAnalyses')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      topObject = value.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)
      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.addAdditionalStructureAnalysis:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.addAdditionalStructureAnalysis:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.addAdditionalStructureAnalysis:
       called with deleted value""" % self.qualifiedName
      )

    if (value in currentValues):
      raise ApiError("""%s.addAdditionalStructureAnalysis:
       value is in list already""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      if (value is not None):
        xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.addAdditionalStructureAnalysis:
           Link additionalStructureAnalyses between objects from separate partitions
           - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    oldSelves = value.__dict__.get('additionalConstraintStores')
    oldSelves.add(self)
    currentValues.add(value)
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('addAdditionalStructureAnalysis')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  addApplicationData = memops.api.Implementation.DataObject.addApplicationData
  
  def addChainState(self, value):
    """
    Add for ccp.nmr.NmrConstraint.NmrConstraintStore.chainStates
    """
    dataDict = self.__dict__
    from ccp.api.nmr.Nmr import ChainState as importedType
    if (not isinstance(value, importedType)):
      raise ApiError("""%s.addChainState:
       value is not of class ccp.nmr.Nmr.ChainState""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    currentValues = dataDict.get('chainStates')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      topObject = value.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)
      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.addChainState:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.addChainState:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.addChainState:
       called with deleted value""" % self.qualifiedName
      )

    if (value in currentValues):
      raise ApiError("""%s.addChainState:
       value is in list already""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      if (value is not None):
        xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.addChainState:
           Link chainStates between objects from separate partitions
           - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      if (notInConstructor):
        if (value is not None):
          if (not (self.findAllChainStates(chainStateSet=value.chainStateSet) in ((), (value,)))):
            raise ApiError("""%s.addChainState:
             chainStates constraint only_one_chainState_for_each_chainStateSet violated by value""" % self.qualifiedName
             + ": %s" % (value,)
            )

    oldSelves = value.__dict__.get('nmrConstraintStores')
    oldSelves.add(self)
    currentValues.add(value)
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('addChainState')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  def addDangleChain(self, value):
    """
    Add for ccp.nmr.NmrConstraint.NmrConstraintStore.dangleChains
    """
    dataDict = self.__dict__
    from cambridge.api.Dangle import DangleChain as importedType
    if (not isinstance(value, importedType)):
      raise ApiError("""%s.addDangleChain:
       value is not of class cambridge.Dangle.DangleChain""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    currentValues = dataDict.get('dangleChains')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      topObject = value.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)
      oldSelf = value.__dict__.get('nmrConstraintStore')
      if (oldSelf is not None):
        topObject = oldSelf.__dict__.get('topObject')
        topObjectsToCheck.add(topObject)

      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.addDangleChain:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.addDangleChain:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.addDangleChain:
       called with deleted value""" % self.qualifiedName
      )

    if (value in currentValues):
      raise ApiError("""%s.addDangleChain:
       value is in list already""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      if (value is not None):
        xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.addDangleChain:
           Link dangleChains between objects from separate partitions
           - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    oldSelf = value.__dict__.get('nmrConstraintStore')
    if (oldSelf is not None):
      if (not (oldSelf.__dict__.get('isLoaded'))):
        oldSelf.load()

      root = dataDict.get('memopsRoot')
      root.refreshTopObjects('cambridge.Dangle')
      tobjList = root.__dict__.get('dangleStores').values()
      for tobj in tobjList:
        if (not (tobj.__dict__.get('isLoaded'))):
          tobj.load()

      siblingValues = oldSelf.__dict__.get('dangleChains')
      siblingValues.remove(value)

    value.__dict__['nmrConstraintStore'] = self
    currentValues.add(value)
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('addDangleChain')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  def addStructureAnalysis(self, value):
    """
    Add for ccp.nmr.NmrConstraint.NmrConstraintStore.structureAnalyses
    """
    dataDict = self.__dict__
    from ccp.api.nmr.Nmr import StructureAnalysis as importedType
    if (not isinstance(value, importedType)):
      raise ApiError("""%s.addStructureAnalysis:
       value is not of class ccp.nmr.Nmr.StructureAnalysis""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    currentValues = dataDict.get('structureAnalyses')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      topObject = value.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)
      if (value.__dict__.get('nmrConstraintStore') is None):
        root = dataDict.get('memopsRoot')
        root.refreshTopObjects('ccp.nmr.NmrConstraint')
        tobjList = root.__dict__.get('nmrConstraintStores').values()
        for tobj in tobjList:
          if (not (tobj.__dict__.get('isLoaded'))):
            tobj.load()

      oldSelf = value.__dict__.get('nmrConstraintStore')
      if (oldSelf is not None):
        topObject = oldSelf.__dict__.get('topObject')
        topObjectsToCheck.add(topObject)

      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.addStructureAnalysis:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.addStructureAnalysis:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.addStructureAnalysis:
       called with deleted value""" % self.qualifiedName
      )

    if (value in currentValues):
      raise ApiError("""%s.addStructureAnalysis:
       value is in list already""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      if (value is not None):
        xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.addStructureAnalysis:
           Link structureAnalyses between objects from separate partitions
           - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    oldSelf = value.__dict__.get('nmrConstraintStore')
    if (oldSelf is not None):
      if (not (oldSelf.__dict__.get('isLoaded'))):
        oldSelf.load()

      siblingValues = oldSelf.__dict__.get('structureAnalyses')
      siblingValues.remove(value)

    value.__dict__['nmrConstraintStore'] = self
    currentValues.add(value)
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('addStructureAnalysis')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  def addStructureGeneration(self, value):
    """
    Add for ccp.nmr.NmrConstraint.NmrConstraintStore.structureGenerations
    """
    dataDict = self.__dict__
    from ccp.api.nmr.Nmr import StructureGeneration as importedType
    if (not isinstance(value, importedType)):
      raise ApiError("""%s.addStructureGeneration:
       value is not of class ccp.nmr.Nmr.StructureGeneration""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    currentValues = dataDict.get('structureGenerations')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      topObject = value.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)
      if (value.__dict__.get('nmrConstraintStore') is None):
        root = dataDict.get('memopsRoot')
        root.refreshTopObjects('ccp.nmr.NmrConstraint')
        tobjList = root.__dict__.get('nmrConstraintStores').values()
        for tobj in tobjList:
          if (not (tobj.__dict__.get('isLoaded'))):
            tobj.load()

      oldSelf = value.__dict__.get('nmrConstraintStore')
      if (oldSelf is not None):
        topObject = oldSelf.__dict__.get('topObject')
        topObjectsToCheck.add(topObject)

      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.addStructureGeneration:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.addStructureGeneration:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.addStructureGeneration:
       called with deleted value""" % self.qualifiedName
      )

    if (value in currentValues):
      raise ApiError("""%s.addStructureGeneration:
       value is in list already""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      if (value is not None):
        xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.addStructureGeneration:
           Link structureGenerations between objects from separate partitions
           - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    oldSelf = value.__dict__.get('nmrConstraintStore')
    if (oldSelf is not None):
      if (not (oldSelf.__dict__.get('isLoaded'))):
        oldSelf.load()

      siblingValues = oldSelf.__dict__.get('structureGenerations')
      siblingValues.remove(value)

    value.__dict__['nmrConstraintStore'] = self
    currentValues.add(value)
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('addStructureGeneration')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  def addValidationStore(self, value):
    """
    Add for ccp.nmr.NmrConstraint.NmrConstraintStore.validationStores
    """
    dataDict = self.__dict__
    from ccp.api.molecule.Validation import ValidationStore as importedType
    if (not isinstance(value, importedType)):
      raise ApiError("""%s.addValidationStore:
       value is not of class ccp.molecule.Validation.ValidationStore""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    currentValues = dataDict.get('validationStores')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      topObject = value.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)
      if (value.__dict__.get('nmrConstraintStore') is None):
        root = dataDict.get('memopsRoot')
        root.refreshTopObjects('ccp.nmr.NmrConstraint')

      oldSelf = value.__dict__.get('nmrConstraintStore')
      if (oldSelf is not None):
        topObject = oldSelf.__dict__.get('topObject')
        topObjectsToCheck.add(topObject)

      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.addValidationStore:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.addValidationStore:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.addValidationStore:
       called with deleted value""" % self.qualifiedName
      )

    if (value in currentValues):
      raise ApiError("""%s.addValidationStore:
       value is in list already""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      if (value is not None):
        xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.addValidationStore:
           Link validationStores between objects from separate partitions
           - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      if (notInConstructor):
        if (value is not None):
          if (not (self.nmrProject is value.nmrProject)):
            raise ApiError("""%s.addValidationStore:
             validationStores constraint self_nmrProject_is_value_nmrProject violated by value""" % self.qualifiedName
             + ": %s" % (value,)
            )

    oldSelf = value.__dict__.get('nmrConstraintStore')
    if (oldSelf is not None):
      siblingValues = oldSelf.__dict__.get('validationStores')
      siblingValues.remove(value)

    value.__dict__['nmrConstraintStore'] = self
    currentValues.add(value)
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        if (not (topObjectModify.__dict__.get('isLoaded'))):
          topObjectModify.load()

        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('addValidationStore')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  backup = memops.api.Implementation.TopObject.backup
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccp.nmr.NmrConstraint.NmrConstraintStore
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    self.checkValid(complete)
    values = dataDict.get('conditionStates').values()
    for value in values:
      value.checkAllValid(complete)

    values = dataDict.get('constraintGroups').values()
    for value in values:
      value.checkAllValid(complete)

    values = dataDict.get('constraintLists').values()
    for value in values:
      value.checkAllValid(complete)

    values = dataDict.get('fixedAtomSets').values()
    for value in values:
      value.checkAllValid(complete)

    values = dataDict.get('fixedResonanceSets').values()
    for value in values:
      value.checkAllValid(complete)

    values = dataDict.get('fixedResonances').values()
    for value in values:
      value.checkAllValid(complete)

    values = dataDict.get('resStructures').values()
    for value in values:
      value.checkAllValid(complete)

    values = dataDict.get('violationLists').values()
    for value in values:
      value.checkAllValid(complete)

  def checkValid(self, complete=False):
    """
    CheckValid for ccp.nmr.NmrConstraint.NmrConstraintStore
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('memopsRoot')
        dd = value.__dict__.get('nmrConstraintStores')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'memopsRoot' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from memops.api.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('createdBy')
      if (value is None):
        raise ApiError("""%s.checkValid: createdBy:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, memops.api.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: createdBy:
         memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 32):
        raise ApiError("""%s.checkValid: createdBy:
         memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: createdBy:
         memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.split()) == 1)):
        raise ApiError("""%s.checkValid: createdBy:
         Word constraint contains_no_white_space violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('guid')
      if (value is None):
        raise ApiError("""%s.checkValid: guid:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, memops.api.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: guid:
         memops.Implementation.GuidString input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: guid:
         memops.Implementation.GuidString maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: guid:
         memops.Implementation.GuidString: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: guid:
         GuidString constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      for char in value:
        if not (char.isalnum() or char in '-_'):
          isValid = False
          break
      else:
        isValid=True
      if (not (isValid)):
        raise ApiError("""%s.checkValid: guid:
         GuidString constraint value_is_url_safe violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('isModifiable')
      if (not (value in [True, False])):
        raise ApiError("""%s.checkValid: isModifiable:
         memops.Implementation.Boolean input is not in enumeration [True, False]""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('lastUnlockedBy')
      if (value is not None):
        if (isinstance(value, memops.api.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: lastUnlockedBy:
           memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 32):
          raise ApiError("""%s.checkValid: lastUnlockedBy:
           memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: lastUnlockedBy:
           memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.split()) == 1)):
          raise ApiError("""%s.checkValid: lastUnlockedBy:
           Word constraint contains_no_white_space violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, memops.api.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('serial')
      if (value is None):
        raise ApiError("""%s.checkValid: serial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, memops.api.Implementation.Int.PythonType)):
        pass
      elif ([x for x in memops.api.Implementation.Int.compatibleTypes if isinstance(value, x)]):
        value = memops.api.Implementation.Int.create(value)
      else:
        raise ApiError("""%s.checkValid: serial:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('access')
      if (value is not None):
        from memops.api.AccessControl import AccessObject as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: access:
           value is not of class memops.AccessControl.AccessObject""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('dataObjects')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: access:
           non-reciprocal link NmrConstraintStore from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('additionalStructureAnalyses')
      for value in values:
        from ccp.api.nmr.Nmr import StructureAnalysis as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: additionalStructureAnalyses:
           value is not of class ccp.nmr.Nmr.StructureAnalysis""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('additionalConstraintStores')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: additionalStructureAnalyses:
           non-reciprocal link NmrConstraintStore from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('chainStates')
      for value in values:
        from ccp.api.nmr.Nmr import ChainState as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: chainStates:
           value is not of class ccp.nmr.Nmr.ChainState""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('nmrConstraintStores')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: chainStates:
           non-reciprocal link NmrConstraintStore from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: chainStates:
           Link chainStates between objects from separate partitions
           - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = dataDict.get('conditionStates').values()
      for value in values:
        if (not isinstance(value, ConditionState)):
          raise ApiError("""%s.checkValid: conditionStates:
           value is not of class ccp.nmr.NmrConstraint.ConditionState""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('nmrConstraintStore')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: conditionStates:
           non-reciprocal link NmrConstraintStore from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('constraintGroups').values()
      for value in values:
        if (not isinstance(value, ConstraintGroup)):
          raise ApiError("""%s.checkValid: constraintGroups:
           value is not of class ccp.nmr.NmrConstraint.ConstraintGroup""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('nmrConstraintStore')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: constraintGroups:
           non-reciprocal link NmrConstraintStore from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('constraintLists').values()
      for value in values:
        if (not isinstance(value, AbstractConstraintList)):
          raise ApiError("""%s.checkValid: constraintLists:
           value is not of class ccp.nmr.NmrConstraint.AbstractConstraintList""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('nmrConstraintStore')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: constraintLists:
           non-reciprocal link NmrConstraintStore from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      root = dataDict.get('memopsRoot')
      root.refreshTopObjects('cambridge.Dangle')
      tobjList = root.__dict__.get('dangleStores').values()
      for tobj in tobjList:
        if (not (tobj.__dict__.get('isLoaded'))):
          tobj.load()

      values = dataDict.get('dangleChains')
      for value in values:
        from cambridge.api.Dangle import DangleChain as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: dangleChains:
           value is not of class cambridge.Dangle.DangleChain""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('nmrConstraintStore')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: dangleChains:
           non-reciprocal link NmrConstraintStore from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: dangleChains:
           Link dangleChains between objects from separate partitions
           - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = dataDict.get('fixedAtomSets').values()
      for value in values:
        if (not isinstance(value, FixedAtomSet)):
          raise ApiError("""%s.checkValid: fixedAtomSets:
           value is not of class ccp.nmr.NmrConstraint.FixedAtomSet""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('nmrConstraintStore')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: fixedAtomSets:
           non-reciprocal link NmrConstraintStore from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('fixedResonanceSets').values()
      for value in values:
        if (not isinstance(value, FixedResonanceSet)):
          raise ApiError("""%s.checkValid: fixedResonanceSets:
           value is not of class ccp.nmr.NmrConstraint.FixedResonanceSet""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('nmrConstraintStore')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: fixedResonanceSets:
           non-reciprocal link NmrConstraintStore from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('fixedResonances').values()
      for value in values:
        if (not isinstance(value, FixedResonance)):
          raise ApiError("""%s.checkValid: fixedResonances:
           value is not of class ccp.nmr.NmrConstraint.FixedResonance""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('nmrConstraintStore')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: fixedResonances:
           non-reciprocal link NmrConstraintStore from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      root = dataDict.get('memopsRoot')
      root.refreshTopObjects('molsim.NmrSim')
      tobjList = root.__dict__.get('nmrSimStores').values()
      for tobj in tobjList:
        if (not (tobj.__dict__.get('isLoaded'))):
          tobj.load()

      values = dataDict.get('inputToNmrRuns')
      for value in values:
        from molsim.api.NmrSim import Run as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: inputToNmrRuns:
           value is not of class molsim.NmrSim.Run""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('inputConstraintStore')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: inputToNmrRuns:
           non-reciprocal link NmrConstraintStore from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: inputToNmrRuns:
           Link inputToNmrRuns between objects from separate partitions
           - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      value = dataDict.get('memopsRoot')
      from memops.api.Implementation import MemopsRoot as importedType
      if (not isinstance(value, importedType)):
        raise ApiError("""%s.checkValid: memopsRoot:
         value is not of class memops.Implementation.MemopsRoot""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('nmrProject')
      from ccp.api.nmr.Nmr import NmrProject as importedType
      if (not isinstance(value, importedType)):
        raise ApiError("""%s.checkValid: nmrProject:
         value is not of class ccp.nmr.Nmr.NmrProject""" % self.qualifiedName
         + ": %s" % (value,)
        )

      oldSelves = value.__dict__.get('nmrConstraintStores')
      if (not (self in oldSelves)):
        raise ApiError("""%s.checkValid: nmrProject:
         non-reciprocal link NmrConstraintStore from object""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (dataDict.get('outputFromNmrRun') is None):
        root = dataDict.get('memopsRoot')
        root.refreshTopObjects('molsim.NmrSim')
        tobjList = root.__dict__.get('nmrSimStores').values()
        for tobj in tobjList:
          if (not (tobj.__dict__.get('isLoaded'))):
            tobj.load()

      value = dataDict.get('outputFromNmrRun')
      if (value is not None):
        from molsim.api.NmrSim import Run as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: outputFromNmrRun:
           value is not of class molsim.NmrSim.Run""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('outputConstraintStore')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: outputFromNmrRun:
           non-reciprocal link NmrConstraintStore from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      value = self.getPackageLocator()
      if (value is None):
        raise ApiError("""%s.checkValid: packageLocator:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      from memops.api.Implementation import PackageLocator as importedType
      if (not isinstance(value, importedType)):
        raise ApiError("""%s.checkValid: packageLocator:
         value is not of class memops.Implementation.PackageLocator""" % self.qualifiedName
         + ": %s" % (value,)
        )

      xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
      yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
      if (not (xx1 is yy1)):
        raise ApiError("""%s.checkValid: packageLocator:
         Link packageLocator between objects from separate partitions
         - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
         + ": %s:%s" % (self, value)
        )

      values = dataDict.get('resStructures').values()
      for value in values:
        if (not isinstance(value, ResStructure)):
          raise ApiError("""%s.checkValid: resStructures:
           value is not of class ccp.nmr.NmrConstraint.ResStructure""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('nmrConstraintStore')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: resStructures:
           non-reciprocal link NmrConstraintStore from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('structureAnalyses')
      for value in values:
        from ccp.api.nmr.Nmr import StructureAnalysis as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: structureAnalyses:
           value is not of class ccp.nmr.Nmr.StructureAnalysis""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('nmrConstraintStore')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: structureAnalyses:
           non-reciprocal link NmrConstraintStore from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: structureAnalyses:
           Link structureAnalyses between objects from separate partitions
           - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = dataDict.get('structureGenerations')
      for value in values:
        from ccp.api.nmr.Nmr import StructureGeneration as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: structureGenerations:
           value is not of class ccp.nmr.Nmr.StructureGeneration""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('nmrConstraintStore')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: structureGenerations:
           non-reciprocal link NmrConstraintStore from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: structureGenerations:
           Link structureGenerations between objects from separate partitions
           - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = dataDict.get('validationStores')
      for value in values:
        from ccp.api.molecule.Validation import ValidationStore as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: validationStores:
           value is not of class ccp.molecule.Validation.ValidationStore""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('nmrConstraintStore')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: validationStores:
           non-reciprocal link NmrConstraintStore from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: validationStores:
           Link validationStores between objects from separate partitions
           - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = dataDict.get('violationLists').values()
      for value in values:
        if (not isinstance(value, ViolationList)):
          raise ApiError("""%s.checkValid: violationLists:
           value is not of class ccp.nmr.NmrConstraint.ViolationList""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('nmrConstraintStore')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: violationLists:
           non-reciprocal link NmrConstraintStore from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

    if (dataDict.get('isLoaded')):
      # check explicit class constraints
      # check attributes
      values = dataDict.get('applicationData')
      for value in values:
        value.checkAllValid(complete)

      value = dataDict.get('isModifiable')
      if (value is None):
        raise ApiError("""%s.checkValid: isModifiable:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      # check roles
      value = dataDict.get('access')
      values = dataDict.get('additionalStructureAnalyses')
      values = dataDict.get('chainStates')
      for value in values:
        if (not (self.findAllChainStates(chainStateSet=value.chainStateSet) in ((), (value,)))):
          raise ApiError("""%s.checkValid: chainStates:
           chainStates constraint only_one_chainState_for_each_chainStateSet violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      values = dataDict.get('conditionStates').values()
      values = dataDict.get('constraintGroups').values()
      values = dataDict.get('constraintLists').values()
      values = dataDict.get('dangleChains')
      values = dataDict.get('fixedAtomSets').values()
      values = dataDict.get('fixedResonanceSets').values()
      values = dataDict.get('fixedResonances').values()
      values = dataDict.get('inputToNmrRuns')
      value = dataDict.get('memopsRoot')
      if (value is None):
        raise ApiError("""%s.checkValid: memopsRoot:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      value = dataDict.get('nmrProject')
      if (value is None):
        raise ApiError("""%s.checkValid: nmrProject:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      value = dataDict.get('outputFromNmrRun')
      values = dataDict.get('resStructures').values()
      values = dataDict.get('structureAnalyses')
      values = dataDict.get('structureGenerations')
      values = dataDict.get('validationStores')
      for value in values:
        if (not (self.nmrProject is value.nmrProject)):
          raise ApiError("""%s.checkValid: validationStores:
           validationStores constraint self_nmrProject_is_value_nmrProject violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      values = dataDict.get('violationLists').values()
    else:
      # check unloaded TopObject
      value = dataDict.get('guid')
      if (value is None):
        raise ApiError("""%s.checkValid: guid:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      value = dataDict.get('serial')
      if (value is None):
        raise ApiError("""%s.checkValid: serial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

  delete = memops.api.Implementation.DataObject.delete

  findAllActiveRepositories = memops.api.Implementation.TopObject.findAllActiveRepositories
  
  def findAllAdditionalStructureAnalyses(self, **conditions):
    """
    FindAll for
    ccp.nmr.NmrConstraint.NmrConstraintStore.additionalStructureAnalyses
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('additionalStructureAnalyses')
      result = set(currentValues)

    else:
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('additionalStructureAnalyses')
      result = set()
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('details', 'name', 'serial', 'access', 'method', 'nmrConstraintStore', 'nmrProject',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result.add(v)

    return result

  findAllApplicationData = memops.api.Implementation.DataObject.findAllApplicationData
  
  def findAllChainStates(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.NmrConstraintStore.chainStates
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('chainStates')
      result = set(currentValues)

    else:
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('chainStates')
      result = set()
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('details', 'name', 'serial', 'access', 'chainStateSet',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result.add(v)

    return result
  
  def findAllConditionStates(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.NmrConstraintStore.conditionStates
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('conditionStates').values()
      result = set(currentValues)

    else:
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('conditionStates').values()
      result = set()
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('details', 'dynamicAlignment', 'name', 'serial', 'staticAlignment', 'access', 'nmrConstraintStore',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result.add(v)

    return result
  
  def findAllConstraintGroups(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.NmrConstraintStore.constraintGroups
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('constraintGroups').values()
      result = set(currentValues)

    else:
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('constraintGroups').values()
      result = set()
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('details', 'serial', 'access', 'nmrConstraintStore',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result.add(v)

    return result
  
  def findAllConstraintLists(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.NmrConstraintStore.constraintLists
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('constraintLists').values()
      result = set(currentValues)

    else:
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('constraintLists').values()
      result = set()
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('details', 'name', 'serial', 'unit', 'usedForCalculation', 'access', 'conditionState', 'method', 'nmrConstraintStore',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result.add(v)

    return result
  
  def findAllDangleChains(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.NmrConstraintStore.dangleChains
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      root = dataDict.get('memopsRoot')
      root.refreshTopObjects('cambridge.Dangle')
      tobjList = root.__dict__.get('dangleStores').values()
      for tobj in tobjList:
        if (not (tobj.__dict__.get('isLoaded'))):
          tobj.load()

      currentValues = dataDict.get('dangleChains')
      result = set(currentValues)

    else:
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      root = dataDict.get('memopsRoot')
      root.refreshTopObjects('cambridge.Dangle')
      tobjList = root.__dict__.get('dangleStores').values()
      for tobj in tobjList:
        if (not (tobj.__dict__.get('isLoaded'))):
          tobj.load()

      currentValues = dataDict.get('dangleChains')
      result = set()
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('access', 'chain', 'dangleStore', 'nmrConstraintStore', 'shiftList',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result.add(v)

    return result
  
  def findAllFixedAtomSets(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.NmrConstraintStore.fixedAtomSets
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('fixedAtomSets').values()
      result = set(currentValues)

    else:
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('fixedAtomSets').values()
      result = set()
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('name', 'serial', 'access', 'nmrConstraintStore',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result.add(v)

    return result
  
  def findAllFixedResonanceSets(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.NmrConstraintStore.fixedResonanceSets
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('fixedResonanceSets').values()
      result = set(currentValues)

    else:
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('fixedResonanceSets').values()
      result = set()
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('serial', 'access', 'nmrConstraintStore',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result.add(v)

    return result
  
  def findAllFixedResonances(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.NmrConstraintStore.fixedResonances
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('fixedResonances').values()
      result = set(currentValues)

    else:
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('fixedResonances').values()
      result = set()
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('details', 'isotopeCode', 'name', 'resonanceSerial', 'serial', 'access', 'nmrConstraintStore', 'resonanceSet',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result.add(v)

    return result
  
  def findAllInputToNmrRuns(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.NmrConstraintStore.inputToNmrRuns
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      root = dataDict.get('memopsRoot')
      root.refreshTopObjects('molsim.NmrSim')
      tobjList = root.__dict__.get('nmrSimStores').values()
      for tobj in tobjList:
        if (not (tobj.__dict__.get('isLoaded'))):
          tobj.load()

      currentValues = dataDict.get('inputToNmrRuns')
      result = set(currentValues)

    else:
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      root = dataDict.get('memopsRoot')
      root.refreshTopObjects('molsim.NmrSim')
      tobjList = root.__dict__.get('nmrSimStores').values()
      for tobj in tobjList:
        if (not (tobj.__dict__.get('isLoaded'))):
          tobj.load()

      currentValues = dataDict.get('inputToNmrRuns')
      result = set()
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('details', 'serial', 'access', 'annealProtocol', 'inputConstraintStore', 'molSystem', 'nmrSimStore', 'outputConstraintStore', 'outputEnsemble',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result.add(v)

    return result
  
  def findAllResStructures(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.NmrConstraintStore.resStructures
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('resStructures').values()
      result = set(currentValues)

    else:
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('resStructures').values()
      result = set()
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('label', 'serial', 'access', 'nmrConstraintStore',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result.add(v)

    return result
  
  def findAllStructureAnalyses(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.NmrConstraintStore.structureAnalyses
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('structureAnalyses')
      result = set(currentValues)

    else:
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('structureAnalyses')
      result = set()
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('details', 'name', 'serial', 'access', 'method', 'nmrConstraintStore', 'nmrProject',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result.add(v)

    return result
  
  def findAllStructureGenerations(self, **conditions):
    """
    FindAll for
    ccp.nmr.NmrConstraint.NmrConstraintStore.structureGenerations
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('structureGenerations')
      result = set(currentValues)

    else:
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('structureGenerations')
      result = set()
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('details', 'generationType', 'name', 'serial', 'access', 'method', 'nmrConstraintStore', 'nmrProject', 'structureEnsemble',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result.add(v)

    return result
  
  def findAllValidationStores(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.NmrConstraintStore.validationStores
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('validationStores')
      result = set(currentValues)

    else:
      currentValues = dataDict.get('validationStores')
      result = set()
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('createdBy', 'guid', 'isModifiable', 'lastUnlockedBy', 'name', 'access', 'memopsRoot', 'nmrConstraintStore', 'nmrProject', 'software', 'structureEnsemble',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result.add(v)

    return result
  
  def findAllViolationLists(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.NmrConstraintStore.violationLists
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('violationLists').values()
      result = set(currentValues)

    else:
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('violationLists').values()
      result = set()
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('details', 'serial', 'access', 'nmrConstraintStore',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result.add(v)

    return result

  findFirstActiveRepository = memops.api.Implementation.TopObject.findFirstActiveRepository
  
  def findFirstAdditionalStructureAnalysis(self, **conditions):
    """
    FindFirst for
    ccp.nmr.NmrConstraint.NmrConstraintStore.additionalStructureAnalyses
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('additionalStructureAnalyses')
      if (currentValues):
        result = iter(currentValues).next()
      else:
        result = None

    else:
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('additionalStructureAnalyses')
      result = None
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('details', 'name', 'serial', 'access', 'method', 'nmrConstraintStore', 'nmrProject',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result = v; break

    return result

  findFirstApplicationData = memops.api.Implementation.DataObject.findFirstApplicationData
  
  def findFirstChainState(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.NmrConstraintStore.chainStates
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('chainStates')
      if (currentValues):
        result = iter(currentValues).next()
      else:
        result = None

    else:
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('chainStates')
      result = None
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('details', 'name', 'serial', 'access', 'chainStateSet',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result = v; break

    return result
  
  def findFirstConditionState(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.NmrConstraintStore.conditionStates
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('conditionStates').values()
      if (currentValues):
        result = iter(currentValues).next()
      else:
        result = None

    else:
      objKey = conditions.get('serial')
      if (objKey is not None):
        if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
          self.load()

        result = dataDict.get('conditionStates').get(objKey)

        if (result is None):
          return result

        elif (len(conditions) <= 1):
          return result

        else:
          currentValues = set()
          currentValues.add(result)

      else:
        if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
          self.load()

        currentValues = dataDict.get('conditionStates').values()

      result = None
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('details', 'dynamicAlignment', 'name', 'serial', 'staticAlignment', 'access', 'nmrConstraintStore',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result = v; break

    return result
  
  def findFirstConstraintGroup(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.NmrConstraintStore.constraintGroups
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('constraintGroups').values()
      if (currentValues):
        result = iter(currentValues).next()
      else:
        result = None

    else:
      objKey = conditions.get('serial')
      if (objKey is not None):
        if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
          self.load()

        result = dataDict.get('constraintGroups').get(objKey)

        if (result is None):
          return result

        elif (len(conditions) <= 1):
          return result

        else:
          currentValues = set()
          currentValues.add(result)

      else:
        if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
          self.load()

        currentValues = dataDict.get('constraintGroups').values()

      result = None
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('details', 'serial', 'access', 'nmrConstraintStore',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result = v; break

    return result
  
  def findFirstConstraintList(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.NmrConstraintStore.constraintLists
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('constraintLists').values()
      if (currentValues):
        result = iter(currentValues).next()
      else:
        result = None

    else:
      objKey = conditions.get('serial')
      if (objKey is not None):
        if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
          self.load()

        result = dataDict.get('constraintLists').get(objKey)

        if (result is None):
          return result

        elif (len(conditions) <= 1):
          return result

        else:
          currentValues = set()
          currentValues.add(result)

      else:
        if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
          self.load()

        currentValues = dataDict.get('constraintLists').values()

      result = None
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('details', 'name', 'serial', 'unit', 'usedForCalculation', 'access', 'conditionState', 'method', 'nmrConstraintStore',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result = v; break

    return result
  
  def findFirstDangleChain(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.NmrConstraintStore.dangleChains
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      root = dataDict.get('memopsRoot')
      root.refreshTopObjects('cambridge.Dangle')
      tobjList = root.__dict__.get('dangleStores').values()
      for tobj in tobjList:
        if (not (tobj.__dict__.get('isLoaded'))):
          tobj.load()

      currentValues = dataDict.get('dangleChains')
      if (currentValues):
        result = iter(currentValues).next()
      else:
        result = None

    else:
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      root = dataDict.get('memopsRoot')
      root.refreshTopObjects('cambridge.Dangle')
      tobjList = root.__dict__.get('dangleStores').values()
      for tobj in tobjList:
        if (not (tobj.__dict__.get('isLoaded'))):
          tobj.load()

      currentValues = dataDict.get('dangleChains')
      result = None
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('access', 'chain', 'dangleStore', 'nmrConstraintStore', 'shiftList',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result = v; break

    return result
  
  def findFirstFixedAtomSet(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.NmrConstraintStore.fixedAtomSets
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('fixedAtomSets').values()
      if (currentValues):
        result = iter(currentValues).next()
      else:
        result = None

    else:
      objKey = conditions.get('serial')
      if (objKey is not None):
        if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
          self.load()

        result = dataDict.get('fixedAtomSets').get(objKey)

        if (result is None):
          return result

        elif (len(conditions) <= 1):
          return result

        else:
          currentValues = set()
          currentValues.add(result)

      else:
        if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
          self.load()

        currentValues = dataDict.get('fixedAtomSets').values()

      result = None
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('name', 'serial', 'access', 'nmrConstraintStore',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result = v; break

    return result
  
  def findFirstFixedResonance(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.NmrConstraintStore.fixedResonances
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('fixedResonances').values()
      if (currentValues):
        result = iter(currentValues).next()
      else:
        result = None

    else:
      objKey = conditions.get('serial')
      if (objKey is not None):
        if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
          self.load()

        result = dataDict.get('fixedResonances').get(objKey)

        if (result is None):
          return result

        elif (len(conditions) <= 1):
          return result

        else:
          currentValues = set()
          currentValues.add(result)

      else:
        if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
          self.load()

        currentValues = dataDict.get('fixedResonances').values()

      result = None
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('details', 'isotopeCode', 'name', 'resonanceSerial', 'serial', 'access', 'nmrConstraintStore', 'resonanceSet',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result = v; break

    return result
  
  def findFirstFixedResonanceSet(self, **conditions):
    """
    FindFirst for
    ccp.nmr.NmrConstraint.NmrConstraintStore.fixedResonanceSets
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('fixedResonanceSets').values()
      if (currentValues):
        result = iter(currentValues).next()
      else:
        result = None

    else:
      objKey = conditions.get('serial')
      if (objKey is not None):
        if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
          self.load()

        result = dataDict.get('fixedResonanceSets').get(objKey)

        if (result is None):
          return result

        elif (len(conditions) <= 1):
          return result

        else:
          currentValues = set()
          currentValues.add(result)

      else:
        if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
          self.load()

        currentValues = dataDict.get('fixedResonanceSets').values()

      result = None
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('serial', 'access', 'nmrConstraintStore',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result = v; break

    return result
  
  def findFirstInputToNmrRun(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.NmrConstraintStore.inputToNmrRuns
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      root = dataDict.get('memopsRoot')
      root.refreshTopObjects('molsim.NmrSim')
      tobjList = root.__dict__.get('nmrSimStores').values()
      for tobj in tobjList:
        if (not (tobj.__dict__.get('isLoaded'))):
          tobj.load()

      currentValues = dataDict.get('inputToNmrRuns')
      if (currentValues):
        result = iter(currentValues).next()
      else:
        result = None

    else:
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      root = dataDict.get('memopsRoot')
      root.refreshTopObjects('molsim.NmrSim')
      tobjList = root.__dict__.get('nmrSimStores').values()
      for tobj in tobjList:
        if (not (tobj.__dict__.get('isLoaded'))):
          tobj.load()

      currentValues = dataDict.get('inputToNmrRuns')
      result = None
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('details', 'serial', 'access', 'annealProtocol', 'inputConstraintStore', 'molSystem', 'nmrSimStore', 'outputConstraintStore', 'outputEnsemble',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result = v; break

    return result
  
  def findFirstResStructure(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.NmrConstraintStore.resStructures
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('resStructures').values()
      if (currentValues):
        result = iter(currentValues).next()
      else:
        result = None

    else:
      objKey = conditions.get('serial')
      if (objKey is not None):
        if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
          self.load()

        result = dataDict.get('resStructures').get(objKey)

        if (result is None):
          return result

        elif (len(conditions) <= 1):
          return result

        else:
          currentValues = set()
          currentValues.add(result)

      else:
        if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
          self.load()

        currentValues = dataDict.get('resStructures').values()

      result = None
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('label', 'serial', 'access', 'nmrConstraintStore',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result = v; break

    return result
  
  def findFirstStructureAnalysis(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.NmrConstraintStore.structureAnalyses
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('structureAnalyses')
      if (currentValues):
        result = iter(currentValues).next()
      else:
        result = None

    else:
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('structureAnalyses')
      result = None
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('details', 'name', 'serial', 'access', 'method', 'nmrConstraintStore', 'nmrProject',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result = v; break

    return result
  
  def findFirstStructureGeneration(self, **conditions):
    """
    FindFirst for
    ccp.nmr.NmrConstraint.NmrConstraintStore.structureGenerations
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('structureGenerations')
      if (currentValues):
        result = iter(currentValues).next()
      else:
        result = None

    else:
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('structureGenerations')
      result = None
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('details', 'generationType', 'name', 'serial', 'access', 'method', 'nmrConstraintStore', 'nmrProject', 'structureEnsemble',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result = v; break

    return result
  
  def findFirstValidationStore(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.NmrConstraintStore.validationStores
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('validationStores')
      if (currentValues):
        result = iter(currentValues).next()
      else:
        result = None

    else:
      currentValues = dataDict.get('validationStores')
      result = None
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('createdBy', 'guid', 'isModifiable', 'lastUnlockedBy', 'name', 'access', 'memopsRoot', 'nmrConstraintStore', 'nmrProject', 'software', 'structureEnsemble',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result = v; break

    return result
  
  def findFirstViolationList(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.NmrConstraintStore.violationLists
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
        self.load()

      currentValues = dataDict.get('violationLists').values()
      if (currentValues):
        result = iter(currentValues).next()
      else:
        result = None

    else:
      objKey = conditions.get('serial')
      if (objKey is not None):
        if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
          self.load()

        result = dataDict.get('violationLists').get(objKey)

        if (result is None):
          return result

        elif (len(conditions) <= 1):
          return result

        else:
          currentValues = set()
          currentValues.add(result)

      else:
        if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
          self.load()

        currentValues = dataDict.get('violationLists').values()

      result = None
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('details', 'serial', 'access', 'nmrConstraintStore',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result = v; break

    return result
  
  def get(self, name):
    """
    GetAttr for ccp.nmr.NmrConstraint.NmrConstraintStore
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getAccess = memops.api.Implementation.DataObject.getAccess

  getActiveRepositories = memops.api.Implementation.TopObject.getActiveRepositories
  
  def getAdditionalStructureAnalyses(self):
    """
    Get for
    ccp.nmr.NmrConstraint.NmrConstraintStore.additionalStructureAnalyses
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    tempVar = dataDict.get('additionalStructureAnalyses')
    result = frozenset(tempVar)
    return result

  getApplicationData = memops.api.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.NmrConstraintStore
    """

    result = None
    if (1 != len(fullKey)):
      raise ApiError("""'ccp.nmr.NmrConstraint.NmrConstraintStore'.getByKey:
       getByKey called with fullKey of wrong length. Parameters:"""
       + ": %s:%s" % (startObj, fullKey)
      )

    objKey = fullKey[0]
    obj1 = startObj.__dict__.get('nmrConstraintStores').get(objKey)
    if (obj1 is None):
      startObj.refreshTopObjects('ccp.nmr.NmrConstraint')
      obj1 = startObj.__dict__.get('nmrConstraintStores').get(objKey)

    result = obj1
    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = memops.api.Implementation.MemopsObject.getByNavigation
  
  def getChainStates(self):
    """
    Get for ccp.nmr.NmrConstraint.NmrConstraintStore.chainStates
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    tempVar = dataDict.get('chainStates')
    result = frozenset(tempVar)
    return result

  getClassName = memops.api.Implementation.ComplexDataType.getClassName
  
  def getConditionStates(self):
    """
    Get for ccp.nmr.NmrConstraint.NmrConstraintStore.conditionStates
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    tempVar = dataDict.get('conditionStates').values()
    result = frozenset(tempVar)
    return result
  
  def getConstraintGroups(self):
    """
    Get for ccp.nmr.NmrConstraint.NmrConstraintStore.constraintGroups
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    tempVar = dataDict.get('constraintGroups').values()
    result = frozenset(tempVar)
    return result
  
  def getConstraintLists(self):
    """
    Get for ccp.nmr.NmrConstraint.NmrConstraintStore.constraintLists
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    tempVar = dataDict.get('constraintLists').values()
    result = frozenset(tempVar)
    return result

  getCreatedBy = memops.api.Implementation.TopObject.getCreatedBy
  
  def getDangleChains(self):
    """
    Get for ccp.nmr.NmrConstraint.NmrConstraintStore.dangleChains
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    root = dataDict.get('memopsRoot')
    root.refreshTopObjects('cambridge.Dangle')
    tobjList = root.__dict__.get('dangleStores').values()
    for tobj in tobjList:
      if (not (tobj.__dict__.get('isLoaded'))):
        tobj.load()

    tempVar = dataDict.get('dangleChains')
    result = frozenset(tempVar)
    return result

  getExpandedKey = memops.api.Implementation.MemopsObject.getExpandedKey

  getFieldNames = memops.api.Implementation.ComplexDataType.getFieldNames
  
  def getFixedAtomSets(self):
    """
    Get for ccp.nmr.NmrConstraint.NmrConstraintStore.fixedAtomSets
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    tempVar = dataDict.get('fixedAtomSets').values()
    result = frozenset(tempVar)
    return result
  
  def getFixedResonanceSets(self):
    """
    Get for ccp.nmr.NmrConstraint.NmrConstraintStore.fixedResonanceSets
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    tempVar = dataDict.get('fixedResonanceSets').values()
    result = frozenset(tempVar)
    return result
  
  def getFixedResonances(self):
    """
    Get for ccp.nmr.NmrConstraint.NmrConstraintStore.fixedResonances
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    tempVar = dataDict.get('fixedResonances').values()
    result = frozenset(tempVar)
    return result
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccp.nmr.NmrConstraint.NmrConstraintStore
    """
    dataDict = self.__dict__
    result = list()

    if (useGuid):
      result.append(dataDict.get('guid'))
    else:
      result.append(dataDict.get('serial'))

    return result

  getGuid = memops.api.Implementation.TopObject.getGuid

  getInConstructor = memops.api.Implementation.ComplexDataType.getInConstructor
  
  def getInputToNmrRuns(self):
    """
    Get for ccp.nmr.NmrConstraint.NmrConstraintStore.inputToNmrRuns
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    root = dataDict.get('memopsRoot')
    root.refreshTopObjects('molsim.NmrSim')
    tobjList = root.__dict__.get('nmrSimStores').values()
    for tobj in tobjList:
      if (not (tobj.__dict__.get('isLoaded'))):
        tobj.load()

    tempVar = dataDict.get('inputToNmrRuns')
    result = frozenset(tempVar)
    return result

  getIsDeleted = memops.api.Implementation.MemopsObject.getIsDeleted

  getIsLoaded = memops.api.Implementation.TopObject.getIsLoaded

  getIsModifiable = memops.api.Implementation.TopObject.getIsModifiable

  getIsModified = memops.api.Implementation.TopObject.getIsModified

  getIsReading = memops.api.Implementation.TopObject.getIsReading

  getLastUnlockedBy = memops.api.Implementation.TopObject.getLastUnlockedBy
  
  def getLocalKey(self):
    """
    GetLocalKey for ccp.nmr.NmrConstraint.NmrConstraintStore
    """
    dataDict = self.__dict__
    result = dataDict.get('serial')
    return result
  
  def getMemopsRoot(self):
    """
    Get for ccp.nmr.NmrConstraint.NmrConstraintStore.memopsRoot
    """
    dataDict = self.__dict__
    result = dataDict.get('memopsRoot')
    return result

  getMetaclass = memops.api.Implementation.ComplexDataType.getMetaclass
  
  def getNmrProject(self):
    """
    Get for ccp.nmr.NmrConstraint.NmrConstraintStore.nmrProject
    """
    dataDict = self.__dict__
    result = dataDict.get('nmrProject')
    return result
  
  def getOutputFromNmrRun(self):
    """
    Get for ccp.nmr.NmrConstraint.NmrConstraintStore.outputFromNmrRun
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    if (dataDict.get('outputFromNmrRun') is None):
      root = dataDict.get('memopsRoot')
      root.refreshTopObjects('molsim.NmrSim')
      tobjList = root.__dict__.get('nmrSimStores').values()
      for tobj in tobjList:
        if (not (tobj.__dict__.get('isLoaded'))):
          tobj.load()

    result = dataDict.get('outputFromNmrRun')
    return result

  getPackageLocator = memops.api.Implementation.TopObject.getPackageLocator

  getPackageName = memops.api.Implementation.ComplexDataType.getPackageName

  getPackageShortName = memops.api.Implementation.ComplexDataType.getPackageShortName
  
  def getParent(self):
    """
    Get for ccp.nmr.NmrConstraint.NmrConstraintStore.parent
    """
    dataDict = self.__dict__
    result = dataDict.get('memopsRoot')
    return result

  getQualifiedName = memops.api.Implementation.ComplexDataType.getQualifiedName
  
  def getResStructures(self):
    """
    Get for ccp.nmr.NmrConstraint.NmrConstraintStore.resStructures
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    tempVar = dataDict.get('resStructures').values()
    result = frozenset(tempVar)
    return result

  getRoot = memops.api.Implementation.MemopsObject.getRoot
  
  def getSerial(self):
    """
    Get for ccp.nmr.NmrConstraint.NmrConstraintStore.serial
    """
    dataDict = self.__dict__
    result = dataDict.get('serial')
    return result
  
  def getStructureAnalyses(self):
    """
    Get for ccp.nmr.NmrConstraint.NmrConstraintStore.structureAnalyses
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    tempVar = dataDict.get('structureAnalyses')
    result = frozenset(tempVar)
    return result
  
  def getStructureGenerations(self):
    """
    Get for ccp.nmr.NmrConstraint.NmrConstraintStore.structureGenerations
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    tempVar = dataDict.get('structureGenerations')
    result = frozenset(tempVar)
    return result

  getTopObject = memops.api.Implementation.DataObject.getTopObject
  
  def getValidationStores(self):
    """
    Get for ccp.nmr.NmrConstraint.NmrConstraintStore.validationStores
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('validationStores')
    result = frozenset(tempVar)
    return result
  
  def getViolationLists(self):
    """
    Get for ccp.nmr.NmrConstraint.NmrConstraintStore.violationLists
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    tempVar = dataDict.get('violationLists').values()
    result = frozenset(tempVar)
    return result

  load = memops.api.Implementation.TopObject.load

  loadFrom = memops.api.Implementation.TopObject.loadFrom
  
  def newChemShiftConstraintList(self, **attrlinks):
    """
    Factory function to create ccp.nmr.NmrConstraint.ChemShiftConstraintList
    """
    return ChemShiftConstraintList(self, **attrlinks)
  
  def newConditionState(self, **attrlinks):
    """
    Factory function to create ccp.nmr.NmrConstraint.ConditionState
    """
    return ConditionState(self, **attrlinks)
  
  def newConstraintGroup(self, **attrlinks):
    """
    Factory function to create ccp.nmr.NmrConstraint.ConstraintGroup
    """
    return ConstraintGroup(self, **attrlinks)
  
  def newCsaConstraintList(self, **attrlinks):
    """
    Factory function to create ccp.nmr.NmrConstraint.CsaConstraintList
    """
    return CsaConstraintList(self, **attrlinks)
  
  def newDihedralConstraintList(self, **attrlinks):
    """
    Factory function to create ccp.nmr.NmrConstraint.DihedralConstraintList
    """
    return DihedralConstraintList(self, **attrlinks)
  
  def newDistanceConstraintList(self, **attrlinks):
    """
    Factory function to create ccp.nmr.NmrConstraint.DistanceConstraintList
    """
    return DistanceConstraintList(self, **attrlinks)
  
  def newFixedAtomSet(self, **attrlinks):
    """
    Factory function to create ccp.nmr.NmrConstraint.FixedAtomSet
    """
    return FixedAtomSet(self, **attrlinks)
  
  def newFixedResonance(self, **attrlinks):
    """
    Factory function to create ccp.nmr.NmrConstraint.FixedResonance
    """
    return FixedResonance(self, **attrlinks)
  
  def newFixedResonanceSet(self, **attrlinks):
    """
    Factory function to create ccp.nmr.NmrConstraint.FixedResonanceSet
    """
    return FixedResonanceSet(self, **attrlinks)
  
  def newHBondConstraintList(self, **attrlinks):
    """
    Factory function to create ccp.nmr.NmrConstraint.HBondConstraintList
    """
    return HBondConstraintList(self, **attrlinks)
  
  def newJCouplingConstraintList(self, **attrlinks):
    """
    Factory function to create ccp.nmr.NmrConstraint.JCouplingConstraintList
    """
    return JCouplingConstraintList(self, **attrlinks)
  
  def newRdcConstraintList(self, **attrlinks):
    """
    Factory function to create ccp.nmr.NmrConstraint.RdcConstraintList
    """
    return RdcConstraintList(self, **attrlinks)
  
  def newResStructure(self, **attrlinks):
    """
    Factory function to create ccp.nmr.NmrConstraint.ResStructure
    """
    return ResStructure(self, **attrlinks)
  
  def newViolationList(self, **attrlinks):
    """
    Factory function to create ccp.nmr.NmrConstraint.ViolationList
    """
    return ViolationList(self, **attrlinks)
  
  def removeAdditionalStructureAnalysis(self, value):
    """
    Remove for
    ccp.nmr.NmrConstraint.NmrConstraintStore.additionalStructureAnalyses
    """
    dataDict = self.__dict__
    from ccp.api.nmr.Nmr import StructureAnalysis as importedType
    if (not isinstance(value, importedType)):
      raise ApiError("""%s.removeAdditionalStructureAnalysis:
       value is not of class ccp.nmr.Nmr.StructureAnalysis""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    currentValues = dataDict.get('additionalStructureAnalyses')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      topObject = value.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)
      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.removeAdditionalStructureAnalysis:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.removeAdditionalStructureAnalysis:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.removeAdditionalStructureAnalysis:
       called with deleted value""" % self.qualifiedName
      )

    if (not (value in currentValues)):
      raise ApiError("""%s.removeAdditionalStructureAnalysis:
       value not in list""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      pass

    oldSelves = value.__dict__.get('additionalConstraintStores')
    oldSelves.remove(self)
    currentValues.remove(value)
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('removeAdditionalStructureAnalysis')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  removeApplicationData = memops.api.Implementation.DataObject.removeApplicationData
  
  def removeChainState(self, value):
    """
    Remove for ccp.nmr.NmrConstraint.NmrConstraintStore.chainStates
    """
    dataDict = self.__dict__
    from ccp.api.nmr.Nmr import ChainState as importedType
    if (not isinstance(value, importedType)):
      raise ApiError("""%s.removeChainState:
       value is not of class ccp.nmr.Nmr.ChainState""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    currentValues = dataDict.get('chainStates')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      topObject = value.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)
      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.removeChainState:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.removeChainState:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.removeChainState:
       called with deleted value""" % self.qualifiedName
      )

    if (not (value in currentValues)):
      raise ApiError("""%s.removeChainState:
       value not in list""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      pass

    oldSelves = value.__dict__.get('nmrConstraintStores')
    oldSelves.remove(self)
    currentValues.remove(value)
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('removeChainState')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  def removeDangleChain(self, value):
    """
    Remove for ccp.nmr.NmrConstraint.NmrConstraintStore.dangleChains
    """
    dataDict = self.__dict__
    from cambridge.api.Dangle import DangleChain as importedType
    if (not isinstance(value, importedType)):
      raise ApiError("""%s.removeDangleChain:
       value is not of class cambridge.Dangle.DangleChain""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    currentValues = dataDict.get('dangleChains')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      topObject = value.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)
      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.removeDangleChain:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.removeDangleChain:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.removeDangleChain:
       called with deleted value""" % self.qualifiedName
      )

    if (not (value in currentValues)):
      raise ApiError("""%s.removeDangleChain:
       value not in list""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      pass

    value.__dict__['nmrConstraintStore'] = None
    currentValues.remove(value)
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('removeDangleChain')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  removeFrom = memops.api.Implementation.TopObject.removeFrom
  
  def removeStructureAnalysis(self, value):
    """
    Remove for ccp.nmr.NmrConstraint.NmrConstraintStore.structureAnalyses
    """
    dataDict = self.__dict__
    from ccp.api.nmr.Nmr import StructureAnalysis as importedType
    if (not isinstance(value, importedType)):
      raise ApiError("""%s.removeStructureAnalysis:
       value is not of class ccp.nmr.Nmr.StructureAnalysis""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    currentValues = dataDict.get('structureAnalyses')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      topObject = value.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)
      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.removeStructureAnalysis:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.removeStructureAnalysis:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.removeStructureAnalysis:
       called with deleted value""" % self.qualifiedName
      )

    if (not (value in currentValues)):
      raise ApiError("""%s.removeStructureAnalysis:
       value not in list""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      pass

    value.__dict__['nmrConstraintStore'] = None
    currentValues.remove(value)
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('removeStructureAnalysis')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  def removeStructureGeneration(self, value):
    """
    Remove for ccp.nmr.NmrConstraint.NmrConstraintStore.structureGenerations
    """
    dataDict = self.__dict__
    from ccp.api.nmr.Nmr import StructureGeneration as importedType
    if (not isinstance(value, importedType)):
      raise ApiError("""%s.removeStructureGeneration:
       value is not of class ccp.nmr.Nmr.StructureGeneration""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    currentValues = dataDict.get('structureGenerations')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      topObject = value.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)
      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.removeStructureGeneration:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.removeStructureGeneration:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.removeStructureGeneration:
       called with deleted value""" % self.qualifiedName
      )

    if (not (value in currentValues)):
      raise ApiError("""%s.removeStructureGeneration:
       value not in list""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      pass

    value.__dict__['nmrConstraintStore'] = None
    currentValues.remove(value)
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('removeStructureGeneration')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  def removeValidationStore(self, value):
    """
    Remove for ccp.nmr.NmrConstraint.NmrConstraintStore.validationStores
    """
    dataDict = self.__dict__
    from ccp.api.molecule.Validation import ValidationStore as importedType
    if (not isinstance(value, importedType)):
      raise ApiError("""%s.removeValidationStore:
       value is not of class ccp.molecule.Validation.ValidationStore""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    currentValues = dataDict.get('validationStores')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      topObject = value.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)
      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.removeValidationStore:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.removeValidationStore:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.removeValidationStore:
       called with deleted value""" % self.qualifiedName
      )

    if (not (value in currentValues)):
      raise ApiError("""%s.removeValidationStore:
       value not in list""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      pass

    value.__dict__['nmrConstraintStore'] = None
    currentValues.remove(value)
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        if (not (topObjectModify.__dict__.get('isLoaded'))):
          topObjectModify.load()

        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('removeValidationStore')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  restore = memops.api.Implementation.TopObject.restore

  save = memops.api.Implementation.TopObject.save

  saveTo = memops.api.Implementation.TopObject.saveTo
  
  def set(self, name, value):
    """
    SetAttr for ccp.nmr.NmrConstraint.NmrConstraintStore
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setAccess = memops.api.Implementation.DataObject.setAccess
  
  def setAdditionalStructureAnalyses(self, values):
    """
    Set for
    ccp.nmr.NmrConstraint.NmrConstraintStore.additionalStructureAnalyses
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setAdditionalStructureAnalyses:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      from ccp.api.nmr.Nmr import StructureAnalysis as importedType
      if (not isinstance(value, importedType)):
        raise ApiError("""%s.setAdditionalStructureAnalyses:
         value is not of class ccp.nmr.Nmr.StructureAnalysis""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    currentValues = dataDict.get('additionalStructureAnalyses')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      for pv in currentValues:
        if (not (pv in values)):
          topObject = pv.__dict__.get('topObject')
          topObjectsToCheck.add(topObject)

      for pv in values:
        if (not (pv in currentValues)):
          topObject = pv.__dict__.get('topObject')
          topObjectsToCheck.add(topObject)

      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setAdditionalStructureAnalyses:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setAdditionalStructureAnalyses:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setAdditionalStructureAnalyses:
         an object in values is deleted""" % self.qualifiedName
        )

    if (values == currentValues):
      return

    if (notOverride):
      xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
      for value in values:
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setAdditionalStructureAnalyses:
           Link additionalStructureAnalyses between objects from separate partitions
           - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    for cv in currentValues:
      if (not (cv in values)):
        oldSelves = cv.__dict__.get('additionalConstraintStores')
        oldSelves.remove(self)

    for cv in values:
      if (not (cv in currentValues)):
        oldSelves = cv.__dict__.get('additionalConstraintStores')
        oldSelves.add(self)

    dataDict['additionalStructureAnalyses'] = values
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setAdditionalStructureAnalyses')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  setApplicationData = memops.api.Implementation.DataObject.setApplicationData
  
  def setChainStates(self, values):
    """
    Set for ccp.nmr.NmrConstraint.NmrConstraintStore.chainStates
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setChainStates:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      from ccp.api.nmr.Nmr import ChainState as importedType
      if (not isinstance(value, importedType)):
        raise ApiError("""%s.setChainStates:
         value is not of class ccp.nmr.Nmr.ChainState""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    currentValues = dataDict.get('chainStates')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      for pv in currentValues:
        if (not (pv in values)):
          topObject = pv.__dict__.get('topObject')
          topObjectsToCheck.add(topObject)

      for pv in values:
        if (not (pv in currentValues)):
          topObject = pv.__dict__.get('topObject')
          topObjectsToCheck.add(topObject)

      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setChainStates:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setChainStates:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setChainStates:
         an object in values is deleted""" % self.qualifiedName
        )

    if (values == currentValues):
      return

    if (notOverride):
      xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
      for value in values:
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setChainStates:
           Link chainStates between objects from separate partitions
           - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      if (notInConstructor):
        for value in values:
          if (not (self.findAllChainStates(chainStateSet=value.chainStateSet) in ((), (value,)))):
            raise ApiError("""%s.setChainStates:
             chainStates constraint only_one_chainState_for_each_chainStateSet violated by value""" % self.qualifiedName
             + ": %s" % (value,)
            )

    for cv in currentValues:
      if (not (cv in values)):
        oldSelves = cv.__dict__.get('nmrConstraintStores')
        oldSelves.remove(self)

    for cv in values:
      if (not (cv in currentValues)):
        oldSelves = cv.__dict__.get('nmrConstraintStores')
        oldSelves.add(self)

    dataDict['chainStates'] = values
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setChainStates')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  setCreatedBy = memops.api.Implementation.TopObject.setCreatedBy
  
  def setDangleChains(self, values):
    """
    Set for ccp.nmr.NmrConstraint.NmrConstraintStore.dangleChains
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setDangleChains:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      from cambridge.api.Dangle import DangleChain as importedType
      if (not isinstance(value, importedType)):
        raise ApiError("""%s.setDangleChains:
         value is not of class cambridge.Dangle.DangleChain""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    currentValues = dataDict.get('dangleChains')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      for pv in currentValues:
        if (not (pv in values)):
          topObject = pv.__dict__.get('topObject')
          topObjectsToCheck.add(topObject)

      for pv in values:
        if (not (pv in currentValues)):
          topObject = pv.__dict__.get('topObject')
          topObjectsToCheck.add(topObject)
          oldSelf = pv.__dict__.get('nmrConstraintStore')
          if (oldSelf is not None):
            if (notIsReading):
              topObject = oldSelf.__dict__.get('topObject')
              topObjectsToCheck.add(topObject)
            else:
              raise ApiError("""%s.setDangleChains:
               Read link incompatible with pre-existing link""" % self.qualifiedName
               + ": %s" % (self,)
              )

      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setDangleChains:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setDangleChains:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setDangleChains:
         an object in values is deleted""" % self.qualifiedName
        )

    if (values == currentValues):
      return

    if (notOverride):
      xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
      for value in values:
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setDangleChains:
           Link dangleChains between objects from separate partitions
           - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    for cv in currentValues:
      if (not (cv in values)):
        cv.__dict__['nmrConstraintStore'] = None

    for cv in values:
      if (not (cv in currentValues)):
        oldSelf = cv.__dict__.get('nmrConstraintStore')
        if (oldSelf is not None):
          vv = oldSelf.__dict__.get('dangleChains')
          vv.remove(cv)

      cv.__dict__['nmrConstraintStore'] = self

    dataDict['dangleChains'] = values
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setDangleChains')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  setGuid = memops.api.Implementation.TopObject.setGuid
  
  def setInputToNmrRuns(self, values):
    """
    Set for ccp.nmr.NmrConstraint.NmrConstraintStore.inputToNmrRuns
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setInputToNmrRuns:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      from molsim.api.NmrSim import Run as importedType
      if (not isinstance(value, importedType)):
        raise ApiError("""%s.setInputToNmrRuns:
         value is not of class molsim.NmrSim.Run""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    currentValues = dataDict.get('inputToNmrRuns')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      for pv in currentValues:
        if (not (pv in values)):
          topObject = pv.__dict__.get('topObject')
          topObjectsToCheck.add(topObject)

      for pv in values:
        if (not (pv in currentValues)):
          topObject = pv.__dict__.get('topObject')
          topObjectsToCheck.add(topObject)
          oldSelf = pv.__dict__.get('inputConstraintStore')
          if (oldSelf is not None):
            if (notIsReading):
              topObject = oldSelf.__dict__.get('topObject')
              topObjectsToCheck.add(topObject)
            else:
              raise ApiError("""%s.setInputToNmrRuns:
               Read link incompatible with pre-existing link""" % self.qualifiedName
               + ": %s" % (self,)
              )

      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setInputToNmrRuns:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setInputToNmrRuns:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setInputToNmrRuns:
         an object in values is deleted""" % self.qualifiedName
        )

    if (values == currentValues):
      return

    if (notOverride):
      for cv in currentValues:
        if (not (cv in values)):
          raise ApiError("""%s.setInputToNmrRuns:
           locard inputConstraintStore: cannot set because some of current values not in values""" % self.qualifiedName
           + ": %s" % (self,)
          )

      xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
      for value in values:
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setInputToNmrRuns:
           Link inputToNmrRuns between objects from separate partitions
           - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    for cv in values:
      cv.__dict__['inputConstraintStore'] = self

    dataDict['inputToNmrRuns'] = values
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setInputToNmrRuns')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  setIsModifiable = memops.api.Implementation.TopObject.setIsModifiable

  setLastUnlockedBy = memops.api.Implementation.TopObject.setLastUnlockedBy
  
  def setNmrProject(self, value):
    """
    Set for ccp.nmr.NmrConstraint.NmrConstraintStore.nmrProject
    """
    dataDict = self.__dict__
    from ccp.api.nmr.Nmr import NmrProject as importedType
    if (not isinstance(value, importedType)):
      raise ApiError("""%s.setNmrProject:
       value is not of class ccp.nmr.Nmr.NmrProject""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    currentValue = dataDict.get('nmrProject')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setNmrProject:
       called on deleted object""" % self.qualifiedName
      )

    if (value is not None):
      if (value.__dict__.get('isDeleted')):
        raise ApiError("""%s.setNmrProject:
         called with deleted value""" % self.qualifiedName
        )

    if (value == currentValue):
      return

    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setNmrProject:
         cannot set nmrProject, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is None):
        raise ApiError("""%s.setNmrProject:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
      yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
      if (not (xx1 is yy1)):
        raise ApiError("""%s.setNmrProject:
         Link nmrProject between objects from separate partitions
         - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
         + ": %s:%s" % (self, value)
        )

    if (currentValue is not None):
      if (notIsReading):
        oldSelves = currentValue.__dict__.get('nmrConstraintStores')
        oldSelves.remove(self)
      else:
        raise ApiError("""%s.setNmrProject:
         Read link 'nmrProject' incompatible with pre-existing link""" % self.qualifiedName
         + ": %s" % (self,)
        )

    if (value is not None):
      newSelves = value.__dict__.get('nmrConstraintStores')
      newSelves.add(self)

    dataDict['nmrProject'] = value

    # doNotifies
  
  def setOutputFromNmrRun(self, value):
    """
    Set for ccp.nmr.NmrConstraint.NmrConstraintStore.outputFromNmrRun
    """
    dataDict = self.__dict__
    if (value is not None):
      from molsim.api.NmrSim import Run as importedType
      if (not isinstance(value, importedType)):
        raise ApiError("""%s.setOutputFromNmrRun:
         value is not of class molsim.NmrSim.Run""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    currentValue = dataDict.get('outputFromNmrRun')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      if (value is not None):
        topObject = value.__dict__.get('topObject')
        topObjectsToCheck.add(topObject)
        oldSelf = value.__dict__.get('outputConstraintStore')
        if (oldSelf is not None):
          if (notIsReading):
            topObject = oldSelf.__dict__.get('topObject')
            topObjectsToCheck.add(topObject)
          else:
            raise ApiError("""%s.setOutputFromNmrRun:
             Read link incompatible with pre-existing link""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (currentValue is not None):
        topObject = currentValue.__dict__.get('topObject')
        topObjectsToCheck.add(topObject)

      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setOutputFromNmrRun:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setOutputFromNmrRun:
       called on deleted object""" % self.qualifiedName
      )

    if (value is not None):
      if (value.__dict__.get('isDeleted')):
        raise ApiError("""%s.setOutputFromNmrRun:
         called with deleted value""" % self.qualifiedName
        )

    if (value == currentValue):
      return

    if (notOverride):
      if (value is not None):
        xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setOutputFromNmrRun:
           Link outputFromNmrRun between objects from separate partitions
           - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    if (currentValue is not None):
      currentValue.__dict__['outputConstraintStore'] = None

    if (value is not None):
      oldSelf = value.__dict__.get('outputConstraintStore')
      if (oldSelf is not None):
        oldSelf.__dict__['outputFromNmrRun'] = None

      value.__dict__['outputConstraintStore'] = self

    dataDict['outputFromNmrRun'] = value
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setOutputFromNmrRun')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  def setSerial(self, value):
    """
    Set for ccp.nmr.NmrConstraint.NmrConstraintStore.serial
    """
    dataDict = self.__dict__
    if (isinstance(value, memops.api.Implementation.Int.PythonType)):
      pass
    elif ([x for x in memops.api.Implementation.Int.compatibleTypes if isinstance(value, x)]):
      value = memops.api.Implementation.Int.create(value)
    else:
      raise ApiError("""%s.setSerial:
       memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    currentValue = dataDict.get('serial')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setSerial:
       called on deleted object""" % self.qualifiedName
      )

    if (value == currentValue):
      return

    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setSerial:
         cannot set serial, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is None):
        raise ApiError("""%s.setSerial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    parent = dataDict.get('memopsRoot')
    oldSerial = parent.__dict__.get('_serialDict').get('nmrConstraintStores')
    if (value < 0):
      value = (oldSerial + 1)
      parent.__dict__.get('_serialDict')['nmrConstraintStores'] = value
    elif (value > oldSerial):
      parent.__dict__.get('_serialDict')['nmrConstraintStores'] = value

    dataDict['serial'] = value

    # doNotifies
  
  def setStructureAnalyses(self, values):
    """
    Set for ccp.nmr.NmrConstraint.NmrConstraintStore.structureAnalyses
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setStructureAnalyses:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      from ccp.api.nmr.Nmr import StructureAnalysis as importedType
      if (not isinstance(value, importedType)):
        raise ApiError("""%s.setStructureAnalyses:
         value is not of class ccp.nmr.Nmr.StructureAnalysis""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    currentValues = dataDict.get('structureAnalyses')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      root = dataDict.get('memopsRoot')
      root.refreshTopObjects('ccp.nmr.NmrConstraint')
      tobjList = set(root.__dict__.get('nmrConstraintStores').values())
      for tobj in tobjList:
        if (not (tobj.__dict__.get('isLoaded'))):
          tobj.load()

    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      for pv in currentValues:
        if (not (pv in values)):
          topObject = pv.__dict__.get('topObject')
          topObjectsToCheck.add(topObject)

      for pv in values:
        if (not (pv in currentValues)):
          topObject = pv.__dict__.get('topObject')
          topObjectsToCheck.add(topObject)
          oldSelf = pv.__dict__.get('nmrConstraintStore')
          if (oldSelf is not None):
            if (notIsReading):
              topObject = oldSelf.__dict__.get('topObject')
              topObjectsToCheck.add(topObject)
            else:
              raise ApiError("""%s.setStructureAnalyses:
               Read link incompatible with pre-existing link""" % self.qualifiedName
               + ": %s" % (self,)
              )

      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setStructureAnalyses:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setStructureAnalyses:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setStructureAnalyses:
         an object in values is deleted""" % self.qualifiedName
        )

    if (values == currentValues):
      return

    if (notOverride):
      xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
      for value in values:
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setStructureAnalyses:
           Link structureAnalyses between objects from separate partitions
           - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    for cv in currentValues:
      if (not (cv in values)):
        cv.__dict__['nmrConstraintStore'] = None

    for cv in values:
      if (not (cv in currentValues)):
        oldSelf = cv.__dict__.get('nmrConstraintStore')
        if (oldSelf is not None):
          vv = oldSelf.__dict__.get('structureAnalyses')
          vv.remove(cv)

      cv.__dict__['nmrConstraintStore'] = self

    dataDict['structureAnalyses'] = values
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setStructureAnalyses')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  def setStructureGenerations(self, values):
    """
    Set for ccp.nmr.NmrConstraint.NmrConstraintStore.structureGenerations
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setStructureGenerations:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      from ccp.api.nmr.Nmr import StructureGeneration as importedType
      if (not isinstance(value, importedType)):
        raise ApiError("""%s.setStructureGenerations:
         value is not of class ccp.nmr.Nmr.StructureGeneration""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    currentValues = dataDict.get('structureGenerations')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      root = dataDict.get('memopsRoot')
      root.refreshTopObjects('ccp.nmr.NmrConstraint')
      tobjList = set(root.__dict__.get('nmrConstraintStores').values())
      for tobj in tobjList:
        if (not (tobj.__dict__.get('isLoaded'))):
          tobj.load()

    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      for pv in currentValues:
        if (not (pv in values)):
          topObject = pv.__dict__.get('topObject')
          topObjectsToCheck.add(topObject)

      for pv in values:
        if (not (pv in currentValues)):
          topObject = pv.__dict__.get('topObject')
          topObjectsToCheck.add(topObject)
          oldSelf = pv.__dict__.get('nmrConstraintStore')
          if (oldSelf is not None):
            if (notIsReading):
              topObject = oldSelf.__dict__.get('topObject')
              topObjectsToCheck.add(topObject)
            else:
              raise ApiError("""%s.setStructureGenerations:
               Read link incompatible with pre-existing link""" % self.qualifiedName
               + ": %s" % (self,)
              )

      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setStructureGenerations:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setStructureGenerations:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setStructureGenerations:
         an object in values is deleted""" % self.qualifiedName
        )

    if (values == currentValues):
      return

    if (notOverride):
      xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
      for value in values:
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setStructureGenerations:
           Link structureGenerations between objects from separate partitions
           - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    for cv in currentValues:
      if (not (cv in values)):
        cv.__dict__['nmrConstraintStore'] = None

    for cv in values:
      if (not (cv in currentValues)):
        oldSelf = cv.__dict__.get('nmrConstraintStore')
        if (oldSelf is not None):
          vv = oldSelf.__dict__.get('structureGenerations')
          vv.remove(cv)

      cv.__dict__['nmrConstraintStore'] = self

    dataDict['structureGenerations'] = values
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setStructureGenerations')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  def setValidationStores(self, values):
    """
    Set for ccp.nmr.NmrConstraint.NmrConstraintStore.validationStores
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setValidationStores:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      from ccp.api.molecule.Validation import ValidationStore as importedType
      if (not isinstance(value, importedType)):
        raise ApiError("""%s.setValidationStores:
         value is not of class ccp.molecule.Validation.ValidationStore""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    currentValues = dataDict.get('validationStores')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = dataDict.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      root = dataDict.get('memopsRoot')
      root.refreshTopObjects('ccp.nmr.NmrConstraint')
      tobjList = set(root.__dict__.get('nmrConstraintStores').values())
      for tobj in tobjList:
        if (not (tobj.__dict__.get('isLoaded'))):
          tobj.load()

    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      for pv in currentValues:
        if (not (pv in values)):
          topObject = pv.__dict__.get('topObject')
          topObjectsToCheck.add(topObject)

      for pv in values:
        if (not (pv in currentValues)):
          topObject = pv.__dict__.get('topObject')
          topObjectsToCheck.add(topObject)
          oldSelf = pv.__dict__.get('nmrConstraintStore')
          if (oldSelf is not None):
            if (notIsReading):
              topObject = oldSelf.__dict__.get('topObject')
              topObjectsToCheck.add(topObject)
            else:
              raise ApiError("""%s.setValidationStores:
               Read link incompatible with pre-existing link""" % self.qualifiedName
               + ": %s" % (self,)
              )

      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setValidationStores:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setValidationStores:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setValidationStores:
         an object in values is deleted""" % self.qualifiedName
        )

    if (values == currentValues):
      return

    if (notOverride):
      xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
      for value in values:
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setValidationStores:
           Link validationStores between objects from separate partitions
           - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      if (notInConstructor):
        for value in values:
          if (not (self.nmrProject is value.nmrProject)):
            raise ApiError("""%s.setValidationStores:
             validationStores constraint self_nmrProject_is_value_nmrProject violated by value""" % self.qualifiedName
             + ": %s" % (value,)
            )

    for cv in currentValues:
      if (not (cv in values)):
        cv.__dict__['nmrConstraintStore'] = None

    for cv in values:
      if (not (cv in currentValues)):
        oldSelf = cv.__dict__.get('nmrConstraintStore')
        if (oldSelf is not None):
          vv = oldSelf.__dict__.get('validationStores')
          vv.remove(cv)

      cv.__dict__['nmrConstraintStore'] = self

    dataDict['validationStores'] = values
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        if (not (topObjectModify.__dict__.get('isLoaded'))):
          topObjectModify.load()

        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setValidationStores')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  def sortedAdditionalStructureAnalyses(self):
    """
    Sorted for
    ccp.nmr.NmrConstraint.NmrConstraintStore.additionalStructureAnalyses
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    ll = dataDict.get('additionalStructureAnalyses')
    ll = [(x.getFullKey(),x) for x in ll]
    
    ll.sort()
    result = [x[1] for x in ll]
    return result
  
  def sortedChainStates(self):
    """
    Sorted for ccp.nmr.NmrConstraint.NmrConstraintStore.chainStates
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    ll = dataDict.get('chainStates')
    ll = [(x.getFullKey(),x) for x in ll]
    
    ll.sort()
    result = [x[1] for x in ll]
    return result
  
  def sortedConditionStates(self):
    """
    Sorted for ccp.nmr.NmrConstraint.NmrConstraintStore.conditionStates
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    sortdd = dataDict.get('conditionStates')
    
    ll = sortdd.keys()
    ll.sort()
    result = [sortdd[x] for x in ll]
    return result
  
  def sortedConstraintGroups(self):
    """
    Sorted for ccp.nmr.NmrConstraint.NmrConstraintStore.constraintGroups
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    sortdd = dataDict.get('constraintGroups')
    
    ll = sortdd.keys()
    ll.sort()
    result = [sortdd[x] for x in ll]
    return result
  
  def sortedConstraintLists(self):
    """
    Sorted for ccp.nmr.NmrConstraint.NmrConstraintStore.constraintLists
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    sortdd = dataDict.get('constraintLists')
    
    ll = sortdd.keys()
    ll.sort()
    result = [sortdd[x] for x in ll]
    return result
  
  def sortedDangleChains(self):
    """
    Sorted for ccp.nmr.NmrConstraint.NmrConstraintStore.dangleChains
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    root = dataDict.get('memopsRoot')
    root.refreshTopObjects('cambridge.Dangle')
    tobjList = root.__dict__.get('dangleStores').values()
    for tobj in tobjList:
      if (not (tobj.__dict__.get('isLoaded'))):
        tobj.load()

    ll = dataDict.get('dangleChains')
    ll = [(x.getFullKey(),x) for x in ll]
    
    ll.sort()
    result = [x[1] for x in ll]
    return result
  
  def sortedFixedAtomSets(self):
    """
    Sorted for ccp.nmr.NmrConstraint.NmrConstraintStore.fixedAtomSets
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    sortdd = dataDict.get('fixedAtomSets')
    
    ll = sortdd.keys()
    ll.sort()
    result = [sortdd[x] for x in ll]
    return result
  
  def sortedFixedResonanceSets(self):
    """
    Sorted for ccp.nmr.NmrConstraint.NmrConstraintStore.fixedResonanceSets
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    sortdd = dataDict.get('fixedResonanceSets')
    
    ll = sortdd.keys()
    ll.sort()
    result = [sortdd[x] for x in ll]
    return result
  
  def sortedFixedResonances(self):
    """
    Sorted for ccp.nmr.NmrConstraint.NmrConstraintStore.fixedResonances
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    sortdd = dataDict.get('fixedResonances')
    
    ll = sortdd.keys()
    ll.sort()
    result = [sortdd[x] for x in ll]
    return result
  
  def sortedInputToNmrRuns(self):
    """
    Sorted for ccp.nmr.NmrConstraint.NmrConstraintStore.inputToNmrRuns
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    root = dataDict.get('memopsRoot')
    root.refreshTopObjects('molsim.NmrSim')
    tobjList = root.__dict__.get('nmrSimStores').values()
    for tobj in tobjList:
      if (not (tobj.__dict__.get('isLoaded'))):
        tobj.load()

    ll = dataDict.get('inputToNmrRuns')
    ll = [(x.getFullKey(),x) for x in ll]
    
    ll.sort()
    result = [x[1] for x in ll]
    return result
  
  def sortedResStructures(self):
    """
    Sorted for ccp.nmr.NmrConstraint.NmrConstraintStore.resStructures
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    sortdd = dataDict.get('resStructures')
    
    ll = sortdd.keys()
    ll.sort()
    result = [sortdd[x] for x in ll]
    return result
  
  def sortedStructureAnalyses(self):
    """
    Sorted for ccp.nmr.NmrConstraint.NmrConstraintStore.structureAnalyses
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    ll = dataDict.get('structureAnalyses')
    ll = [(x.getFullKey(),x) for x in ll]
    
    ll.sort()
    result = [x[1] for x in ll]
    return result
  
  def sortedStructureGenerations(self):
    """
    Sorted for ccp.nmr.NmrConstraint.NmrConstraintStore.structureGenerations
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    ll = dataDict.get('structureGenerations')
    ll = [(x.getFullKey(),x) for x in ll]
    
    ll.sort()
    result = [x[1] for x in ll]
    return result
  
  def sortedValidationStores(self):
    """
    Sorted for ccp.nmr.NmrConstraint.NmrConstraintStore.validationStores
    """
    dataDict = self.__dict__
    ll = dataDict.get('validationStores')
    ll = [(x.getFullKey(),x) for x in ll]
    
    ll.sort()
    result = [x[1] for x in ll]
    return result
  
  def sortedViolationLists(self):
    """
    Sorted for ccp.nmr.NmrConstraint.NmrConstraintStore.violationLists
    """
    dataDict = self.__dict__
    if (not ((dataDict.get('isLoaded') or dataDict.get('isReading')))):
      self.load()

    sortdd = dataDict.get('violationLists')
    
    ll = sortdd.keys()
    ll.sort()
    result = [sortdd[x] for x in ll]
    return result

  toDetailedString = memops.api.Implementation.ComplexDataType.toDetailedString

  touch = memops.api.Implementation.TopObject.touch

  applicationData = memops.api.Implementation.DataObject.applicationData

  className = memops.api.Implementation.ComplexDataType.className

  createdBy = memops.api.Implementation.TopObject.createdBy

  fieldNames = memops.api.Implementation.ComplexDataType.fieldNames

  guid = memops.api.Implementation.TopObject.guid

  inConstructor = memops.api.Implementation.ComplexDataType.inConstructor

  isDeleted = memops.api.Implementation.MemopsObject.isDeleted

  isLoaded = memops.api.Implementation.TopObject.isLoaded

  isModifiable = memops.api.Implementation.TopObject.isModifiable

  isModified = memops.api.Implementation.TopObject.isModified

  isReading = memops.api.Implementation.TopObject.isReading

  lastUnlockedBy = memops.api.Implementation.TopObject.lastUnlockedBy

  metaclass = memops.api.Implementation.ComplexDataType.metaclass

  packageName = memops.api.Implementation.ComplexDataType.packageName

  packageShortName = memops.api.Implementation.ComplexDataType.packageShortName

  qualifiedName = memops.api.Implementation.ComplexDataType.qualifiedName
  
  serial = property(getSerial, setSerial, None,
  r"""Serial number of object. Serves as object main key. Serial numbers of 
  deleted objects are not re-used. Serial numbers can only be set by the 
  implementation. Values are in practice always positive, since negative 
  values are interpreted as a signal to set the next free serial
  """)

  access = memops.api.Implementation.DataObject.access

  activeRepositories = memops.api.Implementation.TopObject.activeRepositories
  
  additionalStructureAnalyses = property(getAdditionalStructureAnalyses, setAdditionalStructureAnalyses, None,
  r"""STructureAnaylsis that use the NmrConstraintStore for additional data
  """)
  
  chainStates = property(getChainStates, setChainStates, None,
  r"""The ChainState of a NmrConstraintStore describes assumptions made during 
  the generation process. For example, if you have two different 
  conformational states of a molecule giving rise to two different sets of 
  restraints, you would select the restraint set corresponding to state A 
  and put in the appropriate link here to reflect it. Note that this link 
  does *not* reflect the conformations actually observed. This link is not 
  for annotating structures.
  """)
  
  conditionStates = property(getConditionStates,  None, None,
  r"""child link to class ConditionState
  """)
  
  constraintGroups = property(getConstraintGroups,  None, None,
  r"""child link to class ConstraintGroup
  """)
  
  constraintLists = property(getConstraintLists,  None, None,
  r"""child link to class AbstractConstraintList
  """)
  
  dangleChains = property(getDangleChains, setDangleChains, None,
  r"""Dangle predictions that have exported constraints to the ConstaintSet
  """)
  
  fixedAtomSets = property(getFixedAtomSets,  None, None,
  r"""child link to class FixedAtomSet
  """)
  
  fixedResonanceSets = property(getFixedResonanceSets,  None, None,
  r"""child link to class FixedResonanceSet
  """)
  
  fixedResonances = property(getFixedResonances,  None, None,
  r"""child link to class FixedResonance
  """)
  
  inputToNmrRuns = property(getInputToNmrRuns, setInputToNmrRuns, None,
  r"""NmrSim.Runs that use this set of NmrConstraints as input
  """)
  
  memopsRoot = property(getMemopsRoot,  None, None,
  r"""parent link
  """)
  
  nmrProject = property(getNmrProject, setNmrProject, None,
  r"""NmrProject to which the NmrConstraintStore refers
  """)
  
  outputFromNmrRun = property(getOutputFromNmrRun, setOutputFromNmrRun, None,
  r"""NmrSim.Run that generated the constraints in the NmrConstraintStore
  """)

  packageLocator = memops.api.Implementation.TopObject.packageLocator
  
  parent = property(getParent, None, None,
  r"""link to parent object - synonym for memopsRoot
  """)
  
  resStructures = property(getResStructures,  None, None,
  r"""ResStructures generated in StructureGeneration run.
  """)

  root = memops.api.Implementation.MemopsObject.root
  
  structureAnalyses = property(getStructureAnalyses, setStructureAnalyses, None,
  r"""StructureAnalyses that user NmrConstraintStore as proimary set of 
  restraints
  """)
  
  structureGenerations = property(getStructureGenerations, setStructureGenerations, None,
  r"""StructureGenerations run with constraints held by NmrConstraintStore
  """)

  topObject = memops.api.Implementation.DataObject.topObject
  
  validationStores = property(getValidationStores, setValidationStores, None,
  r"""NmrConstraintStores relevant to NmrProject
  """)
  
  violationLists = property(getViolationLists,  None, None,
  r"""child link to class ViolationList
  """)

###############################################################################
class PairwiseConstraintItem(memops.api.Implementation.DataObject):
  r"""ConstraintItem that takes an unordered pair of FixedResonances as its 
key
  """
  #   from data model element ccp.nmr.NmrConstraint.PairwiseConstraintItem revision 1.11.2.9
  _metaclass = metaPackage.getElement('PairwiseConstraintItem')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('applicationData', 'className', 'fieldNames', 'inConstructor', 'isDeleted', 'metaclass', 'packageName', 'packageShortName', 'qualifiedName', 'access', 'firstResonance', 'orderedResonances', 'resonances', 'root', 'topObject',)

  __init__ = memops.api.Implementation.ComplexDataType.__init__

  addApplicationData = memops.api.Implementation.DataObject.addApplicationData
  
  def addOrderedResonance(self, value):
    """
    Add for ccp.nmr.NmrConstraint.PairwiseConstraintItem.orderedResonances
    """
    dataDict = self.__dict__
    if (not isinstance(value, FixedResonance)):
      raise ApiError("""%s.addOrderedResonance:
       value is not of class ccp.nmr.NmrConstraint.FixedResonance""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = self.getOrderedResonances()
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.addOrderedResonance:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.addOrderedResonance:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.addOrderedResonance:
       called with deleted value""" % self.qualifiedName
      )

    if (value in currentValues):
      raise ApiError("""%s.addOrderedResonance:
       value is in list already""" % self.qualifiedName
       + ": %s" % (self,)
      )

    currentValues.append(value)
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

  checkAllValid = memops.api.Implementation.ComplexDataType.checkAllValid

  checkValid = memops.api.Implementation.ComplexDataType.checkValid

  delete = memops.api.Implementation.DataObject.delete

  findAllApplicationData = memops.api.Implementation.DataObject.findAllApplicationData
  
  def findAllOrderedResonances(self, **conditions):
    """
    FindAll for
    ccp.nmr.NmrConstraint.PairwiseConstraintItem.orderedResonances
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = self.getOrderedResonances()
      result = list(currentValues)

    else:
      currentValues = self.getOrderedResonances()
      result = list()
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('details', 'isotopeCode', 'name', 'resonanceSerial', 'serial', 'access', 'nmrConstraintStore', 'resonanceSet',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.append(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result.append(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result.append(v)

    return result
  
  def findAllResonances(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.PairwiseConstraintItem.resonances
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('resonances')
      result = set(currentValues)

    else:
      currentValues = dataDict.get('resonances')
      result = set()
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('details', 'isotopeCode', 'name', 'resonanceSerial', 'serial', 'access', 'nmrConstraintStore', 'resonanceSet',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result.add(v)

    return result

  findFirstApplicationData = memops.api.Implementation.DataObject.findFirstApplicationData
  
  def findFirstOrderedResonance(self, **conditions):
    """
    FindFirst for
    ccp.nmr.NmrConstraint.PairwiseConstraintItem.orderedResonances
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = self.getOrderedResonances()
      if (currentValues):
        result = currentValues[0]
      else:
        result = None

    else:
      currentValues = self.getOrderedResonances()
      result = None
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('details', 'isotopeCode', 'name', 'resonanceSerial', 'serial', 'access', 'nmrConstraintStore', 'resonanceSet',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result = v; break

    return result
  
  def findFirstResonance(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.PairwiseConstraintItem.resonances
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('resonances')
      if (currentValues):
        result = iter(currentValues).next()
      else:
        result = None

    else:
      currentValues = dataDict.get('resonances')
      result = None
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('details', 'isotopeCode', 'name', 'resonanceSerial', 'serial', 'access', 'nmrConstraintStore', 'resonanceSet',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result = v; break

    return result

  getAccess = memops.api.Implementation.DataObject.getAccess

  getApplicationData = memops.api.Implementation.DataObject.getApplicationData

  getByNavigation = memops.api.Implementation.MemopsObject.getByNavigation

  getClassName = memops.api.Implementation.ComplexDataType.getClassName

  getExpandedKey = memops.api.Implementation.MemopsObject.getExpandedKey

  getFieldNames = memops.api.Implementation.ComplexDataType.getFieldNames
  
  def getFirstResonance(self):
    """
    Get for ccp.nmr.NmrConstraint.PairwiseConstraintItem.firstResonance
    """
    dataDict = self.__dict__
    result = dataDict.get('firstResonance')
    return result

  getInConstructor = memops.api.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = memops.api.Implementation.MemopsObject.getIsDeleted

  getMetaclass = memops.api.Implementation.ComplexDataType.getMetaclass
  
  def getOrderedResonances(self):
    """
    getter for derived link orderedResonances
    """
    dataDict = self.__dict__
    first = self.firstResonance
    if first:
      result = tuple(self.resonances)
      if first is result[1]:
        result = (result[1], result[0])
    else:
      result = ()
    return result

  getPackageName = memops.api.Implementation.ComplexDataType.getPackageName

  getPackageShortName = memops.api.Implementation.ComplexDataType.getPackageShortName

  getQualifiedName = memops.api.Implementation.ComplexDataType.getQualifiedName
  
  def getResonances(self):
    """
    Get for ccp.nmr.NmrConstraint.PairwiseConstraintItem.resonances
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('resonances')
    result = frozenset(tempVar)
    return result

  getRoot = memops.api.Implementation.MemopsObject.getRoot

  getTopObject = memops.api.Implementation.DataObject.getTopObject

  removeApplicationData = memops.api.Implementation.DataObject.removeApplicationData
  
  def removeOrderedResonance(self, value):
    """
    Remove for
    ccp.nmr.NmrConstraint.PairwiseConstraintItem.orderedResonances
    """
    dataDict = self.__dict__
    if (not isinstance(value, FixedResonance)):
      raise ApiError("""%s.removeOrderedResonance:
       value is not of class ccp.nmr.NmrConstraint.FixedResonance""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = self.getOrderedResonances()
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.removeOrderedResonance:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.removeOrderedResonance:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.removeOrderedResonance:
       called with deleted value""" % self.qualifiedName
      )

    if (not (value in currentValues)):
      raise ApiError("""%s.removeOrderedResonance:
       value not in list""" % self.qualifiedName
       + ": %s" % (self,)
      )

    currentValues.remove(value)
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

  setAccess = memops.api.Implementation.DataObject.setAccess

  setApplicationData = memops.api.Implementation.DataObject.setApplicationData
  
  def setFirstResonance(self, value):
    """
    Set for ccp.nmr.NmrConstraint.PairwiseConstraintItem.firstResonance
    """
    dataDict = self.__dict__
    if (value is not None):
      if (not isinstance(value, FixedResonance)):
        raise ApiError("""%s.setFirstResonance:
         value is not of class ccp.nmr.NmrConstraint.FixedResonance""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('firstResonance')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setFirstResonance:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setFirstResonance:
       called on deleted object""" % self.qualifiedName
      )

    if (value is not None):
      if (value.__dict__.get('isDeleted')):
        raise ApiError("""%s.setFirstResonance:
         called with deleted value""" % self.qualifiedName
        )

    if (value == currentValue):
      return

    if (notOverride):
      if (value is not None):
        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setFirstResonance:
           Link firstResonance between objects from separate partitions
           - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      if (notInConstructor):
        if (value is not None):
          if (not (value in self.resonances)):
            raise ApiError("""%s.setFirstResonance:
             firstResonance constraint FirstResonance_must_be_in_resonances violated by value""" % self.qualifiedName
             + ": %s" % (value,)
            )

    dataDict['firstResonance'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setFirstResonance')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  def setOrderedResonances(self, values):
    """
    getter for derived link orderedResonances
    """
    dataDict = self.__dict__
    xx = set(values)
    values = list(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setOrderedResonances:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      if (not isinstance(value, FixedResonance)):
        raise ApiError("""%s.setOrderedResonances:
         value is not of class ccp.nmr.NmrConstraint.FixedResonance""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = self.getOrderedResonances()
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setOrderedResonances:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setOrderedResonances:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setOrderedResonances:
         an object in values is deleted""" % self.qualifiedName
        )

    if (values == currentValues):
      return

    self.resonances = values
    for val in values:
      break
    self.firstResonance = val
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

  def setResonances(self, values):
    """
    Set for ccp.nmr.NmrConstraint.PairwiseConstraintItem.resonances
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setResonances:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      if (not isinstance(value, FixedResonance)):
        raise ApiError("""%s.setResonances:
         value is not of class ccp.nmr.NmrConstraint.FixedResonance""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('resonances')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setResonances:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setResonances:
         an object in values is deleted""" % self.qualifiedName
        )

    if (values == currentValues):
      return

    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setResonances:
         cannot set resonances, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (not (len(values) == 2)):
        raise ApiError("""%s.setResonances:
         locard, hicard: values must be of length == 2""" % self.qualifiedName
         + ": %s" % (self,)
        )

      xx1 = dataDict.get('topObject')
      for value in values:
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setResonances:
           Link resonances between objects from separate partitions
           - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    for cv in currentValues:
      if (not (cv in values)):
        oldSelves = cv.__dict__.get('pairwiseConstraintItems')
        oldSelves.remove(self)

    for cv in values:
      if (not (cv in currentValues)):
        oldSelves = cv.__dict__.get('pairwiseConstraintItems')
        oldSelves.add(self)

    dataDict['resonances'] = values

    # doNotifies
  
  def sortedResonances(self):
    """
    Sorted for ccp.nmr.NmrConstraint.PairwiseConstraintItem.resonances
    """
    dataDict = self.__dict__
    ll = dataDict.get('resonances')
    ll = [(x.getFullKey(),x) for x in ll]
    
    ll.sort()
    result = [x[1] for x in ll]
    return result

  toDetailedString = memops.api.Implementation.ComplexDataType.toDetailedString

  applicationData = memops.api.Implementation.DataObject.applicationData

  className = memops.api.Implementation.ComplexDataType.className

  fieldNames = memops.api.Implementation.ComplexDataType.fieldNames

  inConstructor = memops.api.Implementation.ComplexDataType.inConstructor

  isDeleted = memops.api.Implementation.MemopsObject.isDeleted

  metaclass = memops.api.Implementation.ComplexDataType.metaclass

  packageName = memops.api.Implementation.ComplexDataType.packageName

  packageShortName = memops.api.Implementation.ComplexDataType.packageShortName

  qualifiedName = memops.api.Implementation.ComplexDataType.qualifiedName

  access = memops.api.Implementation.DataObject.access
  
  firstResonance = property(getFirstResonance, setFirstResonance, None,
  r"""First resonance of the two in 'resonances'. Used to define ordering of 
  resonances. 
  """)
  
  orderedResonances = property(getOrderedResonances, setOrderedResonances, None,
  r"""Resonance pair in order. Optional, as order may not be defined.
  """)
  
  resonances = property(getResonances, setResonances, None,
  r"""Pair of resonances constrained in the PairWiseConstraint
  """)

  root = memops.api.Implementation.MemopsObject.root

  topObject = memops.api.Implementation.DataObject.topObject

###############################################################################
class ResCoord(memops.api.Implementation.DataObject):
  r"""Coordinate record for ResStructure. Linked to FIxedResonance.
  """
  #   from data model element ccp.nmr.NmrConstraint.ResCoord revision 1.36.2.9
  _metaclass = metaPackage.getElement('ResCoord')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('applicationData', 'className', 'fieldNames', 'inConstructor', 'isDeleted', 'metaclass', 'packageName', 'packageShortName', 'qualifiedName', 'x', 'y', 'z', 'access', 'parent', 'resonance', 'root', 'structure', 'topObject',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccp.nmr.NmrConstraint.ResCoord
    """
    dataDict = self.__dict__
    dataDict['structure'] = parent
    if (not isinstance(parent, ResStructure)):
      raise ApiError("""%s.__init__:
       value is not of class ccp.nmr.NmrConstraint.ResStructure""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:

      dataDict['applicationData'] = list()
      dataDict['x'] = None
      dataDict['y'] = None
      dataDict['z'] = None
      dataDict['access'] = None
      dataDict['resonance'] = None

      dataDict['inConstructor'] = True
      try:
        
        for key, value in attrlinks.iteritems():
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        del dataDict['inConstructor']
      except:
        print "ERROR in ccp.nmr.NmrConstraint.ResCoord.__init__"
        del dataDict['inConstructor']
        raise

      if (notIsReading):
        childrenDict = parent.__dict__.get('coords')
        objKey = dataDict.get('resonance')
        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['resonance'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        print '''WARNING Error in clean-up of incorrectly created object. 
        Data may be left in an illegal state'''
        del dataDict['inConstructor']
      raise exc_info[0], exc_info[1], exc_info[2]

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccp.nmr.NmrConstraint.ResCoord:
       determines cascading 
    deletes to follow from delete of object.
       *Implementation function* - 
    should be called only by API delete function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
      dataDict.get('topObject').load()

    access = dataDict.get('access')
    if (access is not None):
      topObject = access.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccp.nmr.NmrConstraint.ResCoord:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    access = dataDict.get('access')
    if ((access is not None and not (access in objsToBeDeleted))):
      dataObjects = access.__dict__.get('dataObjects')
      dataObjects.remove(self)

    resonance = dataDict.get('resonance')
    if ((resonance is not None and not (resonance in objsToBeDeleted))):
      resCoords = resonance.__dict__.get('resCoords')
      resCoords.remove(self)

    structure = dataDict.get('structure')
    if (not (structure in objsToBeDeleted)):
      objKey = dataDict.get('resonance')
      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = structure.__dict__.get('coords')
        if (self is dd.get(objKey)):
          del dd[objKey]

  addApplicationData = memops.api.Implementation.DataObject.addApplicationData
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccp.nmr.NmrConstraint.ResCoord
    """
    dataDict = self.__dict__
    self.checkValid(complete)
  
  def checkValid(self, complete=False):
    """
    CheckValid for ccp.nmr.NmrConstraint.ResCoord
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('resonance')
      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('structure')
        dd = value.__dict__.get('coords')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'structure' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from memops.api.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, memops.api.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('x')
      if (value is not None):
        if (isinstance(value, memops.api.Implementation.Float.PythonType)):
          pass
        elif ([x for x in memops.api.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = memops.api.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: x:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: x:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('y')
      if (value is not None):
        if (isinstance(value, memops.api.Implementation.Float.PythonType)):
          pass
        elif ([x for x in memops.api.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = memops.api.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: y:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: y:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('z')
      if (value is not None):
        if (isinstance(value, memops.api.Implementation.Float.PythonType)):
          pass
        elif ([x for x in memops.api.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = memops.api.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: z:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: z:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      # check roles
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('access')
      if (value is not None):
        from memops.api.AccessControl import AccessObject as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: access:
           value is not of class memops.AccessControl.AccessObject""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('dataObjects')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: access:
           non-reciprocal link ResCoord from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      value = dataDict.get('resonance')
      if (not isinstance(value, FixedResonance)):
        raise ApiError("""%s.checkValid: resonance:
         value is not of class ccp.nmr.NmrConstraint.FixedResonance""" % self.qualifiedName
         + ": %s" % (value,)
        )

      oldSelves = value.__dict__.get('resCoords')
      if (not (self in oldSelves)):
        raise ApiError("""%s.checkValid: resonance:
         non-reciprocal link ResCoord from object""" % self.qualifiedName
         + ": %s" % (self,)
        )

      value = dataDict.get('structure')
      if (not isinstance(value, ResStructure)):
        raise ApiError("""%s.checkValid: structure:
         value is not of class ccp.nmr.NmrConstraint.ResStructure""" % self.qualifiedName
         + ": %s" % (value,)
        )

    # check explicit class constraints
    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('x')
    value = dataDict.get('y')
    value = dataDict.get('z')
    # check roles
    value = dataDict.get('access')
    value = dataDict.get('resonance')
    if (value is None):
      raise ApiError("""%s.checkValid: resonance:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    value = dataDict.get('structure')
    if (value is None):
      raise ApiError("""%s.checkValid: structure:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

  delete = memops.api.Implementation.DataObject.delete

  findAllApplicationData = memops.api.Implementation.DataObject.findAllApplicationData

  findFirstApplicationData = memops.api.Implementation.DataObject.findFirstApplicationData
  
  def get(self, name):
    """
    GetAttr for ccp.nmr.NmrConstraint.ResCoord
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getAccess = memops.api.Implementation.DataObject.getAccess

  getApplicationData = memops.api.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.ResCoord
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (3 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.ResCoord'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (2 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.ResCoord'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-2]
      obj2 = obj1.__dict__.get('resStructures').get(objKey)

      if (obj2 is not None):
        objKey = fullKey[-1]
        obj3 = obj2.__dict__.get('coords').get(objKey)
        result = obj3

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = memops.api.Implementation.MemopsObject.getByNavigation

  getClassName = memops.api.Implementation.ComplexDataType.getClassName

  getExpandedKey = memops.api.Implementation.MemopsObject.getExpandedKey

  getFieldNames = memops.api.Implementation.ComplexDataType.getFieldNames
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccp.nmr.NmrConstraint.ResCoord
    """
    dataDict = self.__dict__
    result = list()

    obj2 = dataDict.get('structure')
    obj1 = obj2.__dict__.get('nmrConstraintStore')

    if (useGuid):
      result.append(obj1.__dict__.get('guid'))
    else:
      result.append(obj1.__dict__.get('serial'))

    result.append(obj2.__dict__.get('serial'))
    result.append(dataDict.get('resonance'))

    return result

  getInConstructor = memops.api.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = memops.api.Implementation.MemopsObject.getIsDeleted
  
  def getLocalKey(self):
    """
    GetLocalKey for ccp.nmr.NmrConstraint.ResCoord
    """
    dataDict = self.__dict__
    result = dataDict.get('resonance')
    return result

  getMetaclass = memops.api.Implementation.ComplexDataType.getMetaclass

  getPackageName = memops.api.Implementation.ComplexDataType.getPackageName

  getPackageShortName = memops.api.Implementation.ComplexDataType.getPackageShortName
  
  def getParent(self):
    """
    Get for ccp.nmr.NmrConstraint.ResCoord.parent
    """
    dataDict = self.__dict__
    result = dataDict.get('structure')
    return result

  getQualifiedName = memops.api.Implementation.ComplexDataType.getQualifiedName
  
  def getResonance(self):
    """
    Get for ccp.nmr.NmrConstraint.ResCoord.resonance
    """
    dataDict = self.__dict__
    result = dataDict.get('resonance')
    return result

  getRoot = memops.api.Implementation.MemopsObject.getRoot
  
  def getStructure(self):
    """
    Get for ccp.nmr.NmrConstraint.ResCoord.structure
    """
    dataDict = self.__dict__
    result = dataDict.get('structure')
    return result

  getTopObject = memops.api.Implementation.DataObject.getTopObject
  
  def getX(self):
    """
    Get for ccp.nmr.NmrConstraint.ResCoord.x
    """
    dataDict = self.__dict__
    result = dataDict.get('x')
    return result
  
  def getY(self):
    """
    Get for ccp.nmr.NmrConstraint.ResCoord.y
    """
    dataDict = self.__dict__
    result = dataDict.get('y')
    return result
  
  def getZ(self):
    """
    Get for ccp.nmr.NmrConstraint.ResCoord.z
    """
    dataDict = self.__dict__
    result = dataDict.get('z')
    return result

  removeApplicationData = memops.api.Implementation.DataObject.removeApplicationData
  
  def set(self, name, value):
    """
    SetAttr for ccp.nmr.NmrConstraint.ResCoord
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setAccess = memops.api.Implementation.DataObject.setAccess

  setApplicationData = memops.api.Implementation.DataObject.setApplicationData
  
  def setResonance(self, value):
    """
    Set for ccp.nmr.NmrConstraint.ResCoord.resonance
    """
    dataDict = self.__dict__
    if (not isinstance(value, FixedResonance)):
      raise ApiError("""%s.setResonance:
       value is not of class ccp.nmr.NmrConstraint.FixedResonance""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('resonance')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setResonance:
       called on deleted object""" % self.qualifiedName
      )

    if (value is not None):
      if (value.__dict__.get('isDeleted')):
        raise ApiError("""%s.setResonance:
         called with deleted value""" % self.qualifiedName
        )

    if (value == currentValue):
      return

    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setResonance:
         cannot set resonance, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is None):
        raise ApiError("""%s.setResonance:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      xx1 = dataDict.get('topObject')
      yy1 = value.__dict__.get('topObject')
      if (not (xx1 is yy1)):
        raise ApiError("""%s.setResonance:
         Link resonance between objects from separate partitions
         - memops.Implementation.TopObject does not match""" % self.qualifiedName
         + ": %s:%s" % (self, value)
        )

    if (currentValue is not None):
      if (notIsReading):
        oldSelves = currentValue.__dict__.get('resCoords')
        oldSelves.remove(self)
      else:
        raise ApiError("""%s.setResonance:
         Read link 'resonance' incompatible with pre-existing link""" % self.qualifiedName
         + ": %s" % (self,)
        )

    if (value is not None):
      newSelves = value.__dict__.get('resCoords')
      newSelves.add(self)

    dataDict['resonance'] = value

    # doNotifies
  
  def setX(self, value):
    """
    Set for ccp.nmr.NmrConstraint.ResCoord.x
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, memops.api.Implementation.Float.PythonType)):
        pass
      elif ([x for x in memops.api.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = memops.api.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.setX:
         memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.setX:
         Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('x')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setX:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setX:
       called on deleted object""" % self.qualifiedName
      )

    if (value == currentValue):
      return

    if (notOverride):
      pass

    dataDict['x'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setX')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  def setY(self, value):
    """
    Set for ccp.nmr.NmrConstraint.ResCoord.y
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, memops.api.Implementation.Float.PythonType)):
        pass
      elif ([x for x in memops.api.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = memops.api.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.setY:
         memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.setY:
         Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('y')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setY:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setY:
       called on deleted object""" % self.qualifiedName
      )

    if (value == currentValue):
      return

    if (notOverride):
      pass

    dataDict['y'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setY')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  def setZ(self, value):
    """
    Set for ccp.nmr.NmrConstraint.ResCoord.z
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, memops.api.Implementation.Float.PythonType)):
        pass
      elif ([x for x in memops.api.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = memops.api.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.setZ:
         memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.setZ:
         Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('z')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setZ:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setZ:
       called on deleted object""" % self.qualifiedName
      )

    if (value == currentValue):
      return

    if (notOverride):
      pass

    dataDict['z'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setZ')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  toDetailedString = memops.api.Implementation.ComplexDataType.toDetailedString

  applicationData = memops.api.Implementation.DataObject.applicationData

  className = memops.api.Implementation.ComplexDataType.className

  fieldNames = memops.api.Implementation.ComplexDataType.fieldNames

  inConstructor = memops.api.Implementation.ComplexDataType.inConstructor

  isDeleted = memops.api.Implementation.MemopsObject.isDeleted

  metaclass = memops.api.Implementation.ComplexDataType.metaclass

  packageName = memops.api.Implementation.ComplexDataType.packageName

  packageShortName = memops.api.Implementation.ComplexDataType.packageShortName

  qualifiedName = memops.api.Implementation.ComplexDataType.qualifiedName
  
  x = property(getX, setX, None,
  r"""X coordinate
  """)
  
  y = property(getY, setY, None,
  r"""Y coordinate
  """)
  
  z = property(getZ, setZ, None,
  r"""Z coordinate
  """)

  access = memops.api.Implementation.DataObject.access
  
  parent = property(getParent, None, None,
  r"""link to parent object - synonym for structure
  """)
  
  resonance = property(getResonance, setResonance, None,
  r"""FixedResonance to which ResCoords apply.
  """)

  root = memops.api.Implementation.MemopsObject.root
  
  structure = property(getStructure,  None, None,
  r"""parent link
  """)

  topObject = memops.api.Implementation.DataObject.topObject

###############################################################################
class ResStructure(memops.api.Implementation.DataObject):
  r"""Molecule Structure with coordinates assigned to Resonances rather than 
Atoms. Intended for protocols that generate 3D structures without 
(complete) assignment. 
  """
  #   from data model element ccp.nmr.NmrConstraint.ResStructure revision 1.37.2.9
  _metaclass = metaPackage.getElement('ResStructure')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('applicationData', 'className', 'fieldNames', 'inConstructor', 'isDeleted', 'label', 'metaclass', 'packageName', 'packageShortName', 'qualifiedName', 'serial', 'access', 'coords', 'nmrConstraintStore', 'parent', 'root', 'topObject',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccp.nmr.NmrConstraint.ResStructure
    """
    dataDict = self.__dict__
    dataDict['nmrConstraintStore'] = parent
    if (not isinstance(parent, NmrConstraintStore)):
      raise ApiError("""%s.__init__:
       value is not of class ccp.nmr.NmrConstraint.NmrConstraintStore""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:
      if (not ((parent.__dict__.get('isLoaded') or parent.__dict__.get('isReading')))):
        parent.load()

      dataDict['applicationData'] = list()
      dataDict['label'] = None
      dataDict['serial'] = None
      dataDict['access'] = None
      dataDict['coords'] = {}

      dataDict['inConstructor'] = True
      try:
        
        for key, value in attrlinks.iteritems():
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        del dataDict['inConstructor']
      except:
        print "ERROR in ccp.nmr.NmrConstraint.ResStructure.__init__"
        del dataDict['inConstructor']
        raise

      if (notOverride):
        if (dataDict.get('serial') is None):
          dataDict['inConstructor'] = True
          self.setSerial(-1)
          del dataDict['inConstructor']
        else:
          raise ApiError("""%s.__init__:
           Cannot pass in explicit serial if not reading""" % self.qualifiedName
           + ": %s:%s" % (parent, 'ccp.nmr.NmrConstraint.ResStructure')
          )

      if (notIsReading):
        childrenDict = parent.__dict__.get('resStructures')
        objKey = dataDict.get('serial')
        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['serial'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        print '''WARNING Error in clean-up of incorrectly created object. 
        Data may be left in an illegal state'''
        del dataDict['inConstructor']
      raise exc_info[0], exc_info[1], exc_info[2]

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccp.nmr.NmrConstraint.ResStructure:
       determines 
    cascading deletes to follow from delete of object.
       *Implementation 
    function* - should be called only by API delete function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
      dataDict.get('topObject').load()

    access = dataDict.get('access')
    if (access is not None):
      topObject = access.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    coords = dataDict.get('coords').values()
    for coord in coords:
      if (not (coord in objsToBeDeleted)):
        objsToBeDeleted.add(coord)
        objsToBeChecked.append(coord)

    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccp.nmr.NmrConstraint.ResStructure:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    access = dataDict.get('access')
    if ((access is not None and not (access in objsToBeDeleted))):
      dataObjects = access.__dict__.get('dataObjects')
      dataObjects.remove(self)

    nmrConstraintStore = dataDict.get('nmrConstraintStore')
    if (not (nmrConstraintStore in objsToBeDeleted)):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = nmrConstraintStore.__dict__.get('resStructures')
        if (self is dd.get(objKey)):
          del dd[objKey]

  addApplicationData = memops.api.Implementation.DataObject.addApplicationData
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccp.nmr.NmrConstraint.ResStructure
    """
    dataDict = self.__dict__
    self.checkValid(complete)
    values = dataDict.get('coords').values()
    for value in values:
      value.checkAllValid(complete)

  def checkValid(self, complete=False):
    """
    CheckValid for ccp.nmr.NmrConstraint.ResStructure
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('nmrConstraintStore')
        dd = value.__dict__.get('resStructures')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'nmrConstraintStore' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from memops.api.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('label')
      if (value is not None):
        if (isinstance(value, memops.api.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: label:
           memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 80):
          raise ApiError("""%s.checkValid: label:
           memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: label:
           memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.splitlines()) <= 1)):
          raise ApiError("""%s.checkValid: label:
           Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, memops.api.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('serial')
      if (value is None):
        raise ApiError("""%s.checkValid: serial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, memops.api.Implementation.Int.PythonType)):
        pass
      elif ([x for x in memops.api.Implementation.Int.compatibleTypes if isinstance(value, x)]):
        value = memops.api.Implementation.Int.create(value)
      else:
        raise ApiError("""%s.checkValid: serial:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('access')
      if (value is not None):
        from memops.api.AccessControl import AccessObject as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: access:
           value is not of class memops.AccessControl.AccessObject""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('dataObjects')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: access:
           non-reciprocal link ResStructure from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('coords').values()
      for value in values:
        if (not isinstance(value, ResCoord)):
          raise ApiError("""%s.checkValid: coords:
           value is not of class ccp.nmr.NmrConstraint.ResCoord""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('structure')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: coords:
           non-reciprocal link ResStructure from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      value = dataDict.get('nmrConstraintStore')
      if (not isinstance(value, NmrConstraintStore)):
        raise ApiError("""%s.checkValid: nmrConstraintStore:
         value is not of class ccp.nmr.NmrConstraint.NmrConstraintStore""" % self.qualifiedName
         + ": %s" % (value,)
        )

    # check explicit class constraints
    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('label')
    # check roles
    value = dataDict.get('access')
    values = dataDict.get('coords').values()
    value = dataDict.get('nmrConstraintStore')
    if (value is None):
      raise ApiError("""%s.checkValid: nmrConstraintStore:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

  delete = memops.api.Implementation.DataObject.delete

  findAllApplicationData = memops.api.Implementation.DataObject.findAllApplicationData
  
  def findAllCoords(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.ResStructure.coords
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('coords').values()
      result = set(currentValues)

    else:
      currentValues = dataDict.get('coords').values()
      result = set()
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('x', 'y', 'z', 'access', 'resonance', 'structure',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result.add(v)

    return result

  findFirstApplicationData = memops.api.Implementation.DataObject.findFirstApplicationData
  
  def findFirstCoord(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.ResStructure.coords
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('coords').values()
      if (currentValues):
        result = iter(currentValues).next()
      else:
        result = None

    else:
      objKey = conditions.get('resonance')
      if (objKey is not None):
        result = dataDict.get('coords').get(objKey)

        if (result is None):
          return result

        elif (len(conditions) <= 1):
          return result

        else:
          currentValues = set()
          currentValues.add(result)

      else:
        currentValues = dataDict.get('coords').values()

      result = None
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('x', 'y', 'z', 'access', 'resonance', 'structure',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result = v; break

    return result
  
  def get(self, name):
    """
    GetAttr for ccp.nmr.NmrConstraint.ResStructure
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getAccess = memops.api.Implementation.DataObject.getAccess

  getApplicationData = memops.api.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.ResStructure
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (2 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.ResStructure'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (1 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.ResStructure'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-1]
      obj2 = obj1.__dict__.get('resStructures').get(objKey)
      result = obj2

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = memops.api.Implementation.MemopsObject.getByNavigation

  getClassName = memops.api.Implementation.ComplexDataType.getClassName
  
  def getCoords(self):
    """
    Get for ccp.nmr.NmrConstraint.ResStructure.coords
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('coords').values()
    result = frozenset(tempVar)
    return result

  getExpandedKey = memops.api.Implementation.MemopsObject.getExpandedKey

  getFieldNames = memops.api.Implementation.ComplexDataType.getFieldNames
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccp.nmr.NmrConstraint.ResStructure
    """
    dataDict = self.__dict__
    result = list()

    obj1 = dataDict.get('nmrConstraintStore')

    if (useGuid):
      result.append(obj1.__dict__.get('guid'))
    else:
      result.append(obj1.__dict__.get('serial'))

    result.append(dataDict.get('serial'))

    return result

  getInConstructor = memops.api.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = memops.api.Implementation.MemopsObject.getIsDeleted
  
  def getLabel(self):
    """
    Get for ccp.nmr.NmrConstraint.ResStructure.label
    """
    dataDict = self.__dict__
    result = dataDict.get('label')
    return result
  
  def getLocalKey(self):
    """
    GetLocalKey for ccp.nmr.NmrConstraint.ResStructure
    """
    dataDict = self.__dict__
    result = dataDict.get('serial')
    return result

  getMetaclass = memops.api.Implementation.ComplexDataType.getMetaclass
  
  def getNmrConstraintStore(self):
    """
    Get for ccp.nmr.NmrConstraint.ResStructure.nmrConstraintStore
    """
    dataDict = self.__dict__
    result = dataDict.get('nmrConstraintStore')
    return result

  getPackageName = memops.api.Implementation.ComplexDataType.getPackageName

  getPackageShortName = memops.api.Implementation.ComplexDataType.getPackageShortName
  
  def getParent(self):
    """
    Get for ccp.nmr.NmrConstraint.ResStructure.parent
    """
    dataDict = self.__dict__
    result = dataDict.get('nmrConstraintStore')
    return result

  getQualifiedName = memops.api.Implementation.ComplexDataType.getQualifiedName

  getRoot = memops.api.Implementation.MemopsObject.getRoot
  
  def getSerial(self):
    """
    Get for ccp.nmr.NmrConstraint.ResStructure.serial
    """
    dataDict = self.__dict__
    result = dataDict.get('serial')
    return result

  getTopObject = memops.api.Implementation.DataObject.getTopObject
  
  def newResCoord(self, **attrlinks):
    """
    Factory function to create ccp.nmr.NmrConstraint.ResCoord
    """
    return ResCoord(self, **attrlinks)

  removeApplicationData = memops.api.Implementation.DataObject.removeApplicationData
  
  def set(self, name, value):
    """
    SetAttr for ccp.nmr.NmrConstraint.ResStructure
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setAccess = memops.api.Implementation.DataObject.setAccess

  setApplicationData = memops.api.Implementation.DataObject.setApplicationData
  
  def setLabel(self, value):
    """
    Set for ccp.nmr.NmrConstraint.ResStructure.label
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, memops.api.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.setLabel:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.setLabel:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.setLabel:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.setLabel:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('label')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setLabel:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setLabel:
       called on deleted object""" % self.qualifiedName
      )

    if (value == currentValue):
      return

    if (notOverride):
      pass

    dataDict['label'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setLabel')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  def setSerial(self, value):
    """
    Set for ccp.nmr.NmrConstraint.ResStructure.serial
    """
    dataDict = self.__dict__
    if (isinstance(value, memops.api.Implementation.Int.PythonType)):
      pass
    elif ([x for x in memops.api.Implementation.Int.compatibleTypes if isinstance(value, x)]):
      value = memops.api.Implementation.Int.create(value)
    else:
      raise ApiError("""%s.setSerial:
       memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('serial')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setSerial:
       called on deleted object""" % self.qualifiedName
      )

    if (value == currentValue):
      return

    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setSerial:
         cannot set serial, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is None):
        raise ApiError("""%s.setSerial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    parent = dataDict.get('nmrConstraintStore')
    oldSerial = parent.__dict__.get('_serialDict').get('resStructures')
    if (value < 0):
      value = (oldSerial + 1)
      parent.__dict__.get('_serialDict')['resStructures'] = value
    elif (value > oldSerial):
      parent.__dict__.get('_serialDict')['resStructures'] = value

    dataDict['serial'] = value

    # doNotifies
  
  def sortedCoords(self):
    """
    Sorted for ccp.nmr.NmrConstraint.ResStructure.coords
    """
    dataDict = self.__dict__
    sortdd = dataDict.get('coords')
    
    ll = sortdd.keys()
    ll.sort()
    result = [sortdd[x] for x in ll]
    return result

  toDetailedString = memops.api.Implementation.ComplexDataType.toDetailedString

  applicationData = memops.api.Implementation.DataObject.applicationData

  className = memops.api.Implementation.ComplexDataType.className

  fieldNames = memops.api.Implementation.ComplexDataType.fieldNames

  inConstructor = memops.api.Implementation.ComplexDataType.inConstructor

  isDeleted = memops.api.Implementation.MemopsObject.isDeleted
  
  label = property(getLabel, setLabel, None,
  r"""Short identyfying or explanatory string, 
  """)

  metaclass = memops.api.Implementation.ComplexDataType.metaclass

  packageName = memops.api.Implementation.ComplexDataType.packageName

  packageShortName = memops.api.Implementation.ComplexDataType.packageShortName

  qualifiedName = memops.api.Implementation.ComplexDataType.qualifiedName
  
  serial = property(getSerial, setSerial, None,
  r"""Serial number of object. Serves as object main key. Serial numbers of 
  deleted objects are not re-used. Serial numbers can only be set by the 
  implementation. Values are in practice always positive, since negative 
  values are interpreted as a signal to set the next free serial
  """)

  access = memops.api.Implementation.DataObject.access
  
  coords = property(getCoords,  None, None,
  r"""child link to class ResCoord
  """)
  
  nmrConstraintStore = property(getNmrConstraintStore,  None, None,
  r"""Structure generation run where ResStructures were generated.
  """)
  
  parent = property(getParent, None, None,
  r"""link to parent object - synonym for nmrConstraintStore
  """)

  root = memops.api.Implementation.MemopsObject.root

  topObject = memops.api.Implementation.DataObject.topObject

###############################################################################
class Violation(memops.api.Implementation.DataObject):
  r"""Violation of linked-to constraint, calculated over structures defined in 
ViolationList.
  """
  #   from data model element ccp.nmr.NmrConstraint.Violation revision 1.36.2.9
  _metaclass = metaPackage.getElement('Violation')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('applicationData', 'calcValue', 'calcValueError', 'className', 'fieldNames', 'fractionViolated', 'inConstructor', 'isDeleted', 'metaclass', 'packageName', 'packageShortName', 'qualifiedName', 'violation', 'access', 'constraint', 'method', 'parent', 'root', 'topObject', 'violationList',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccp.nmr.NmrConstraint.Violation
    """
    dataDict = self.__dict__
    dataDict['violationList'] = parent
    if (not isinstance(parent, ViolationList)):
      raise ApiError("""%s.__init__:
       value is not of class ccp.nmr.NmrConstraint.ViolationList""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:

      dataDict['applicationData'] = list()
      dataDict['calcValue'] = None
      dataDict['calcValueError'] = None
      dataDict['fractionViolated'] = None
      dataDict['violation'] = None
      dataDict['access'] = None
      dataDict['constraint'] = None
      dataDict['method'] = None

      dataDict['inConstructor'] = True
      try:
        
        for key, value in attrlinks.iteritems():
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        del dataDict['inConstructor']
      except:
        print "ERROR in ccp.nmr.NmrConstraint.Violation.__init__"
        del dataDict['inConstructor']
        raise

      if (notIsReading):
        childrenDict = parent.__dict__.get('violations')
        objKey = dataDict.get('constraint')
        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['constraint'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        print '''WARNING Error in clean-up of incorrectly created object. 
        Data may be left in an illegal state'''
        del dataDict['inConstructor']
      raise exc_info[0], exc_info[1], exc_info[2]

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccp.nmr.NmrConstraint.Violation:
       determines cascading 
    deletes to follow from delete of object.
       *Implementation function* - 
    should be called only by API delete function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
      dataDict.get('topObject').load()

    access = dataDict.get('access')
    if (access is not None):
      topObject = access.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    method = dataDict.get('method')
    if (method is not None):
      topObject = method.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccp.nmr.NmrConstraint.Violation:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    access = dataDict.get('access')
    if ((access is not None and not (access in objsToBeDeleted))):
      dataObjects = access.__dict__.get('dataObjects')
      dataObjects.remove(self)

    constraint = dataDict.get('constraint')
    if ((constraint is not None and not (constraint in objsToBeDeleted))):
      violations = constraint.__dict__.get('violations')
      violations.remove(self)

    method = dataDict.get('method')
    if ((method is not None and not (method in objsToBeDeleted))):
      violations = method.__dict__.get('violations')
      violations.remove(self)

    violationList = dataDict.get('violationList')
    if (not (violationList in objsToBeDeleted)):
      objKey = dataDict.get('constraint')
      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = violationList.__dict__.get('violations')
        if (self is dd.get(objKey)):
          del dd[objKey]

  addApplicationData = memops.api.Implementation.DataObject.addApplicationData
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccp.nmr.NmrConstraint.Violation
    """
    dataDict = self.__dict__
    self.checkValid(complete)
  
  def checkValid(self, complete=False):
    """
    CheckValid for ccp.nmr.NmrConstraint.Violation
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('constraint')
      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('violationList')
        dd = value.__dict__.get('violations')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'violationList' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from memops.api.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('calcValue')
      if (isinstance(value, memops.api.Implementation.Float.PythonType)):
        pass
      elif ([x for x in memops.api.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = memops.api.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.checkValid: calcValue:
         memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.checkValid: calcValue:
         Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('calcValueError')
      if (value is not None):
        if (isinstance(value, memops.api.Implementation.Float.PythonType)):
          pass
        elif ([x for x in memops.api.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = memops.api.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: calcValueError:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: calcValueError:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('fractionViolated')
      if (isinstance(value, memops.api.Implementation.Float.PythonType)):
        pass
      elif ([x for x in memops.api.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = memops.api.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.checkValid: fractionViolated:
         memops.Implementation.FloatRatio input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (0.0 <= value)):
        raise ApiError("""%s.checkValid: fractionViolated:
         FloatRatio constraint value_ge_0 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.checkValid: fractionViolated:
         FloatRatio constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value <= 1.0)):
        raise ApiError("""%s.checkValid: fractionViolated:
         FloatRatio constraint value_le_1 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, memops.api.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('violation')
      if (isinstance(value, memops.api.Implementation.Float.PythonType)):
        pass
      elif ([x for x in memops.api.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = memops.api.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.checkValid: violation:
         memops.Implementation.NonNegativeFloat input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (0.0 <= value)):
        raise ApiError("""%s.checkValid: violation:
         NonNegativeFloat constraint float_value_ge_0 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.checkValid: violation:
         NonNegativeFloat constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('access')
      if (value is not None):
        from memops.api.AccessControl import AccessObject as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: access:
           value is not of class memops.AccessControl.AccessObject""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('dataObjects')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: access:
           non-reciprocal link Violation from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      value = dataDict.get('constraint')
      if (not isinstance(value, AbstractConstraint)):
        raise ApiError("""%s.checkValid: constraint:
         value is not of class ccp.nmr.NmrConstraint.AbstractConstraint""" % self.qualifiedName
         + ": %s" % (value,)
        )

      oldSelves = value.__dict__.get('violations')
      if (not (self in oldSelves)):
        raise ApiError("""%s.checkValid: constraint:
         non-reciprocal link Violation from object""" % self.qualifiedName
         + ": %s" % (self,)
        )

      value = dataDict.get('method')
      if (value is not None):
        from ccp.api.general.Method import Method as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: method:
           value is not of class ccp.general.Method.Method""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('violations')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: method:
           non-reciprocal link Violation from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      value = dataDict.get('violationList')
      if (not isinstance(value, ViolationList)):
        raise ApiError("""%s.checkValid: violationList:
         value is not of class ccp.nmr.NmrConstraint.ViolationList""" % self.qualifiedName
         + ": %s" % (value,)
        )

    # check explicit class constraints
    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('calcValue')
    if (value is None):
      raise ApiError("""%s.checkValid: calcValue:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    value = dataDict.get('calcValueError')
    value = dataDict.get('fractionViolated')
    if (value is None):
      raise ApiError("""%s.checkValid: fractionViolated:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    value = dataDict.get('violation')
    if (value is None):
      raise ApiError("""%s.checkValid: violation:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    # check roles
    value = dataDict.get('access')
    value = dataDict.get('constraint')
    if (value is None):
      raise ApiError("""%s.checkValid: constraint:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    value = dataDict.get('method')
    value = dataDict.get('violationList')
    if (value is None):
      raise ApiError("""%s.checkValid: violationList:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

  delete = memops.api.Implementation.DataObject.delete

  findAllApplicationData = memops.api.Implementation.DataObject.findAllApplicationData

  findFirstApplicationData = memops.api.Implementation.DataObject.findFirstApplicationData
  
  def get(self, name):
    """
    GetAttr for ccp.nmr.NmrConstraint.Violation
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getAccess = memops.api.Implementation.DataObject.getAccess

  getApplicationData = memops.api.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.Violation
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (3 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.Violation'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (2 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.Violation'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-2]
      obj2 = obj1.__dict__.get('violationLists').get(objKey)

      if (obj2 is not None):
        objKey = fullKey[-1]
        obj3 = obj2.__dict__.get('violations').get(objKey)
        result = obj3

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = memops.api.Implementation.MemopsObject.getByNavigation
  
  def getCalcValue(self):
    """
    Get for ccp.nmr.NmrConstraint.Violation.calcValue
    """
    dataDict = self.__dict__
    result = dataDict.get('calcValue')
    return result
  
  def getCalcValueError(self):
    """
    Get for ccp.nmr.NmrConstraint.Violation.calcValueError
    """
    dataDict = self.__dict__
    result = dataDict.get('calcValueError')
    return result

  getClassName = memops.api.Implementation.ComplexDataType.getClassName
  
  def getConstraint(self):
    """
    Get for ccp.nmr.NmrConstraint.Violation.constraint
    """
    dataDict = self.__dict__
    result = dataDict.get('constraint')
    return result

  getExpandedKey = memops.api.Implementation.MemopsObject.getExpandedKey

  getFieldNames = memops.api.Implementation.ComplexDataType.getFieldNames
  
  def getFractionViolated(self):
    """
    Get for ccp.nmr.NmrConstraint.Violation.fractionViolated
    """
    dataDict = self.__dict__
    result = dataDict.get('fractionViolated')
    return result
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccp.nmr.NmrConstraint.Violation
    """
    dataDict = self.__dict__
    result = list()

    obj2 = dataDict.get('violationList')
    obj1 = obj2.__dict__.get('nmrConstraintStore')

    if (useGuid):
      result.append(obj1.__dict__.get('guid'))
    else:
      result.append(obj1.__dict__.get('serial'))

    result.append(obj2.__dict__.get('serial'))
    result.append(dataDict.get('constraint'))

    return result

  getInConstructor = memops.api.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = memops.api.Implementation.MemopsObject.getIsDeleted
  
  def getLocalKey(self):
    """
    GetLocalKey for ccp.nmr.NmrConstraint.Violation
    """
    dataDict = self.__dict__
    result = dataDict.get('constraint')
    return result

  getMetaclass = memops.api.Implementation.ComplexDataType.getMetaclass
  
  def getMethod(self):
    """
    Get for ccp.nmr.NmrConstraint.Violation.method
    """
    dataDict = self.__dict__
    result = dataDict.get('method')
    return result

  getPackageName = memops.api.Implementation.ComplexDataType.getPackageName

  getPackageShortName = memops.api.Implementation.ComplexDataType.getPackageShortName
  
  def getParent(self):
    """
    Get for ccp.nmr.NmrConstraint.Violation.parent
    """
    dataDict = self.__dict__
    result = dataDict.get('violationList')
    return result

  getQualifiedName = memops.api.Implementation.ComplexDataType.getQualifiedName

  getRoot = memops.api.Implementation.MemopsObject.getRoot

  getTopObject = memops.api.Implementation.DataObject.getTopObject
  
  def getViolation(self):
    """
    Get for ccp.nmr.NmrConstraint.Violation.violation
    """
    dataDict = self.__dict__
    result = dataDict.get('violation')
    return result
  
  def getViolationList(self):
    """
    Get for ccp.nmr.NmrConstraint.Violation.violationList
    """
    dataDict = self.__dict__
    result = dataDict.get('violationList')
    return result

  removeApplicationData = memops.api.Implementation.DataObject.removeApplicationData
  
  def set(self, name, value):
    """
    SetAttr for ccp.nmr.NmrConstraint.Violation
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setAccess = memops.api.Implementation.DataObject.setAccess

  setApplicationData = memops.api.Implementation.DataObject.setApplicationData
  
  def setCalcValue(self, value):
    """
    Set for ccp.nmr.NmrConstraint.Violation.calcValue
    """
    dataDict = self.__dict__
    if (isinstance(value, memops.api.Implementation.Float.PythonType)):
      pass
    elif ([x for x in memops.api.Implementation.Float.compatibleTypes if isinstance(value, x)]):
      value = memops.api.Implementation.Float.create(value)
    else:
      raise ApiError("""%s.setCalcValue:
       memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (value - value == 0.0)):
      raise ApiError("""%s.setCalcValue:
       Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('calcValue')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setCalcValue:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setCalcValue:
       called on deleted object""" % self.qualifiedName
      )

    if (value == currentValue):
      return

    if (notOverride):
      if (value is None):
        raise ApiError("""%s.setCalcValue:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    dataDict['calcValue'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setCalcValue')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  def setCalcValueError(self, value):
    """
    Set for ccp.nmr.NmrConstraint.Violation.calcValueError
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, memops.api.Implementation.Float.PythonType)):
        pass
      elif ([x for x in memops.api.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = memops.api.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.setCalcValueError:
         memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.setCalcValueError:
         Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('calcValueError')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setCalcValueError:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setCalcValueError:
       called on deleted object""" % self.qualifiedName
      )

    if (value == currentValue):
      return

    if (notOverride):
      pass

    dataDict['calcValueError'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setCalcValueError')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  def setConstraint(self, value):
    """
    Set for ccp.nmr.NmrConstraint.Violation.constraint
    """
    dataDict = self.__dict__
    if (not isinstance(value, AbstractConstraint)):
      raise ApiError("""%s.setConstraint:
       value is not of class ccp.nmr.NmrConstraint.AbstractConstraint""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('constraint')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setConstraint:
       called on deleted object""" % self.qualifiedName
      )

    if (value is not None):
      if (value.__dict__.get('isDeleted')):
        raise ApiError("""%s.setConstraint:
         called with deleted value""" % self.qualifiedName
        )

    if (value == currentValue):
      return

    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setConstraint:
         cannot set constraint, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is None):
        raise ApiError("""%s.setConstraint:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      xx1 = dataDict.get('topObject')
      yy1 = value.__dict__.get('topObject')
      if (not (xx1 is yy1)):
        raise ApiError("""%s.setConstraint:
         Link constraint between objects from separate partitions
         - memops.Implementation.TopObject does not match""" % self.qualifiedName
         + ": %s:%s" % (self, value)
        )

    if (currentValue is not None):
      if (notIsReading):
        oldSelves = currentValue.__dict__.get('violations')
        oldSelves.remove(self)
      else:
        raise ApiError("""%s.setConstraint:
         Read link 'constraint' incompatible with pre-existing link""" % self.qualifiedName
         + ": %s" % (self,)
        )

    if (value is not None):
      newSelves = value.__dict__.get('violations')
      newSelves.add(self)

    dataDict['constraint'] = value

    # doNotifies
  
  def setFractionViolated(self, value):
    """
    Set for ccp.nmr.NmrConstraint.Violation.fractionViolated
    """
    dataDict = self.__dict__
    if (isinstance(value, memops.api.Implementation.Float.PythonType)):
      pass
    elif ([x for x in memops.api.Implementation.Float.compatibleTypes if isinstance(value, x)]):
      value = memops.api.Implementation.Float.create(value)
    else:
      raise ApiError("""%s.setFractionViolated:
       memops.Implementation.FloatRatio input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (0.0 <= value)):
      raise ApiError("""%s.setFractionViolated:
       FloatRatio constraint value_ge_0 violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (value - value == 0.0)):
      raise ApiError("""%s.setFractionViolated:
       FloatRatio constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (value <= 1.0)):
      raise ApiError("""%s.setFractionViolated:
       FloatRatio constraint value_le_1 violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('fractionViolated')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setFractionViolated:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setFractionViolated:
       called on deleted object""" % self.qualifiedName
      )

    if (value == currentValue):
      return

    if (notOverride):
      if (value is None):
        raise ApiError("""%s.setFractionViolated:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    dataDict['fractionViolated'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setFractionViolated')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  def setMethod(self, value):
    """
    Set for ccp.nmr.NmrConstraint.Violation.method
    """
    dataDict = self.__dict__
    if (value is not None):
      from ccp.api.general.Method import Method as importedType
      if (not isinstance(value, importedType)):
        raise ApiError("""%s.setMethod:
         value is not of class ccp.general.Method.Method""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('method')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setMethod:
       called on deleted object""" % self.qualifiedName
      )

    if (value is not None):
      if (value.__dict__.get('isDeleted')):
        raise ApiError("""%s.setMethod:
         called with deleted value""" % self.qualifiedName
        )

    if (value == currentValue):
      return

    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setMethod:
         cannot set method, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is not None):
        xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setMethod:
           Link method between objects from separate partitions
           - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    if (currentValue is not None):
      if (notIsReading):
        oldSelves = currentValue.__dict__.get('violations')
        oldSelves.remove(self)
      else:
        raise ApiError("""%s.setMethod:
         Read link 'method' incompatible with pre-existing link""" % self.qualifiedName
         + ": %s" % (self,)
        )

    if (value is not None):
      newSelves = value.__dict__.get('violations')
      newSelves.add(self)

    dataDict['method'] = value

    # doNotifies
  
  def setViolation(self, value):
    """
    Set for ccp.nmr.NmrConstraint.Violation.violation
    """
    dataDict = self.__dict__
    if (isinstance(value, memops.api.Implementation.Float.PythonType)):
      pass
    elif ([x for x in memops.api.Implementation.Float.compatibleTypes if isinstance(value, x)]):
      value = memops.api.Implementation.Float.create(value)
    else:
      raise ApiError("""%s.setViolation:
       memops.Implementation.NonNegativeFloat input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (0.0 <= value)):
      raise ApiError("""%s.setViolation:
       NonNegativeFloat constraint float_value_ge_0 violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    if (not (value - value == 0.0)):
      raise ApiError("""%s.setViolation:
       NonNegativeFloat constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('violation')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setViolation:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setViolation:
       called on deleted object""" % self.qualifiedName
      )

    if (value == currentValue):
      return

    if (notOverride):
      if (value is None):
        raise ApiError("""%s.setViolation:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    dataDict['violation'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setViolation')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  toDetailedString = memops.api.Implementation.ComplexDataType.toDetailedString

  applicationData = memops.api.Implementation.DataObject.applicationData
  
  calcValue = property(getCalcValue, setCalcValue, None,
  r"""The value calculated for the quantity being constrained.
  """)
  
  calcValueError = property(getCalcValueError, setCalcValueError, None,
  r"""Error (standard deviation) in the calculated value
  """)

  className = memops.api.Implementation.ComplexDataType.className

  fieldNames = memops.api.Implementation.ComplexDataType.fieldNames
  
  fractionViolated = property(getFractionViolated, setFractionViolated, None,
  r"""Fraction of structures in which the constraint was violated
  """)

  inConstructor = memops.api.Implementation.ComplexDataType.inConstructor

  isDeleted = memops.api.Implementation.MemopsObject.isDeleted

  metaclass = memops.api.Implementation.ComplexDataType.metaclass

  packageName = memops.api.Implementation.ComplexDataType.packageName

  packageShortName = memops.api.Implementation.ComplexDataType.packageShortName

  qualifiedName = memops.api.Implementation.ComplexDataType.qualifiedName
  
  violation = property(getViolation, setViolation, None,
  r"""Value of the violation - the amount by which the calcValue exceeds the 
  limit given in the Constraint. The violation is always given as 
  positive. The unit is given by the ConstraintList containing the 
  violated Constraint
  """)

  access = memops.api.Implementation.DataObject.access
  
  constraint = property(getConstraint, setConstraint, None,
  r"""Constraint being violated
  """)
  
  method = property(getMethod, setMethod, None,
  r"""Method used for calculating violation
  """)
  
  parent = property(getParent, None, None,
  r"""link to parent object - synonym for violationList
  """)

  root = memops.api.Implementation.MemopsObject.root

  topObject = memops.api.Implementation.DataObject.topObject
  
  violationList = property(getViolationList,  None, None,
  r"""parent link
  """)

###############################################################################
class ViolationList(memops.api.Implementation.DataObject):
  r"""List of constraint violations, calculated over the structures linked to 
(if set). The violations may refer to constraints from different 
ConstraintLists.
  """
  #   from data model element ccp.nmr.NmrConstraint.ViolationList revision 1.38.2.9
  _metaclass = metaPackage.getElement('ViolationList')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('applicationData', 'className', 'details', 'fieldNames', 'inConstructor', 'isDeleted', 'metaclass', 'packageName', 'packageShortName', 'qualifiedName', 'serial', 'access', 'molStructures', 'nmrConstraintStore', 'parent', 'root', 'topObject', 'violations',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccp.nmr.NmrConstraint.ViolationList
    """
    dataDict = self.__dict__
    dataDict['nmrConstraintStore'] = parent
    if (not isinstance(parent, NmrConstraintStore)):
      raise ApiError("""%s.__init__:
       value is not of class ccp.nmr.NmrConstraint.NmrConstraintStore""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:
      if (not ((parent.__dict__.get('isLoaded') or parent.__dict__.get('isReading')))):
        parent.load()

      dataDict['applicationData'] = list()
      dataDict['details'] = None
      dataDict['serial'] = None
      dataDict['access'] = None
      dataDict['molStructures'] = set()
      dataDict['violations'] = {}

      dataDict['inConstructor'] = True
      try:
        
        for key, value in attrlinks.iteritems():
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        del dataDict['inConstructor']
      except:
        print "ERROR in ccp.nmr.NmrConstraint.ViolationList.__init__"
        del dataDict['inConstructor']
        raise

      if (notOverride):
        if (dataDict.get('serial') is None):
          dataDict['inConstructor'] = True
          self.setSerial(-1)
          del dataDict['inConstructor']
        else:
          raise ApiError("""%s.__init__:
           Cannot pass in explicit serial if not reading""" % self.qualifiedName
           + ": %s:%s" % (parent, 'ccp.nmr.NmrConstraint.ViolationList')
          )

      if (notIsReading):
        childrenDict = parent.__dict__.get('violationLists')
        objKey = dataDict.get('serial')
        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['serial'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        print '''WARNING Error in clean-up of incorrectly created object. 
        Data may be left in an illegal state'''
        del dataDict['inConstructor']
      raise exc_info[0], exc_info[1], exc_info[2]

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccp.nmr.NmrConstraint.ViolationList:
       determines 
    cascading deletes to follow from delete of object.
       *Implementation 
    function* - should be called only by API delete function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
      dataDict.get('topObject').load()

    access = dataDict.get('access')
    if (access is not None):
      topObject = access.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    molStructures = dataDict.get('molStructures')
    pass
    for molStructure in molStructures:
      topObject = molStructure.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    violations = dataDict.get('violations').values()
    for violation in violations:
      if (not (violation in objsToBeDeleted)):
        objsToBeDeleted.add(violation)
        objsToBeChecked.append(violation)

    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccp.nmr.NmrConstraint.ViolationList:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    access = dataDict.get('access')
    if ((access is not None and not (access in objsToBeDeleted))):
      dataObjects = access.__dict__.get('dataObjects')
      dataObjects.remove(self)

    for molStructure in dataDict.get('molStructures'):
      if (not (molStructure in objsToBeDeleted)):
        violationLists = molStructure.__dict__.get('violationLists')
        violationLists.remove(self)

    nmrConstraintStore = dataDict.get('nmrConstraintStore')
    if (not (nmrConstraintStore in objsToBeDeleted)):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = nmrConstraintStore.__dict__.get('violationLists')
        if (self is dd.get(objKey)):
          del dd[objKey]

  addApplicationData = memops.api.Implementation.DataObject.addApplicationData
  
  def addMolStructure(self, value):
    """
    Add for ccp.nmr.NmrConstraint.ViolationList.molStructures
    """
    dataDict = self.__dict__
    from ccp.api.molecule.MolStructure import Model as importedType
    if (not isinstance(value, importedType)):
      raise ApiError("""%s.addMolStructure:
       value is not of class ccp.molecule.MolStructure.Model""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('molStructures')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      topObject = value.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)
      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.addMolStructure:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.addMolStructure:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.addMolStructure:
       called with deleted value""" % self.qualifiedName
      )

    if (value in currentValues):
      raise ApiError("""%s.addMolStructure:
       value is in list already""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      if (value is not None):
        xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.addMolStructure:
           Link molStructures between objects from separate partitions
           - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    oldSelves = value.__dict__.get('violationLists')
    oldSelves.add(self)
    currentValues.add(value)
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('addMolStructure')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccp.nmr.NmrConstraint.ViolationList
    """
    dataDict = self.__dict__
    self.checkValid(complete)
    values = dataDict.get('violations').values()
    for value in values:
      value.checkAllValid(complete)

  def checkValid(self, complete=False):
    """
    CheckValid for ccp.nmr.NmrConstraint.ViolationList
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('nmrConstraintStore')
        dd = value.__dict__.get('violationLists')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'nmrConstraintStore' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from memops.api.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('details')
      if (value is not None):
        if (isinstance(value, memops.api.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: details:
           memops.Implementation.Text input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 254):
          raise ApiError("""%s.checkValid: details:
           memops.Implementation.Text maximum length is 254 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: details:
           memops.Implementation.Text: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, memops.api.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('serial')
      if (value is None):
        raise ApiError("""%s.checkValid: serial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, memops.api.Implementation.Int.PythonType)):
        pass
      elif ([x for x in memops.api.Implementation.Int.compatibleTypes if isinstance(value, x)]):
        value = memops.api.Implementation.Int.create(value)
      else:
        raise ApiError("""%s.checkValid: serial:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('access')
      if (value is not None):
        from memops.api.AccessControl import AccessObject as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: access:
           value is not of class memops.AccessControl.AccessObject""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('dataObjects')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: access:
           non-reciprocal link ViolationList from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('molStructures')
      for value in values:
        from ccp.api.molecule.MolStructure import Model as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: molStructures:
           value is not of class ccp.molecule.MolStructure.Model""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('violationLists')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: molStructures:
           non-reciprocal link ViolationList from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: molStructures:
           Link molStructures between objects from separate partitions
           - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      value = dataDict.get('nmrConstraintStore')
      if (not isinstance(value, NmrConstraintStore)):
        raise ApiError("""%s.checkValid: nmrConstraintStore:
         value is not of class ccp.nmr.NmrConstraint.NmrConstraintStore""" % self.qualifiedName
         + ": %s" % (value,)
        )

      values = dataDict.get('violations').values()
      for value in values:
        if (not isinstance(value, Violation)):
          raise ApiError("""%s.checkValid: violations:
           value is not of class ccp.nmr.NmrConstraint.Violation""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('violationList')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: violations:
           non-reciprocal link ViolationList from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

    # check explicit class constraints
    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('details')
    # check roles
    value = dataDict.get('access')
    values = dataDict.get('molStructures')
    value = dataDict.get('nmrConstraintStore')
    if (value is None):
      raise ApiError("""%s.checkValid: nmrConstraintStore:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    values = dataDict.get('violations').values()

  delete = memops.api.Implementation.DataObject.delete

  findAllApplicationData = memops.api.Implementation.DataObject.findAllApplicationData
  
  def findAllMolStructures(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.ViolationList.molStructures
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('molStructures')
      result = set(currentValues)

    else:
      currentValues = dataDict.get('molStructures')
      result = set()
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('details', 'name', 'serial', 'access', 'structureEnsemble',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result.add(v)

    return result
  
  def findAllViolations(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.ViolationList.violations
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('violations').values()
      result = set(currentValues)

    else:
      currentValues = dataDict.get('violations').values()
      result = set()
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('calcValue', 'calcValueError', 'fractionViolated', 'violation', 'access', 'constraint', 'method', 'violationList',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result.add(v)

    return result

  findFirstApplicationData = memops.api.Implementation.DataObject.findFirstApplicationData
  
  def findFirstMolStructure(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.ViolationList.molStructures
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('molStructures')
      if (currentValues):
        result = iter(currentValues).next()
      else:
        result = None

    else:
      currentValues = dataDict.get('molStructures')
      result = None
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('details', 'name', 'serial', 'access', 'structureEnsemble',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result = v; break

    return result
  
  def findFirstViolation(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.ViolationList.violations
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('violations').values()
      if (currentValues):
        result = iter(currentValues).next()
      else:
        result = None

    else:
      objKey = conditions.get('constraint')
      if (objKey is not None):
        result = dataDict.get('violations').get(objKey)

        if (result is None):
          return result

        elif (len(conditions) <= 1):
          return result

        else:
          currentValues = set()
          currentValues.add(result)

      else:
        currentValues = dataDict.get('violations').values()

      result = None
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('calcValue', 'calcValueError', 'fractionViolated', 'violation', 'access', 'constraint', 'method', 'violationList',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result = v; break

    return result
  
  def get(self, name):
    """
    GetAttr for ccp.nmr.NmrConstraint.ViolationList
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getAccess = memops.api.Implementation.DataObject.getAccess

  getApplicationData = memops.api.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.ViolationList
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (2 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.ViolationList'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (1 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.ViolationList'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-1]
      obj2 = obj1.__dict__.get('violationLists').get(objKey)
      result = obj2

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = memops.api.Implementation.MemopsObject.getByNavigation

  getClassName = memops.api.Implementation.ComplexDataType.getClassName
  
  def getDetails(self):
    """
    Get for ccp.nmr.NmrConstraint.ViolationList.details
    """
    dataDict = self.__dict__
    result = dataDict.get('details')
    return result

  getExpandedKey = memops.api.Implementation.MemopsObject.getExpandedKey

  getFieldNames = memops.api.Implementation.ComplexDataType.getFieldNames
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccp.nmr.NmrConstraint.ViolationList
    """
    dataDict = self.__dict__
    result = list()

    obj1 = dataDict.get('nmrConstraintStore')

    if (useGuid):
      result.append(obj1.__dict__.get('guid'))
    else:
      result.append(obj1.__dict__.get('serial'))

    result.append(dataDict.get('serial'))

    return result

  getInConstructor = memops.api.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = memops.api.Implementation.MemopsObject.getIsDeleted
  
  def getLocalKey(self):
    """
    GetLocalKey for ccp.nmr.NmrConstraint.ViolationList
    """
    dataDict = self.__dict__
    result = dataDict.get('serial')
    return result

  getMetaclass = memops.api.Implementation.ComplexDataType.getMetaclass
  
  def getMolStructures(self):
    """
    Get for ccp.nmr.NmrConstraint.ViolationList.molStructures
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('molStructures')
    result = frozenset(tempVar)
    return result
  
  def getNmrConstraintStore(self):
    """
    Get for ccp.nmr.NmrConstraint.ViolationList.nmrConstraintStore
    """
    dataDict = self.__dict__
    result = dataDict.get('nmrConstraintStore')
    return result

  getPackageName = memops.api.Implementation.ComplexDataType.getPackageName

  getPackageShortName = memops.api.Implementation.ComplexDataType.getPackageShortName
  
  def getParent(self):
    """
    Get for ccp.nmr.NmrConstraint.ViolationList.parent
    """
    dataDict = self.__dict__
    result = dataDict.get('nmrConstraintStore')
    return result

  getQualifiedName = memops.api.Implementation.ComplexDataType.getQualifiedName

  getRoot = memops.api.Implementation.MemopsObject.getRoot
  
  def getSerial(self):
    """
    Get for ccp.nmr.NmrConstraint.ViolationList.serial
    """
    dataDict = self.__dict__
    result = dataDict.get('serial')
    return result

  getTopObject = memops.api.Implementation.DataObject.getTopObject
  
  def getViolations(self):
    """
    Get for ccp.nmr.NmrConstraint.ViolationList.violations
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('violations').values()
    result = frozenset(tempVar)
    return result
  
  def newViolation(self, **attrlinks):
    """
    Factory function to create ccp.nmr.NmrConstraint.Violation
    """
    return Violation(self, **attrlinks)

  removeApplicationData = memops.api.Implementation.DataObject.removeApplicationData
  
  def removeMolStructure(self, value):
    """
    Remove for ccp.nmr.NmrConstraint.ViolationList.molStructures
    """
    dataDict = self.__dict__
    from ccp.api.molecule.MolStructure import Model as importedType
    if (not isinstance(value, importedType)):
      raise ApiError("""%s.removeMolStructure:
       value is not of class ccp.molecule.MolStructure.Model""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('molStructures')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      topObject = value.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)
      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.removeMolStructure:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.removeMolStructure:
       called on deleted object""" % self.qualifiedName
      )

    if (value.__dict__.get('isDeleted')):
      raise ApiError("""%s.removeMolStructure:
       called with deleted value""" % self.qualifiedName
      )

    if (not (value in currentValues)):
      raise ApiError("""%s.removeMolStructure:
       value not in list""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (notOverride):
      pass

    oldSelves = value.__dict__.get('violationLists')
    oldSelves.remove(self)
    currentValues.remove(value)
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('removeMolStructure')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  def set(self, name, value):
    """
    SetAttr for ccp.nmr.NmrConstraint.ViolationList
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setAccess = memops.api.Implementation.DataObject.setAccess

  setApplicationData = memops.api.Implementation.DataObject.setApplicationData
  
  def setDetails(self, value):
    """
    Set for ccp.nmr.NmrConstraint.ViolationList.details
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, memops.api.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.setDetails:
         memops.Implementation.Text input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 254):
        raise ApiError("""%s.setDetails:
         memops.Implementation.Text maximum length is 254 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.setDetails:
         memops.Implementation.Text: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('details')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setDetails:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setDetails:
       called on deleted object""" % self.qualifiedName
      )

    if (value == currentValue):
      return

    if (notOverride):
      pass

    dataDict['details'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setDetails')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  def setMolStructures(self, values):
    """
    Set for ccp.nmr.NmrConstraint.ViolationList.molStructures
    """
    dataDict = self.__dict__
    xx = values
    values = set(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setMolStructures:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      from ccp.api.molecule.MolStructure import Model as importedType
      if (not isinstance(value, importedType)):
        raise ApiError("""%s.setMolStructures:
         value is not of class ccp.molecule.MolStructure.Model""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('molStructures')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    topObjectsToCheck = None
    if (notIsReading):
      topObjectsToCheck = set()
      if (notInConstructor):
        topObject = dataDict.get('topObject')
        topObjectsToCheck.add(topObject)

      for pv in currentValues:
        if (not (pv in values)):
          topObject = pv.__dict__.get('topObject')
          topObjectsToCheck.add(topObject)

      for pv in values:
        if (not (pv in currentValues)):
          topObject = pv.__dict__.get('topObject')
          topObjectsToCheck.add(topObject)

      for topObjectToCheck in topObjectsToCheck:
        if (not (topObjectToCheck.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setMolStructures:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObjectToCheck,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setMolStructures:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setMolStructures:
         an object in values is deleted""" % self.qualifiedName
        )

    if (values == currentValues):
      return

    if (notOverride):
      xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
      for value in values:
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setMolStructures:
           Link molStructures between objects from separate partitions
           - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    for cv in currentValues:
      if (not (cv in values)):
        oldSelves = cv.__dict__.get('violationLists')
        oldSelves.remove(self)

    for cv in values:
      if (not (cv in currentValues)):
        oldSelves = cv.__dict__.get('violationLists')
        oldSelves.add(self)

    dataDict['molStructures'] = values
    if (notIsReading):
      for topObjectModify in topObjectsToCheck:
        topObjectModify.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setMolStructures')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  def setSerial(self, value):
    """
    Set for ccp.nmr.NmrConstraint.ViolationList.serial
    """
    dataDict = self.__dict__
    if (isinstance(value, memops.api.Implementation.Int.PythonType)):
      pass
    elif ([x for x in memops.api.Implementation.Int.compatibleTypes if isinstance(value, x)]):
      value = memops.api.Implementation.Int.create(value)
    else:
      raise ApiError("""%s.setSerial:
       memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('serial')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setSerial:
       called on deleted object""" % self.qualifiedName
      )

    if (value == currentValue):
      return

    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setSerial:
         cannot set serial, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is None):
        raise ApiError("""%s.setSerial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      pass

    parent = dataDict.get('nmrConstraintStore')
    oldSerial = parent.__dict__.get('_serialDict').get('violationLists')
    if (value < 0):
      value = (oldSerial + 1)
      parent.__dict__.get('_serialDict')['violationLists'] = value
    elif (value > oldSerial):
      parent.__dict__.get('_serialDict')['violationLists'] = value

    dataDict['serial'] = value

    # doNotifies
  
  def sortedMolStructures(self):
    """
    Sorted for ccp.nmr.NmrConstraint.ViolationList.molStructures
    """
    dataDict = self.__dict__
    ll = dataDict.get('molStructures')
    ll = [(x.getFullKey(),x) for x in ll]
    
    ll.sort()
    result = [x[1] for x in ll]
    return result
  
  def sortedViolations(self):
    """
    Sorted for ccp.nmr.NmrConstraint.ViolationList.violations
    """
    dataDict = self.__dict__
    sortdd = dataDict.get('violations')
    
    ll = sortdd.keys()
    ll.sort()
    result = [sortdd[x] for x in ll]
    return result

  toDetailedString = memops.api.Implementation.ComplexDataType.toDetailedString

  applicationData = memops.api.Implementation.DataObject.applicationData

  className = memops.api.Implementation.ComplexDataType.className
  
  details = property(getDetails, setDetails, None,
  r"""Free text, for notes, explanatory comments, etc.
  """)

  fieldNames = memops.api.Implementation.ComplexDataType.fieldNames

  inConstructor = memops.api.Implementation.ComplexDataType.inConstructor

  isDeleted = memops.api.Implementation.MemopsObject.isDeleted

  metaclass = memops.api.Implementation.ComplexDataType.metaclass

  packageName = memops.api.Implementation.ComplexDataType.packageName

  packageShortName = memops.api.Implementation.ComplexDataType.packageShortName

  qualifiedName = memops.api.Implementation.ComplexDataType.qualifiedName
  
  serial = property(getSerial, setSerial, None,
  r"""Serial number of object. Serves as object main key. Serial numbers of 
  deleted objects are not re-used. Serial numbers can only be set by the 
  implementation. Values are in practice always positive, since negative 
  values are interpreted as a signal to set the next free serial
  """)

  access = memops.api.Implementation.DataObject.access
  
  molStructures = property(getMolStructures, setMolStructures, None,
  r"""MolStructure.Models used for calculating ViolationList
  """)
  
  nmrConstraintStore = property(getNmrConstraintStore,  None, None,
  r"""parent link
  """)
  
  parent = property(getParent, None, None,
  r"""link to parent object - synonym for nmrConstraintStore
  """)

  root = memops.api.Implementation.MemopsObject.root

  topObject = memops.api.Implementation.DataObject.topObject
  
  violations = property(getViolations,  None, None,
  r"""child link to class Violation
  """)

###############################################################################
class DihedralConstraint(AbstractConstraint):
  r"""Dihedral angle constraint. Not ambiguous, must be assigned to a specific 
quartet of Resonances. The different Dihedral Constraint Items represent 
alternative possibilities for dihedral angle values, rather than 
alternative assignemnts.
  """
  #   from data model element ccp.nmr.NmrConstraint.DihedralConstraint revision 1.36.2.9
  _metaclass = metaPackage.getElement('DihedralConstraint')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('applicationData', 'className', 'details', 'fieldNames', 'inConstructor', 'isDeleted', 'metaclass', 'origData', 'packageName', 'packageShortName', 'qualifiedName', 'serial', 'weight', 'access', 'constraintGroups', 'items', 'method', 'nmrConstraintValidations', 'parent', 'parentList', 'peakContribs', 'peaks', 'resonances', 'root', 'topObject', 'violations',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccp.nmr.NmrConstraint.DihedralConstraint
    """
    dataDict = self.__dict__
    dataDict['parentList'] = parent
    if (not isinstance(parent, DihedralConstraintList)):
      raise ApiError("""%s.__init__:
       value is not of class ccp.nmr.NmrConstraint.DihedralConstraintList""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:

      dataDict['applicationData'] = list()
      dataDict['details'] = None
      dataDict['origData'] = None
      dataDict['serial'] = None
      dataDict['weight'] = 1.0
      dataDict['access'] = None
      dataDict['constraintGroups'] = set()
      dataDict['items'] = {}
      dataDict['method'] = None
      dataDict['nmrConstraintValidations'] = set()
      dataDict['peakContribs'] = {}
      dataDict['resonances'] = list()
      dataDict['violations'] = set()

      dataDict['inConstructor'] = True
      try:
        
        for key, value in attrlinks.iteritems():
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        del dataDict['inConstructor']
      except:
        print "ERROR in ccp.nmr.NmrConstraint.DihedralConstraint.__init__"
        del dataDict['inConstructor']
        raise

      if (notOverride):
        if (dataDict.get('serial') is None):
          dataDict['inConstructor'] = True
          self.setSerial(-1)
          del dataDict['inConstructor']
        else:
          raise ApiError("""%s.__init__:
           Cannot pass in explicit serial if not reading""" % self.qualifiedName
           + ": %s:%s" % (parent, 'ccp.nmr.NmrConstraint.DihedralConstraint')
          )

      serialDict = {}
      serialDict['items'] = 0
      dataDict['_serialDict'] = serialDict

      if (notIsReading):
        childrenDict = parent.__dict__.get('constraints')
        objKey = dataDict.get('serial')
        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['serial'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        print '''WARNING Error in clean-up of incorrectly created object. 
        Data may be left in an illegal state'''
        del dataDict['inConstructor']
      raise exc_info[0], exc_info[1], exc_info[2]

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccp.nmr.NmrConstraint.DihedralConstraint:
       determines 
    cascading deletes to follow from delete of object.
       *Implementation 
    function* - should be called only by API delete function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
      dataDict.get('topObject').load()

    access = dataDict.get('access')
    if (access is not None):
      topObject = access.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    items = dataDict.get('items').values()
    for item in items:
      if (not (item in objsToBeDeleted)):
        objsToBeDeleted.add(item)
        objsToBeChecked.append(item)

    method = dataDict.get('method')
    if (method is not None):
      topObject = method.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    nmrConstraintValidations = dataDict.get('nmrConstraintValidations')
    pass
    for nmrConstraintValidation in nmrConstraintValidations:
      topObject = nmrConstraintValidation.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    peakContribs = dataDict.get('peakContribs').values()
    for peakContrib in peakContribs:
      if (not (peakContrib in objsToBeDeleted)):
        objsToBeDeleted.add(peakContrib)
        objsToBeChecked.append(peakContrib)

    violations = dataDict.get('violations')
    for violation in violations:
      if (not (violation in objsToBeDeleted)):
        objsToBeDeleted.add(violation)
        objsToBeChecked.append(violation)

    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccp.nmr.NmrConstraint.DihedralConstraint:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    access = dataDict.get('access')
    if ((access is not None and not (access in objsToBeDeleted))):
      dataObjects = access.__dict__.get('dataObjects')
      dataObjects.remove(self)

    for constraintGroup in dataDict.get('constraintGroups'):
      if (not (constraintGroup in objsToBeDeleted)):
        constraints = constraintGroup.__dict__.get('constraints')
        constraints.remove(self)

    method = dataDict.get('method')
    if ((method is not None and not (method in objsToBeDeleted))):
      constraints = method.__dict__.get('constraints')
      constraints.remove(self)

    for nmrConstraintValidation in dataDict.get('nmrConstraintValidations'):
      if (not (nmrConstraintValidation in objsToBeDeleted)):
        nmrConstraints = nmrConstraintValidation.__dict__.get('nmrConstraints')
        nmrConstraints.remove(self)

    for resonance in dataDict.get('resonances'):
      if (not (resonance in objsToBeDeleted)):
        dihedralConstraints = resonance.__dict__.get('dihedralConstraints')
        dihedralConstraints.remove(self)

    parentList = dataDict.get('parentList')
    if (not (parentList in objsToBeDeleted)):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = parentList.__dict__.get('constraints')
        if (self is dd.get(objKey)):
          del dd[objKey]

  addApplicationData = memops.api.Implementation.DataObject.addApplicationData

  addConstraintGroup = AbstractConstraint.addConstraintGroup

  addNmrConstraintValidation = AbstractConstraint.addNmrConstraintValidation

  addPeak = AbstractConstraint.addPeak
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccp.nmr.NmrConstraint.DihedralConstraint
    """
    dataDict = self.__dict__
    self.checkValid(complete)
    values = dataDict.get('items').values()
    for value in values:
      value.checkAllValid(complete)

    values = dataDict.get('peakContribs').values()
    for value in values:
      value.checkAllValid(complete)

  def checkValid(self, complete=False):
    """
    CheckValid for ccp.nmr.NmrConstraint.DihedralConstraint
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('parentList')
        dd = value.__dict__.get('constraints')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'parentList' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from memops.api.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('details')
      if (value is not None):
        if (isinstance(value, memops.api.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: details:
           memops.Implementation.Text input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 254):
          raise ApiError("""%s.checkValid: details:
           memops.Implementation.Text maximum length is 254 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: details:
           memops.Implementation.Text: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('origData')
      if (value is not None):
        if (isinstance(value, memops.api.Implementation.Float.PythonType)):
          pass
        elif ([x for x in memops.api.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = memops.api.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: origData:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: origData:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, memops.api.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('serial')
      if (value is None):
        raise ApiError("""%s.checkValid: serial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, memops.api.Implementation.Int.PythonType)):
        pass
      elif ([x for x in memops.api.Implementation.Int.compatibleTypes if isinstance(value, x)]):
        value = memops.api.Implementation.Int.create(value)
      else:
        raise ApiError("""%s.checkValid: serial:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('weight')
      if (isinstance(value, memops.api.Implementation.Float.PythonType)):
        pass
      elif ([x for x in memops.api.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = memops.api.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.checkValid: weight:
         memops.Implementation.NonNegativeFloat input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (0.0 <= value)):
        raise ApiError("""%s.checkValid: weight:
         NonNegativeFloat constraint float_value_ge_0 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.checkValid: weight:
         NonNegativeFloat constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('access')
      if (value is not None):
        from memops.api.AccessControl import AccessObject as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: access:
           value is not of class memops.AccessControl.AccessObject""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('dataObjects')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: access:
           non-reciprocal link DihedralConstraint from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('constraintGroups')
      for value in values:
        if (not isinstance(value, ConstraintGroup)):
          raise ApiError("""%s.checkValid: constraintGroups:
           value is not of class ccp.nmr.NmrConstraint.ConstraintGroup""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('constraints')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: constraintGroups:
           non-reciprocal link DihedralConstraint from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: constraintGroups:
           Link constraintGroups between objects from separate partitions
           - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = dataDict.get('items').values()
      for value in values:
        if (not isinstance(value, DihedralConstraintItem)):
          raise ApiError("""%s.checkValid: items:
           value is not of class ccp.nmr.NmrConstraint.DihedralConstraintItem""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('constraint')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: items:
           non-reciprocal link DihedralConstraint from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      value = dataDict.get('method')
      if (value is not None):
        from ccp.api.general.Method import Method as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: method:
           value is not of class ccp.general.Method.Method""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('constraints')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: method:
           non-reciprocal link DihedralConstraint from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('nmrConstraintValidations')
      for value in values:
        from ccp.api.molecule.Validation import NmrConstraintValidation as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: nmrConstraintValidations:
           value is not of class ccp.molecule.Validation.NmrConstraintValidation""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('nmrConstraints')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: nmrConstraintValidations:
           non-reciprocal link DihedralConstraint from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        yy2 = yy1.__dict__.get('nmrConstraintStore')
        if (not (xx1 is yy2)):
          raise ApiError("""%s.checkValid: nmrConstraintValidations:
           Link nmrConstraintValidations between objects from separate partitions
           - ccp.molecule.Validation.ValidationStore.nmrConstraintStore not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      value = dataDict.get('parentList')
      if (not isinstance(value, DihedralConstraintList)):
        raise ApiError("""%s.checkValid: parentList:
         value is not of class ccp.nmr.NmrConstraint.DihedralConstraintList""" % self.qualifiedName
         + ": %s" % (value,)
        )

      values = dataDict.get('peakContribs').values()
      for value in values:
        if (not isinstance(value, ConstraintPeakContrib)):
          raise ApiError("""%s.checkValid: peakContribs:
           value is not of class ccp.nmr.NmrConstraint.ConstraintPeakContrib""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('constraint')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: peakContribs:
           non-reciprocal link DihedralConstraint from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = self.getPeaks()
      for value in values:
        from ccp.api.nmr.Nmr import Peak as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: peaks:
           value is not of class ccp.nmr.Nmr.Peak""" % self.qualifiedName
           + ": %s" % (value,)
          )

        xx1 = dataDict.get('topObject')
        xx2 = xx1.__dict__.get('nmrProject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx2 is yy1)):
          raise ApiError("""%s.checkValid: peaks:
           Link peaks between objects from separate partitions
           - ccp.nmr.NmrConstraint.NmrConstraintStore.nmrProject not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = dataDict.get('resonances')
      for value in values:
        if (not isinstance(value, FixedResonance)):
          raise ApiError("""%s.checkValid: resonances:
           value is not of class ccp.nmr.NmrConstraint.FixedResonance""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('dihedralConstraints')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: resonances:
           non-reciprocal link DihedralConstraint from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('violations')
      for value in values:
        if (not isinstance(value, Violation)):
          raise ApiError("""%s.checkValid: violations:
           value is not of class ccp.nmr.NmrConstraint.Violation""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('constraint')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: violations:
           non-reciprocal link DihedralConstraint from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: violations:
           Link violations between objects from separate partitions
           - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    # check explicit class constraints
    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('details')
    value = dataDict.get('origData')
    value = dataDict.get('weight')
    if (value is None):
      raise ApiError("""%s.checkValid: weight:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    # check roles
    value = dataDict.get('access')
    values = dataDict.get('constraintGroups')
    values = dataDict.get('items').values()
    value = dataDict.get('method')
    values = dataDict.get('nmrConstraintValidations')
    for value in values:
      ll= value.keywordDefinition.targetNames
      isValid = (not ll or self.qualifiedName in ll)
      if (not (isValid)):
        raise ApiError("""%s.checkValid: nmrConstraintValidations:
         nmrConstraintValidations constraint KeywordDefinition_fits_Constraint violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    value = dataDict.get('parentList')
    if (value is None):
      raise ApiError("""%s.checkValid: parentList:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    values = dataDict.get('peakContribs').values()
    values = dataDict.get('resonances')
    if (not (len(values) == 4)):
      raise ApiError("""%s.checkValid: resonances:
       locard, hicard: values must be of length == 4""" % self.qualifiedName
       + ": %s" % (self,)
      )

    values = dataDict.get('violations')

  delete = memops.api.Implementation.DataObject.delete

  findAllApplicationData = memops.api.Implementation.DataObject.findAllApplicationData

  findAllConstraintGroups = AbstractConstraint.findAllConstraintGroups
  
  def findAllItems(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.DihedralConstraint.items
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('items').values()
      result = set(currentValues)

    else:
      currentValues = dataDict.get('items').values()
      result = set()
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('error', 'lowerLimit', 'serial', 'targetValue', 'upperLimit', 'access', 'constraint',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result.add(v)

    return result

  findAllNmrConstraintValidations = AbstractConstraint.findAllNmrConstraintValidations

  findAllPeakContribs = AbstractConstraint.findAllPeakContribs

  findAllPeaks = AbstractConstraint.findAllPeaks
  
  def findAllResonances(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.DihedralConstraint.resonances
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('resonances')
      result = list(currentValues)

    else:
      currentValues = dataDict.get('resonances')
      result = list()
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('details', 'isotopeCode', 'name', 'resonanceSerial', 'serial', 'access', 'nmrConstraintStore', 'resonanceSet',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.append(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result.append(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result.append(v)

    return result

  findAllViolations = AbstractConstraint.findAllViolations

  findFirstApplicationData = memops.api.Implementation.DataObject.findFirstApplicationData

  findFirstConstraintGroup = AbstractConstraint.findFirstConstraintGroup
  
  def findFirstItem(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.DihedralConstraint.items
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('items').values()
      if (currentValues):
        result = iter(currentValues).next()
      else:
        result = None

    else:
      objKey = conditions.get('serial')
      if (objKey is not None):
        result = dataDict.get('items').get(objKey)

        if (result is None):
          return result

        elif (len(conditions) <= 1):
          return result

        else:
          currentValues = set()
          currentValues.add(result)

      else:
        currentValues = dataDict.get('items').values()

      result = None
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('error', 'lowerLimit', 'serial', 'targetValue', 'upperLimit', 'access', 'constraint',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result = v; break

    return result

  findFirstNmrConstraintValidation = AbstractConstraint.findFirstNmrConstraintValidation

  findFirstPeak = AbstractConstraint.findFirstPeak

  findFirstPeakContrib = AbstractConstraint.findFirstPeakContrib
  
  def findFirstResonance(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.DihedralConstraint.resonances
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('resonances')
      if (currentValues):
        result = currentValues[0]
      else:
        result = None

    else:
      currentValues = dataDict.get('resonances')
      result = None
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('details', 'isotopeCode', 'name', 'resonanceSerial', 'serial', 'access', 'nmrConstraintStore', 'resonanceSet',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result = v; break

    return result

  findFirstViolation = AbstractConstraint.findFirstViolation
  
  def get(self, name):
    """
    GetAttr for ccp.nmr.NmrConstraint.DihedralConstraint
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getAccess = memops.api.Implementation.DataObject.getAccess

  getApplicationData = memops.api.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.DihedralConstraint
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (3 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.DihedralConstraint'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (2 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.DihedralConstraint'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-2]
      obj2 = obj1.__dict__.get('constraintLists').get(objKey)

      if (obj2 is not None):
        objKey = fullKey[-1]
        obj3 = obj2.__dict__.get('constraints').get(objKey)
        result = obj3

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = memops.api.Implementation.MemopsObject.getByNavigation

  getClassName = memops.api.Implementation.ComplexDataType.getClassName

  getConstraintGroups = AbstractConstraint.getConstraintGroups

  getDetails = AbstractConstraint.getDetails

  getExpandedKey = memops.api.Implementation.MemopsObject.getExpandedKey

  getFieldNames = memops.api.Implementation.ComplexDataType.getFieldNames
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccp.nmr.NmrConstraint.DihedralConstraint
    """
    dataDict = self.__dict__
    result = list()

    obj2 = dataDict.get('parentList')
    obj1 = obj2.__dict__.get('nmrConstraintStore')

    if (useGuid):
      result.append(obj1.__dict__.get('guid'))
    else:
      result.append(obj1.__dict__.get('serial'))

    result.append(obj2.__dict__.get('serial'))
    result.append(dataDict.get('serial'))

    return result

  getInConstructor = memops.api.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = memops.api.Implementation.MemopsObject.getIsDeleted
  
  def getItems(self):
    """
    Get for ccp.nmr.NmrConstraint.DihedralConstraint.items
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('items').values()
    result = frozenset(tempVar)
    return result
  
  def getLocalKey(self):
    """
    GetLocalKey for ccp.nmr.NmrConstraint.DihedralConstraint
    """
    dataDict = self.__dict__
    result = dataDict.get('serial')
    return result

  getMetaclass = memops.api.Implementation.ComplexDataType.getMetaclass

  getMethod = AbstractConstraint.getMethod

  getNmrConstraintValidations = AbstractConstraint.getNmrConstraintValidations

  getOrigData = AbstractConstraint.getOrigData

  getPackageName = memops.api.Implementation.ComplexDataType.getPackageName

  getPackageShortName = memops.api.Implementation.ComplexDataType.getPackageShortName
  
  def getParent(self):
    """
    Get for ccp.nmr.NmrConstraint.DihedralConstraint.parent
    """
    dataDict = self.__dict__
    result = dataDict.get('parentList')
    return result
  
  def getParentList(self):
    """
    Get for ccp.nmr.NmrConstraint.DihedralConstraint.parentList
    """
    dataDict = self.__dict__
    result = dataDict.get('parentList')
    return result

  getPeakContribs = AbstractConstraint.getPeakContribs

  getPeaks = AbstractConstraint.getPeaks

  getQualifiedName = memops.api.Implementation.ComplexDataType.getQualifiedName
  
  def getResonances(self):
    """
    Get for ccp.nmr.NmrConstraint.DihedralConstraint.resonances
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('resonances')
    result = tuple(tempVar)
    return result

  getRoot = memops.api.Implementation.MemopsObject.getRoot

  getSerial = AbstractConstraint.getSerial

  getTopObject = memops.api.Implementation.DataObject.getTopObject

  getViolations = AbstractConstraint.getViolations

  getWeight = AbstractConstraint.getWeight

  newConstraintPeakContrib = AbstractConstraint.newConstraintPeakContrib
  
  def newDihedralConstraintItem(self, **attrlinks):
    """
    Factory function to create ccp.nmr.NmrConstraint.DihedralConstraintItem
    """
    return DihedralConstraintItem(self, **attrlinks)

  removeApplicationData = memops.api.Implementation.DataObject.removeApplicationData

  removeConstraintGroup = AbstractConstraint.removeConstraintGroup

  removeNmrConstraintValidation = AbstractConstraint.removeNmrConstraintValidation

  removePeak = AbstractConstraint.removePeak
  
  def set(self, name, value):
    """
    SetAttr for ccp.nmr.NmrConstraint.DihedralConstraint
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setAccess = memops.api.Implementation.DataObject.setAccess

  setApplicationData = memops.api.Implementation.DataObject.setApplicationData

  setConstraintGroups = AbstractConstraint.setConstraintGroups

  setDetails = AbstractConstraint.setDetails

  setMethod = AbstractConstraint.setMethod

  setNmrConstraintValidations = AbstractConstraint.setNmrConstraintValidations

  setOrigData = AbstractConstraint.setOrigData

  setPeaks = AbstractConstraint.setPeaks
  
  def setResonances(self, values):
    """
    Set for ccp.nmr.NmrConstraint.DihedralConstraint.resonances
    """
    dataDict = self.__dict__
    xx = set(values)
    values = list(values)
    if (len(values) != len(xx)):
      raise ApiError("""%s.setResonances:
       values may not contain duplicates""" % self.qualifiedName
       + ": %s" % (self,)
      )

    for value in values:
      if (not isinstance(value, FixedResonance)):
        raise ApiError("""%s.setResonances:
         value is not of class ccp.nmr.NmrConstraint.FixedResonance""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValues = dataDict.get('resonances')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setResonances:
       called on deleted object""" % self.qualifiedName
      )

    for obj in values:
      if (obj.__dict__.get('isDeleted')):
        raise ApiError("""%s.setResonances:
         an object in values is deleted""" % self.qualifiedName
        )

    if (values == currentValues):
      return

    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setResonances:
         cannot set resonances, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (not (len(values) == 4)):
        raise ApiError("""%s.setResonances:
         locard, hicard: values must be of length == 4""" % self.qualifiedName
         + ": %s" % (self,)
        )

      xx1 = dataDict.get('topObject')
      for value in values:
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.setResonances:
           Link resonances between objects from separate partitions
           - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    for cv in currentValues:
      if (not (cv in values)):
        oldSelves = cv.__dict__.get('dihedralConstraints')
        oldSelves.remove(self)

    for cv in values:
      if (not (cv in currentValues)):
        oldSelves = cv.__dict__.get('dihedralConstraints')
        oldSelves.add(self)

    dataDict['resonances'] = values

    # doNotifies

  setSerial = AbstractConstraint.setSerial

  setViolations = AbstractConstraint.setViolations

  setWeight = AbstractConstraint.setWeight

  sortedConstraintGroups = AbstractConstraint.sortedConstraintGroups
  
  def sortedItems(self):
    """
    Sorted for ccp.nmr.NmrConstraint.DihedralConstraint.items
    """
    dataDict = self.__dict__
    sortdd = dataDict.get('items')
    
    ll = sortdd.keys()
    ll.sort()
    result = [sortdd[x] for x in ll]
    return result

  sortedNmrConstraintValidations = AbstractConstraint.sortedNmrConstraintValidations

  sortedPeakContribs = AbstractConstraint.sortedPeakContribs

  sortedPeaks = AbstractConstraint.sortedPeaks

  sortedViolations = AbstractConstraint.sortedViolations

  toDetailedString = memops.api.Implementation.ComplexDataType.toDetailedString

  applicationData = memops.api.Implementation.DataObject.applicationData

  className = memops.api.Implementation.ComplexDataType.className

  details = AbstractConstraint.details

  fieldNames = memops.api.Implementation.ComplexDataType.fieldNames

  inConstructor = memops.api.Implementation.ComplexDataType.inConstructor

  isDeleted = memops.api.Implementation.MemopsObject.isDeleted

  metaclass = memops.api.Implementation.ComplexDataType.metaclass

  origData = AbstractConstraint.origData

  packageName = memops.api.Implementation.ComplexDataType.packageName

  packageShortName = memops.api.Implementation.ComplexDataType.packageShortName

  qualifiedName = memops.api.Implementation.ComplexDataType.qualifiedName

  serial = AbstractConstraint.serial

  weight = AbstractConstraint.weight

  access = memops.api.Implementation.DataObject.access

  constraintGroups = AbstractConstraint.constraintGroups
  
  items = property(getItems,  None, None,
  r"""child link to class DihedralConstraintItem
  """)

  method = AbstractConstraint.method

  nmrConstraintValidations = AbstractConstraint.nmrConstraintValidations
  
  parent = property(getParent, None, None,
  r"""link to parent object - synonym for parentList
  """)
  
  parentList = property(getParentList,  None, None,
  r"""parent link
  """)

  peakContribs = AbstractConstraint.peakContribs

  peaks = AbstractConstraint.peaks
  
  resonances = property(getResonances, setResonances, None,
  r"""Resonances (in order from one end to the other) defining the dihedral 
  angle being constrained
  """)

  root = memops.api.Implementation.MemopsObject.root

  topObject = memops.api.Implementation.DataObject.topObject

  violations = AbstractConstraint.violations

###############################################################################
class SingleConstraint(AbstractConstraint):
  r"""Constraint with a single interval for the constrained value. May be used 
to constraint to a specific value (targetValue) to constrain to within 
an interval, or both.
  """
  #   from data model element ccp.nmr.NmrConstraint.SingleConstraint revision 1.35.2.9
  _metaclass = metaPackage.getElement('SingleConstraint')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('applicationData', 'className', 'details', 'error', 'fieldNames', 'inConstructor', 'isDeleted', 'lowerLimit', 'metaclass', 'origData', 'packageName', 'packageShortName', 'qualifiedName', 'serial', 'targetValue', 'upperLimit', 'weight', 'access', 'constraintGroups', 'method', 'nmrConstraintValidations', 'parentList', 'peakContribs', 'peaks', 'root', 'topObject', 'violations',)

  __init__ = memops.api.Implementation.ComplexDataType.__init__

  addApplicationData = memops.api.Implementation.DataObject.addApplicationData

  addConstraintGroup = AbstractConstraint.addConstraintGroup

  addNmrConstraintValidation = AbstractConstraint.addNmrConstraintValidation

  addPeak = AbstractConstraint.addPeak

  checkAllValid = memops.api.Implementation.ComplexDataType.checkAllValid

  checkValid = memops.api.Implementation.ComplexDataType.checkValid

  delete = memops.api.Implementation.DataObject.delete

  findAllApplicationData = memops.api.Implementation.DataObject.findAllApplicationData

  findAllConstraintGroups = AbstractConstraint.findAllConstraintGroups

  findAllNmrConstraintValidations = AbstractConstraint.findAllNmrConstraintValidations

  findAllPeakContribs = AbstractConstraint.findAllPeakContribs

  findAllPeaks = AbstractConstraint.findAllPeaks

  findAllViolations = AbstractConstraint.findAllViolations

  findFirstApplicationData = memops.api.Implementation.DataObject.findFirstApplicationData

  findFirstConstraintGroup = AbstractConstraint.findFirstConstraintGroup

  findFirstNmrConstraintValidation = AbstractConstraint.findFirstNmrConstraintValidation

  findFirstPeak = AbstractConstraint.findFirstPeak

  findFirstPeakContrib = AbstractConstraint.findFirstPeakContrib

  findFirstViolation = AbstractConstraint.findFirstViolation

  getAccess = memops.api.Implementation.DataObject.getAccess

  getApplicationData = memops.api.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.SingleConstraint
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (3 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.SingleConstraint'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (2 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.SingleConstraint'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-2]
      obj2 = obj1.__dict__.get('constraintLists').get(objKey)

      if (obj2 is not None):
        objKey = fullKey[-1]
        obj3 = obj2.__dict__.get('constraints').get(objKey)
        if (isinstance(obj3, SingleConstraint)):
          result = obj3

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = memops.api.Implementation.MemopsObject.getByNavigation

  getClassName = memops.api.Implementation.ComplexDataType.getClassName

  getConstraintGroups = AbstractConstraint.getConstraintGroups

  getDetails = AbstractConstraint.getDetails
  
  def getError(self):
    """
    Get for ccp.nmr.NmrConstraint.SingleConstraint.error
    """
    dataDict = self.__dict__
    result = dataDict.get('error')
    return result

  getExpandedKey = memops.api.Implementation.MemopsObject.getExpandedKey

  getFieldNames = memops.api.Implementation.ComplexDataType.getFieldNames

  getFullKey = AbstractConstraint.getFullKey

  getInConstructor = memops.api.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = memops.api.Implementation.MemopsObject.getIsDeleted

  getLocalKey = AbstractConstraint.getLocalKey
  
  def getLowerLimit(self):
    """
    Get for ccp.nmr.NmrConstraint.SingleConstraint.lowerLimit
    """
    dataDict = self.__dict__
    result = dataDict.get('lowerLimit')
    return result

  getMetaclass = memops.api.Implementation.ComplexDataType.getMetaclass

  getMethod = AbstractConstraint.getMethod

  getNmrConstraintValidations = AbstractConstraint.getNmrConstraintValidations

  getOrigData = AbstractConstraint.getOrigData

  getPackageName = memops.api.Implementation.ComplexDataType.getPackageName

  getPackageShortName = memops.api.Implementation.ComplexDataType.getPackageShortName

  getParentList = AbstractConstraint.getParentList

  getPeakContribs = AbstractConstraint.getPeakContribs

  getPeaks = AbstractConstraint.getPeaks

  getQualifiedName = memops.api.Implementation.ComplexDataType.getQualifiedName

  getRoot = memops.api.Implementation.MemopsObject.getRoot

  getSerial = AbstractConstraint.getSerial
  
  def getTargetValue(self):
    """
    Get for ccp.nmr.NmrConstraint.SingleConstraint.targetValue
    """
    dataDict = self.__dict__
    result = dataDict.get('targetValue')
    return result

  getTopObject = memops.api.Implementation.DataObject.getTopObject
  
  def getUpperLimit(self):
    """
    Get for ccp.nmr.NmrConstraint.SingleConstraint.upperLimit
    """
    dataDict = self.__dict__
    result = dataDict.get('upperLimit')
    return result

  getViolations = AbstractConstraint.getViolations

  getWeight = AbstractConstraint.getWeight

  newConstraintPeakContrib = AbstractConstraint.newConstraintPeakContrib

  removeApplicationData = memops.api.Implementation.DataObject.removeApplicationData

  removeConstraintGroup = AbstractConstraint.removeConstraintGroup

  removeNmrConstraintValidation = AbstractConstraint.removeNmrConstraintValidation

  removePeak = AbstractConstraint.removePeak

  setAccess = memops.api.Implementation.DataObject.setAccess

  setApplicationData = memops.api.Implementation.DataObject.setApplicationData

  setConstraintGroups = AbstractConstraint.setConstraintGroups

  setDetails = AbstractConstraint.setDetails
  
  def setError(self, value):
    """
    Set for ccp.nmr.NmrConstraint.SingleConstraint.error
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, memops.api.Implementation.Float.PythonType)):
        pass
      elif ([x for x in memops.api.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = memops.api.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.setError:
         memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.setError:
         Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('error')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setError:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setError:
       called on deleted object""" % self.qualifiedName
      )

    if (value == currentValue):
      return

    if (notOverride):
      pass

    dataDict['error'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setError')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  def setLowerLimit(self, value):
    """
    Set for ccp.nmr.NmrConstraint.SingleConstraint.lowerLimit
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, memops.api.Implementation.Float.PythonType)):
        pass
      elif ([x for x in memops.api.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = memops.api.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.setLowerLimit:
         memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.setLowerLimit:
         Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('lowerLimit')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setLowerLimit:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setLowerLimit:
       called on deleted object""" % self.qualifiedName
      )

    if (value == currentValue):
      return

    if (notOverride):
      pass

    dataDict['lowerLimit'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setLowerLimit')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  setMethod = AbstractConstraint.setMethod

  setNmrConstraintValidations = AbstractConstraint.setNmrConstraintValidations

  setOrigData = AbstractConstraint.setOrigData

  setPeaks = AbstractConstraint.setPeaks

  setSerial = AbstractConstraint.setSerial
  
  def setTargetValue(self, value):
    """
    Set for ccp.nmr.NmrConstraint.SingleConstraint.targetValue
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, memops.api.Implementation.Float.PythonType)):
        pass
      elif ([x for x in memops.api.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = memops.api.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.setTargetValue:
         memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.setTargetValue:
         Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('targetValue')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setTargetValue:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setTargetValue:
       called on deleted object""" % self.qualifiedName
      )

    if (value == currentValue):
      return

    if (notOverride):
      pass

    dataDict['targetValue'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setTargetValue')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  def setUpperLimit(self, value):
    """
    Set for ccp.nmr.NmrConstraint.SingleConstraint.upperLimit
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, memops.api.Implementation.Float.PythonType)):
        pass
      elif ([x for x in memops.api.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = memops.api.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.setUpperLimit:
         memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.setUpperLimit:
         Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('upperLimit')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setUpperLimit:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setUpperLimit:
       called on deleted object""" % self.qualifiedName
      )

    if (value == currentValue):
      return

    if (notOverride):
      pass

    dataDict['upperLimit'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setUpperLimit')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  setViolations = AbstractConstraint.setViolations

  setWeight = AbstractConstraint.setWeight

  sortedConstraintGroups = AbstractConstraint.sortedConstraintGroups

  sortedNmrConstraintValidations = AbstractConstraint.sortedNmrConstraintValidations

  sortedPeakContribs = AbstractConstraint.sortedPeakContribs

  sortedPeaks = AbstractConstraint.sortedPeaks

  sortedViolations = AbstractConstraint.sortedViolations

  toDetailedString = memops.api.Implementation.ComplexDataType.toDetailedString

  applicationData = memops.api.Implementation.DataObject.applicationData

  className = memops.api.Implementation.ComplexDataType.className

  details = AbstractConstraint.details
  
  error = property(getError, setError, None,
  r"""Uncertainty (standard deviation) of targetValue.
  """)

  fieldNames = memops.api.Implementation.ComplexDataType.fieldNames

  inConstructor = memops.api.Implementation.ComplexDataType.inConstructor

  isDeleted = memops.api.Implementation.MemopsObject.isDeleted
  
  lowerLimit = property(getLowerLimit, setLowerLimit, None,
  r"""Minimum allowed value of constrained parameter. If set, energy penalty 
  is zero for values above lowerLimit.
  """)

  metaclass = memops.api.Implementation.ComplexDataType.metaclass

  origData = AbstractConstraint.origData

  packageName = memops.api.Implementation.ComplexDataType.packageName

  packageShortName = memops.api.Implementation.ComplexDataType.packageShortName

  qualifiedName = memops.api.Implementation.ComplexDataType.qualifiedName

  serial = AbstractConstraint.serial
  
  targetValue = property(getTargetValue, setTargetValue, None,
  r"""Desired value of constrained parameter
  """)
  
  upperLimit = property(getUpperLimit, setUpperLimit, None,
  r"""Maximum allowed value of constrained parameter
  """)

  weight = AbstractConstraint.weight

  access = memops.api.Implementation.DataObject.access

  constraintGroups = AbstractConstraint.constraintGroups

  method = AbstractConstraint.method

  nmrConstraintValidations = AbstractConstraint.nmrConstraintValidations

  parentList = AbstractConstraint.parentList

  peakContribs = AbstractConstraint.peakContribs

  peaks = AbstractConstraint.peaks

  root = memops.api.Implementation.MemopsObject.root

  topObject = memops.api.Implementation.DataObject.topObject

  violations = AbstractConstraint.violations

###############################################################################
class RdcConstraintList(AbstractConstraintList):
  r"""List of reduced dipolar coupling constraints, in the form of RDC values 
that should be reproduced by the structure.
  """
  #   from data model element ccp.nmr.NmrConstraint.RdcConstraintList revision 1.36.2.9
  _metaclass = metaPackage.getElement('RdcConstraintList')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('applicationData', 'className', 'details', 'experimentSerials', 'fieldNames', 'inConstructor', 'isDeleted', 'measureListSerials', 'metaclass', 'name', 'packageName', 'packageShortName', 'qualifiedName', 'serial', 'unit', 'usedForCalculation', 'access', 'conditionState', 'constraints', 'experiments', 'measurementLists', 'method', 'nmrConstraintListValidations', 'nmrConstraintStore', 'nmrSimEnergyTerms', 'parent', 'root', 'topObject',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccp.nmr.NmrConstraint.RdcConstraintList
    """
    dataDict = self.__dict__
    dataDict['nmrConstraintStore'] = parent
    if (not isinstance(parent, NmrConstraintStore)):
      raise ApiError("""%s.__init__:
       value is not of class ccp.nmr.NmrConstraint.NmrConstraintStore""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:
      if (not ((parent.__dict__.get('isLoaded') or parent.__dict__.get('isReading')))):
        parent.load()

      dataDict['applicationData'] = list()
      dataDict['details'] = None
      dataDict['experimentSerials'] = set()
      dataDict['measureListSerials'] = set()
      dataDict['name'] = None
      dataDict['serial'] = None
      dataDict['unit'] = None
      dataDict['usedForCalculation'] = True
      dataDict['access'] = None
      dataDict['conditionState'] = None
      dataDict['constraints'] = {}
      dataDict['method'] = None
      dataDict['nmrConstraintListValidations'] = set()
      dataDict['nmrSimEnergyTerms'] = set()

      dataDict['inConstructor'] = True
      try:
        
        for key, value in attrlinks.iteritems():
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        del dataDict['inConstructor']
      except:
        print "ERROR in ccp.nmr.NmrConstraint.RdcConstraintList.__init__"
        del dataDict['inConstructor']
        raise

      if (notOverride):
        if (dataDict.get('serial') is None):
          dataDict['inConstructor'] = True
          self.setSerial(-1)
          del dataDict['inConstructor']
        else:
          raise ApiError("""%s.__init__:
           Cannot pass in explicit serial if not reading""" % self.qualifiedName
           + ": %s:%s" % (parent, 'ccp.nmr.NmrConstraint.RdcConstraintList')
          )

      serialDict = {}
      serialDict['constraints'] = 0
      dataDict['_serialDict'] = serialDict

      if (notIsReading):
        childrenDict = parent.__dict__.get('constraintLists')
        objKey = dataDict.get('serial')
        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['serial'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        print '''WARNING Error in clean-up of incorrectly created object. 
        Data may be left in an illegal state'''
        del dataDict['inConstructor']
      raise exc_info[0], exc_info[1], exc_info[2]

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccp.nmr.NmrConstraint.RdcConstraintList:
       determines 
    cascading deletes to follow from delete of object.
       *Implementation 
    function* - should be called only by API delete function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
      dataDict.get('topObject').load()

    access = dataDict.get('access')
    if (access is not None):
      topObject = access.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    constraints = dataDict.get('constraints').values()
    for constraint in constraints:
      if (not (constraint in objsToBeDeleted)):
        objsToBeDeleted.add(constraint)
        objsToBeChecked.append(constraint)

    method = dataDict.get('method')
    if (method is not None):
      topObject = method.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    nmrConstraintListValidations = dataDict.get('nmrConstraintListValidations')
    pass
    for nmrConstraintListValidation in nmrConstraintListValidations:
      topObject = nmrConstraintListValidation.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    root = dataDict.get('topObject').__dict__.get('memopsRoot')
    root.refreshTopObjects('molsim.NmrSim')
    tobjList = root.__dict__.get('nmrSimStores').values()
    for tobj in tobjList:
      if (not (tobj.__dict__.get('isLoaded'))):
        tobj.load()

    nmrSimEnergyTerms = dataDict.get('nmrSimEnergyTerms')
    pass
    for nmrSimEnergyTerm in nmrSimEnergyTerms:
      topObject = nmrSimEnergyTerm.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccp.nmr.NmrConstraint.RdcConstraintList:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    access = dataDict.get('access')
    if ((access is not None and not (access in objsToBeDeleted))):
      dataObjects = access.__dict__.get('dataObjects')
      dataObjects.remove(self)

    conditionState = dataDict.get('conditionState')
    if ((conditionState is not None and not (conditionState in objsToBeDeleted))):
      constraintLists = conditionState.__dict__.get('constraintLists')
      constraintLists.remove(self)

    method = dataDict.get('method')
    if ((method is not None and not (method in objsToBeDeleted))):
      constraintLists = method.__dict__.get('constraintLists')
      constraintLists.remove(self)

    for nmrConstraintListValidation in dataDict.get('nmrConstraintListValidations'):
      if (not (nmrConstraintListValidation in objsToBeDeleted)):
        nmrConstraintLists = nmrConstraintListValidation.__dict__.get('nmrConstraintLists')
        nmrConstraintLists.remove(self)

    for nmrSimEnergyTerm in dataDict.get('nmrSimEnergyTerms'):
      if (not (nmrSimEnergyTerm in objsToBeDeleted)):
        constraintLists = nmrSimEnergyTerm.__dict__.get('constraintLists')
        constraintLists.remove(self)

    nmrConstraintStore = dataDict.get('nmrConstraintStore')
    if (not (nmrConstraintStore in objsToBeDeleted)):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = nmrConstraintStore.__dict__.get('constraintLists')
        if (self is dd.get(objKey)):
          del dd[objKey]

  addApplicationData = memops.api.Implementation.DataObject.addApplicationData

  addExperiment = AbstractConstraintList.addExperiment

  addExperimentSerial = AbstractConstraintList.addExperimentSerial

  addMeasureListSerial = AbstractConstraintList.addMeasureListSerial

  addMeasurementList = AbstractConstraintList.addMeasurementList

  addNmrConstraintListValidation = AbstractConstraintList.addNmrConstraintListValidation

  addNmrSimEnergyTerm = AbstractConstraintList.addNmrSimEnergyTerm
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccp.nmr.NmrConstraint.RdcConstraintList
    """
    dataDict = self.__dict__
    self.checkValid(complete)
    values = dataDict.get('constraints').values()
    for value in values:
      value.checkAllValid(complete)

  def checkValid(self, complete=False):
    """
    CheckValid for ccp.nmr.NmrConstraint.RdcConstraintList
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('nmrConstraintStore')
        dd = value.__dict__.get('constraintLists')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'nmrConstraintStore' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from memops.api.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('details')
      if (value is not None):
        if (isinstance(value, memops.api.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: details:
           memops.Implementation.String input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      values = dataDict.get('experimentSerials')
      for value in values:
        if (isinstance(value, memops.api.Implementation.Int.PythonType)):
          pass
        elif ([x for x in memops.api.Implementation.Int.compatibleTypes if isinstance(value, x)]):
          castValue = memops.api.Implementation.Int.create(value)
          values.remove(value)
          if (castValue in values):
            values.add(value)
            raise ApiError("""%s.checkValid: experimentSerials:
             replacement value already in unique collection """ % self.qualifiedName
             + ": %s" % (castValue,)
            )
          else:
            values.add(castValue)

          value = castValue
        else:
          raise ApiError("""%s.checkValid: experimentSerials:
           memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      values = dataDict.get('measureListSerials')
      for value in values:
        if (isinstance(value, memops.api.Implementation.Int.PythonType)):
          pass
        elif ([x for x in memops.api.Implementation.Int.compatibleTypes if isinstance(value, x)]):
          castValue = memops.api.Implementation.Int.create(value)
          values.remove(value)
          if (castValue in values):
            values.add(value)
            raise ApiError("""%s.checkValid: measureListSerials:
             replacement value already in unique collection """ % self.qualifiedName
             + ": %s" % (castValue,)
            )
          else:
            values.add(castValue)

          value = castValue
        else:
          raise ApiError("""%s.checkValid: measureListSerials:
           memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('name')
      if (value is not None):
        if (isinstance(value, memops.api.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: name:
           memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 80):
          raise ApiError("""%s.checkValid: name:
           memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: name:
           memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.splitlines()) <= 1)):
          raise ApiError("""%s.checkValid: name:
           Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, memops.api.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('serial')
      if (value is None):
        raise ApiError("""%s.checkValid: serial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, memops.api.Implementation.Int.PythonType)):
        pass
      elif ([x for x in memops.api.Implementation.Int.compatibleTypes if isinstance(value, x)]):
        value = memops.api.Implementation.Int.create(value)
      else:
        raise ApiError("""%s.checkValid: serial:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('unit')
      if (value is not None):
        if (isinstance(value, memops.api.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: unit:
           memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 32):
          raise ApiError("""%s.checkValid: unit:
           memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: unit:
           memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.split()) == 1)):
          raise ApiError("""%s.checkValid: unit:
           Word constraint contains_no_white_space violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('usedForCalculation')
      if (not (value in [True, False])):
        raise ApiError("""%s.checkValid: usedForCalculation:
         memops.Implementation.Boolean input is not in enumeration [True, False]""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('access')
      if (value is not None):
        from memops.api.AccessControl import AccessObject as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: access:
           value is not of class memops.AccessControl.AccessObject""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('dataObjects')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: access:
           non-reciprocal link RdcConstraintList from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      value = dataDict.get('conditionState')
      if (value is not None):
        if (not isinstance(value, ConditionState)):
          raise ApiError("""%s.checkValid: conditionState:
           value is not of class ccp.nmr.NmrConstraint.ConditionState""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('constraintLists')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: conditionState:
           non-reciprocal link RdcConstraintList from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('constraints').values()
      for value in values:
        if (not isinstance(value, RdcConstraint)):
          raise ApiError("""%s.checkValid: constraints:
           value is not of class ccp.nmr.NmrConstraint.RdcConstraint""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('parentList')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: constraints:
           non-reciprocal link RdcConstraintList from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = self.getExperiments()
      for value in values:
        from ccp.api.nmr.Nmr import Experiment as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: experiments:
           value is not of class ccp.nmr.Nmr.Experiment""" % self.qualifiedName
           + ": %s" % (value,)
          )

        xx1 = dataDict.get('topObject')
        xx2 = xx1.__dict__.get('nmrProject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx2 is yy1)):
          raise ApiError("""%s.checkValid: experiments:
           Link experiments between objects from separate partitions
           - ccp.nmr.NmrConstraint.NmrConstraintStore.nmrProject not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = self.getMeasurementLists()
      for value in values:
        from ccp.api.nmr.Nmr import AbstractMeasurementList as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: measurementLists:
           value is not of class ccp.nmr.Nmr.AbstractMeasurementList""" % self.qualifiedName
           + ": %s" % (value,)
          )

        xx1 = dataDict.get('topObject')
        xx2 = xx1.__dict__.get('nmrProject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx2 is yy1)):
          raise ApiError("""%s.checkValid: measurementLists:
           Link measurementLists between objects from separate partitions
           - ccp.nmr.NmrConstraint.NmrConstraintStore.nmrProject not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      value = dataDict.get('method')
      if (value is not None):
        from ccp.api.general.Method import Method as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: method:
           value is not of class ccp.general.Method.Method""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('constraintLists')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: method:
           non-reciprocal link RdcConstraintList from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('nmrConstraintListValidations')
      for value in values:
        from ccp.api.molecule.Validation import NmrConstraintListValidation as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: nmrConstraintListValidations:
           value is not of class ccp.molecule.Validation.NmrConstraintListValidation""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('nmrConstraintLists')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: nmrConstraintListValidations:
           non-reciprocal link RdcConstraintList from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        yy2 = yy1.__dict__.get('nmrConstraintStore')
        if (not (xx1 is yy2)):
          raise ApiError("""%s.checkValid: nmrConstraintListValidations:
           Link nmrConstraintListValidations between objects from separate partitions
           - ccp.molecule.Validation.ValidationStore.nmrConstraintStore not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      value = dataDict.get('nmrConstraintStore')
      if (not isinstance(value, NmrConstraintStore)):
        raise ApiError("""%s.checkValid: nmrConstraintStore:
         value is not of class ccp.nmr.NmrConstraint.NmrConstraintStore""" % self.qualifiedName
         + ": %s" % (value,)
        )

      root = dataDict.get('topObject').__dict__.get('memopsRoot')
      root.refreshTopObjects('molsim.NmrSim')
      tobjList = root.__dict__.get('nmrSimStores').values()
      for tobj in tobjList:
        if (not (tobj.__dict__.get('isLoaded'))):
          tobj.load()

      values = dataDict.get('nmrSimEnergyTerms')
      for value in values:
        from molsim.api.NmrSim import NmrSimEnergyTerm as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: nmrSimEnergyTerms:
           value is not of class molsim.NmrSim.NmrSimEnergyTerm""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('constraintLists')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: nmrSimEnergyTerms:
           non-reciprocal link RdcConstraintList from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

    # check explicit class constraints
    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('details')
    values = dataDict.get('experimentSerials')
    values = dataDict.get('measureListSerials')
    value = dataDict.get('name')
    value = dataDict.get('unit')
    value = dataDict.get('usedForCalculation')
    if (value is None):
      raise ApiError("""%s.checkValid: usedForCalculation:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    # check roles
    value = dataDict.get('access')
    value = dataDict.get('conditionState')
    values = dataDict.get('constraints').values()
    value = dataDict.get('method')
    values = dataDict.get('nmrConstraintListValidations')
    for value in values:
      ll= value.keywordDefinition.targetNames
      isValid = (not ll or self.qualifiedName in ll)
      if (not (isValid)):
        raise ApiError("""%s.checkValid: nmrConstraintListValidations:
         nmrConstraintListValidations constraint KeywordDefinition_fits_ConstraintList violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    value = dataDict.get('nmrConstraintStore')
    if (value is None):
      raise ApiError("""%s.checkValid: nmrConstraintStore:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    values = dataDict.get('nmrSimEnergyTerms')

  delete = memops.api.Implementation.DataObject.delete

  findAllApplicationData = memops.api.Implementation.DataObject.findAllApplicationData
  
  def findAllConstraints(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.RdcConstraintList.constraints
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('constraints').values()
      result = set(currentValues)

    else:
      currentValues = dataDict.get('constraints').values()
      result = set()
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('details', 'error', 'lowerLimit', 'origData', 'serial', 'targetValue', 'upperLimit', 'vectorLength', 'weight', 'access', 'method', 'parentList',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result.add(v)

    return result

  findAllExperiments = AbstractConstraintList.findAllExperiments

  findAllMeasurementLists = AbstractConstraintList.findAllMeasurementLists

  findAllNmrConstraintListValidations = AbstractConstraintList.findAllNmrConstraintListValidations

  findAllNmrSimEnergyTerms = AbstractConstraintList.findAllNmrSimEnergyTerms

  findFirstApplicationData = memops.api.Implementation.DataObject.findFirstApplicationData
  
  def findFirstConstraint(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.RdcConstraintList.constraints
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('constraints').values()
      if (currentValues):
        result = iter(currentValues).next()
      else:
        result = None

    else:
      objKey = conditions.get('serial')
      if (objKey is not None):
        result = dataDict.get('constraints').get(objKey)

        if (result is None):
          return result

        elif (len(conditions) <= 1):
          return result

        else:
          currentValues = set()
          currentValues.add(result)

      else:
        currentValues = dataDict.get('constraints').values()

      result = None
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('details', 'error', 'lowerLimit', 'origData', 'serial', 'targetValue', 'upperLimit', 'vectorLength', 'weight', 'access', 'method', 'parentList',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result = v; break

    return result

  findFirstExperiment = AbstractConstraintList.findFirstExperiment

  findFirstMeasurementList = AbstractConstraintList.findFirstMeasurementList

  findFirstNmrConstraintListValidation = AbstractConstraintList.findFirstNmrConstraintListValidation

  findFirstNmrSimEnergyTerm = AbstractConstraintList.findFirstNmrSimEnergyTerm
  
  def get(self, name):
    """
    GetAttr for ccp.nmr.NmrConstraint.RdcConstraintList
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getAccess = memops.api.Implementation.DataObject.getAccess

  getApplicationData = memops.api.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.RdcConstraintList
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (2 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.RdcConstraintList'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (1 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.RdcConstraintList'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-1]
      obj2 = obj1.__dict__.get('constraintLists').get(objKey)
      if (isinstance(obj2, RdcConstraintList)):
        result = obj2

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = memops.api.Implementation.MemopsObject.getByNavigation

  getClassName = memops.api.Implementation.ComplexDataType.getClassName

  getConditionState = AbstractConstraintList.getConditionState
  
  def getConstraints(self):
    """
    Get for ccp.nmr.NmrConstraint.RdcConstraintList.constraints
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('constraints').values()
    result = frozenset(tempVar)
    return result

  getDetails = AbstractConstraintList.getDetails

  getExpandedKey = memops.api.Implementation.MemopsObject.getExpandedKey

  getExperimentSerials = AbstractConstraintList.getExperimentSerials

  getExperiments = AbstractConstraintList.getExperiments

  getFieldNames = memops.api.Implementation.ComplexDataType.getFieldNames

  getFullKey = AbstractConstraintList.getFullKey

  getInConstructor = memops.api.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = memops.api.Implementation.MemopsObject.getIsDeleted

  getLocalKey = AbstractConstraintList.getLocalKey

  getMeasureListSerials = AbstractConstraintList.getMeasureListSerials

  getMeasurementLists = AbstractConstraintList.getMeasurementLists

  getMetaclass = memops.api.Implementation.ComplexDataType.getMetaclass

  getMethod = AbstractConstraintList.getMethod

  getName = AbstractConstraintList.getName

  getNmrConstraintListValidations = AbstractConstraintList.getNmrConstraintListValidations

  getNmrConstraintStore = AbstractConstraintList.getNmrConstraintStore

  getNmrSimEnergyTerms = AbstractConstraintList.getNmrSimEnergyTerms

  getPackageName = memops.api.Implementation.ComplexDataType.getPackageName

  getPackageShortName = memops.api.Implementation.ComplexDataType.getPackageShortName

  getParent = AbstractConstraintList.getParent

  getQualifiedName = memops.api.Implementation.ComplexDataType.getQualifiedName

  getRoot = memops.api.Implementation.MemopsObject.getRoot

  getSerial = AbstractConstraintList.getSerial

  getTopObject = memops.api.Implementation.DataObject.getTopObject

  getUnit = AbstractConstraintList.getUnit

  getUsedForCalculation = AbstractConstraintList.getUsedForCalculation
  
  def newRdcConstraint(self, **attrlinks):
    """
    Factory function to create ccp.nmr.NmrConstraint.RdcConstraint
    """
    return RdcConstraint(self, **attrlinks)

  removeApplicationData = memops.api.Implementation.DataObject.removeApplicationData

  removeExperiment = AbstractConstraintList.removeExperiment

  removeExperimentSerial = AbstractConstraintList.removeExperimentSerial

  removeMeasureListSerial = AbstractConstraintList.removeMeasureListSerial

  removeMeasurementList = AbstractConstraintList.removeMeasurementList

  removeNmrConstraintListValidation = AbstractConstraintList.removeNmrConstraintListValidation

  removeNmrSimEnergyTerm = AbstractConstraintList.removeNmrSimEnergyTerm
  
  def set(self, name, value):
    """
    SetAttr for ccp.nmr.NmrConstraint.RdcConstraintList
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setAccess = memops.api.Implementation.DataObject.setAccess

  setApplicationData = memops.api.Implementation.DataObject.setApplicationData

  setConditionState = AbstractConstraintList.setConditionState

  setDetails = AbstractConstraintList.setDetails

  setExperimentSerials = AbstractConstraintList.setExperimentSerials

  setExperiments = AbstractConstraintList.setExperiments

  setMeasureListSerials = AbstractConstraintList.setMeasureListSerials

  setMeasurementLists = AbstractConstraintList.setMeasurementLists

  setMethod = AbstractConstraintList.setMethod

  setName = AbstractConstraintList.setName

  setNmrConstraintListValidations = AbstractConstraintList.setNmrConstraintListValidations

  setNmrSimEnergyTerms = AbstractConstraintList.setNmrSimEnergyTerms

  setSerial = AbstractConstraintList.setSerial

  setUnit = AbstractConstraintList.setUnit

  setUsedForCalculation = AbstractConstraintList.setUsedForCalculation
  
  def sortedConstraints(self):
    """
    Sorted for ccp.nmr.NmrConstraint.RdcConstraintList.constraints
    """
    dataDict = self.__dict__
    sortdd = dataDict.get('constraints')
    
    ll = sortdd.keys()
    ll.sort()
    result = [sortdd[x] for x in ll]
    return result

  sortedExperiments = AbstractConstraintList.sortedExperiments

  sortedMeasurementLists = AbstractConstraintList.sortedMeasurementLists

  sortedNmrConstraintListValidations = AbstractConstraintList.sortedNmrConstraintListValidations

  sortedNmrSimEnergyTerms = AbstractConstraintList.sortedNmrSimEnergyTerms

  toDetailedString = memops.api.Implementation.ComplexDataType.toDetailedString

  applicationData = memops.api.Implementation.DataObject.applicationData

  className = memops.api.Implementation.ComplexDataType.className

  details = AbstractConstraintList.details

  experimentSerials = AbstractConstraintList.experimentSerials

  fieldNames = memops.api.Implementation.ComplexDataType.fieldNames

  inConstructor = memops.api.Implementation.ComplexDataType.inConstructor

  isDeleted = memops.api.Implementation.MemopsObject.isDeleted

  measureListSerials = AbstractConstraintList.measureListSerials

  metaclass = memops.api.Implementation.ComplexDataType.metaclass

  name = AbstractConstraintList.name

  packageName = memops.api.Implementation.ComplexDataType.packageName

  packageShortName = memops.api.Implementation.ComplexDataType.packageShortName

  qualifiedName = memops.api.Implementation.ComplexDataType.qualifiedName

  serial = AbstractConstraintList.serial

  unit = AbstractConstraintList.unit

  usedForCalculation = AbstractConstraintList.usedForCalculation

  access = memops.api.Implementation.DataObject.access

  conditionState = AbstractConstraintList.conditionState
  
  constraints = property(getConstraints,  None, None,
  r"""child link to class RdcConstraint
  """)

  experiments = AbstractConstraintList.experiments

  measurementLists = AbstractConstraintList.measurementLists

  method = AbstractConstraintList.method

  nmrConstraintListValidations = AbstractConstraintList.nmrConstraintListValidations

  nmrConstraintStore = AbstractConstraintList.nmrConstraintStore

  nmrSimEnergyTerms = AbstractConstraintList.nmrSimEnergyTerms

  parent = AbstractConstraintList.parent

  root = memops.api.Implementation.MemopsObject.root

  topObject = memops.api.Implementation.DataObject.topObject

###############################################################################
class HBondConstraintList(AbstractConstraintList):
  r"""List of hydrogen bond constraints.
  """
  #   from data model element ccp.nmr.NmrConstraint.HBondConstraintList revision 1.36.2.9
  _metaclass = metaPackage.getElement('HBondConstraintList')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('applicationData', 'className', 'details', 'experimentSerials', 'fieldNames', 'inConstructor', 'isDeleted', 'measureListSerials', 'metaclass', 'name', 'packageName', 'packageShortName', 'qualifiedName', 'serial', 'unit', 'usedForCalculation', 'access', 'conditionState', 'constraints', 'experiments', 'measurementLists', 'method', 'nmrConstraintListValidations', 'nmrConstraintStore', 'nmrSimEnergyTerms', 'parent', 'root', 'topObject',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccp.nmr.NmrConstraint.HBondConstraintList
    """
    dataDict = self.__dict__
    dataDict['nmrConstraintStore'] = parent
    if (not isinstance(parent, NmrConstraintStore)):
      raise ApiError("""%s.__init__:
       value is not of class ccp.nmr.NmrConstraint.NmrConstraintStore""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:
      if (not ((parent.__dict__.get('isLoaded') or parent.__dict__.get('isReading')))):
        parent.load()

      dataDict['applicationData'] = list()
      dataDict['details'] = None
      dataDict['experimentSerials'] = set()
      dataDict['measureListSerials'] = set()
      dataDict['name'] = None
      dataDict['serial'] = None
      dataDict['unit'] = None
      dataDict['usedForCalculation'] = True
      dataDict['access'] = None
      dataDict['conditionState'] = None
      dataDict['constraints'] = {}
      dataDict['method'] = None
      dataDict['nmrConstraintListValidations'] = set()
      dataDict['nmrSimEnergyTerms'] = set()

      dataDict['inConstructor'] = True
      try:
        
        for key, value in attrlinks.iteritems():
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        del dataDict['inConstructor']
      except:
        print "ERROR in ccp.nmr.NmrConstraint.HBondConstraintList.__init__"
        del dataDict['inConstructor']
        raise

      if (notOverride):
        if (dataDict.get('serial') is None):
          dataDict['inConstructor'] = True
          self.setSerial(-1)
          del dataDict['inConstructor']
        else:
          raise ApiError("""%s.__init__:
           Cannot pass in explicit serial if not reading""" % self.qualifiedName
           + ": %s:%s" % (parent, 'ccp.nmr.NmrConstraint.HBondConstraintList')
          )

      serialDict = {}
      serialDict['constraints'] = 0
      dataDict['_serialDict'] = serialDict

      if (notIsReading):
        childrenDict = parent.__dict__.get('constraintLists')
        objKey = dataDict.get('serial')
        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['serial'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        print '''WARNING Error in clean-up of incorrectly created object. 
        Data may be left in an illegal state'''
        del dataDict['inConstructor']
      raise exc_info[0], exc_info[1], exc_info[2]

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccp.nmr.NmrConstraint.HBondConstraintList:
       determines 
    cascading deletes to follow from delete of object.
       *Implementation 
    function* - should be called only by API delete function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
      dataDict.get('topObject').load()

    access = dataDict.get('access')
    if (access is not None):
      topObject = access.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    constraints = dataDict.get('constraints').values()
    for constraint in constraints:
      if (not (constraint in objsToBeDeleted)):
        objsToBeDeleted.add(constraint)
        objsToBeChecked.append(constraint)

    method = dataDict.get('method')
    if (method is not None):
      topObject = method.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    nmrConstraintListValidations = dataDict.get('nmrConstraintListValidations')
    pass
    for nmrConstraintListValidation in nmrConstraintListValidations:
      topObject = nmrConstraintListValidation.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    root = dataDict.get('topObject').__dict__.get('memopsRoot')
    root.refreshTopObjects('molsim.NmrSim')
    tobjList = root.__dict__.get('nmrSimStores').values()
    for tobj in tobjList:
      if (not (tobj.__dict__.get('isLoaded'))):
        tobj.load()

    nmrSimEnergyTerms = dataDict.get('nmrSimEnergyTerms')
    pass
    for nmrSimEnergyTerm in nmrSimEnergyTerms:
      topObject = nmrSimEnergyTerm.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccp.nmr.NmrConstraint.HBondConstraintList:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    access = dataDict.get('access')
    if ((access is not None and not (access in objsToBeDeleted))):
      dataObjects = access.__dict__.get('dataObjects')
      dataObjects.remove(self)

    conditionState = dataDict.get('conditionState')
    if ((conditionState is not None and not (conditionState in objsToBeDeleted))):
      constraintLists = conditionState.__dict__.get('constraintLists')
      constraintLists.remove(self)

    method = dataDict.get('method')
    if ((method is not None and not (method in objsToBeDeleted))):
      constraintLists = method.__dict__.get('constraintLists')
      constraintLists.remove(self)

    for nmrConstraintListValidation in dataDict.get('nmrConstraintListValidations'):
      if (not (nmrConstraintListValidation in objsToBeDeleted)):
        nmrConstraintLists = nmrConstraintListValidation.__dict__.get('nmrConstraintLists')
        nmrConstraintLists.remove(self)

    for nmrSimEnergyTerm in dataDict.get('nmrSimEnergyTerms'):
      if (not (nmrSimEnergyTerm in objsToBeDeleted)):
        constraintLists = nmrSimEnergyTerm.__dict__.get('constraintLists')
        constraintLists.remove(self)

    nmrConstraintStore = dataDict.get('nmrConstraintStore')
    if (not (nmrConstraintStore in objsToBeDeleted)):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = nmrConstraintStore.__dict__.get('constraintLists')
        if (self is dd.get(objKey)):
          del dd[objKey]

  addApplicationData = memops.api.Implementation.DataObject.addApplicationData

  addExperiment = AbstractConstraintList.addExperiment

  addExperimentSerial = AbstractConstraintList.addExperimentSerial

  addMeasureListSerial = AbstractConstraintList.addMeasureListSerial

  addMeasurementList = AbstractConstraintList.addMeasurementList

  addNmrConstraintListValidation = AbstractConstraintList.addNmrConstraintListValidation

  addNmrSimEnergyTerm = AbstractConstraintList.addNmrSimEnergyTerm
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccp.nmr.NmrConstraint.HBondConstraintList
    """
    dataDict = self.__dict__
    self.checkValid(complete)
    values = dataDict.get('constraints').values()
    for value in values:
      value.checkAllValid(complete)

  def checkValid(self, complete=False):
    """
    CheckValid for ccp.nmr.NmrConstraint.HBondConstraintList
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('nmrConstraintStore')
        dd = value.__dict__.get('constraintLists')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'nmrConstraintStore' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from memops.api.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('details')
      if (value is not None):
        if (isinstance(value, memops.api.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: details:
           memops.Implementation.String input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      values = dataDict.get('experimentSerials')
      for value in values:
        if (isinstance(value, memops.api.Implementation.Int.PythonType)):
          pass
        elif ([x for x in memops.api.Implementation.Int.compatibleTypes if isinstance(value, x)]):
          castValue = memops.api.Implementation.Int.create(value)
          values.remove(value)
          if (castValue in values):
            values.add(value)
            raise ApiError("""%s.checkValid: experimentSerials:
             replacement value already in unique collection """ % self.qualifiedName
             + ": %s" % (castValue,)
            )
          else:
            values.add(castValue)

          value = castValue
        else:
          raise ApiError("""%s.checkValid: experimentSerials:
           memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      values = dataDict.get('measureListSerials')
      for value in values:
        if (isinstance(value, memops.api.Implementation.Int.PythonType)):
          pass
        elif ([x for x in memops.api.Implementation.Int.compatibleTypes if isinstance(value, x)]):
          castValue = memops.api.Implementation.Int.create(value)
          values.remove(value)
          if (castValue in values):
            values.add(value)
            raise ApiError("""%s.checkValid: measureListSerials:
             replacement value already in unique collection """ % self.qualifiedName
             + ": %s" % (castValue,)
            )
          else:
            values.add(castValue)

          value = castValue
        else:
          raise ApiError("""%s.checkValid: measureListSerials:
           memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('name')
      if (value is not None):
        if (isinstance(value, memops.api.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: name:
           memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 80):
          raise ApiError("""%s.checkValid: name:
           memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: name:
           memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.splitlines()) <= 1)):
          raise ApiError("""%s.checkValid: name:
           Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, memops.api.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('serial')
      if (value is None):
        raise ApiError("""%s.checkValid: serial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, memops.api.Implementation.Int.PythonType)):
        pass
      elif ([x for x in memops.api.Implementation.Int.compatibleTypes if isinstance(value, x)]):
        value = memops.api.Implementation.Int.create(value)
      else:
        raise ApiError("""%s.checkValid: serial:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('unit')
      if (value is not None):
        if (isinstance(value, memops.api.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: unit:
           memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 32):
          raise ApiError("""%s.checkValid: unit:
           memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: unit:
           memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.split()) == 1)):
          raise ApiError("""%s.checkValid: unit:
           Word constraint contains_no_white_space violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('usedForCalculation')
      if (not (value in [True, False])):
        raise ApiError("""%s.checkValid: usedForCalculation:
         memops.Implementation.Boolean input is not in enumeration [True, False]""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('access')
      if (value is not None):
        from memops.api.AccessControl import AccessObject as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: access:
           value is not of class memops.AccessControl.AccessObject""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('dataObjects')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: access:
           non-reciprocal link HBondConstraintList from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      value = dataDict.get('conditionState')
      if (value is not None):
        if (not isinstance(value, ConditionState)):
          raise ApiError("""%s.checkValid: conditionState:
           value is not of class ccp.nmr.NmrConstraint.ConditionState""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('constraintLists')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: conditionState:
           non-reciprocal link HBondConstraintList from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('constraints').values()
      for value in values:
        if (not isinstance(value, HBondConstraint)):
          raise ApiError("""%s.checkValid: constraints:
           value is not of class ccp.nmr.NmrConstraint.HBondConstraint""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('parentList')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: constraints:
           non-reciprocal link HBondConstraintList from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = self.getExperiments()
      for value in values:
        from ccp.api.nmr.Nmr import Experiment as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: experiments:
           value is not of class ccp.nmr.Nmr.Experiment""" % self.qualifiedName
           + ": %s" % (value,)
          )

        xx1 = dataDict.get('topObject')
        xx2 = xx1.__dict__.get('nmrProject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx2 is yy1)):
          raise ApiError("""%s.checkValid: experiments:
           Link experiments between objects from separate partitions
           - ccp.nmr.NmrConstraint.NmrConstraintStore.nmrProject not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = self.getMeasurementLists()
      for value in values:
        from ccp.api.nmr.Nmr import AbstractMeasurementList as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: measurementLists:
           value is not of class ccp.nmr.Nmr.AbstractMeasurementList""" % self.qualifiedName
           + ": %s" % (value,)
          )

        xx1 = dataDict.get('topObject')
        xx2 = xx1.__dict__.get('nmrProject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx2 is yy1)):
          raise ApiError("""%s.checkValid: measurementLists:
           Link measurementLists between objects from separate partitions
           - ccp.nmr.NmrConstraint.NmrConstraintStore.nmrProject not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      value = dataDict.get('method')
      if (value is not None):
        from ccp.api.general.Method import Method as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: method:
           value is not of class ccp.general.Method.Method""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('constraintLists')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: method:
           non-reciprocal link HBondConstraintList from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('nmrConstraintListValidations')
      for value in values:
        from ccp.api.molecule.Validation import NmrConstraintListValidation as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: nmrConstraintListValidations:
           value is not of class ccp.molecule.Validation.NmrConstraintListValidation""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('nmrConstraintLists')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: nmrConstraintListValidations:
           non-reciprocal link HBondConstraintList from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        yy2 = yy1.__dict__.get('nmrConstraintStore')
        if (not (xx1 is yy2)):
          raise ApiError("""%s.checkValid: nmrConstraintListValidations:
           Link nmrConstraintListValidations between objects from separate partitions
           - ccp.molecule.Validation.ValidationStore.nmrConstraintStore not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      value = dataDict.get('nmrConstraintStore')
      if (not isinstance(value, NmrConstraintStore)):
        raise ApiError("""%s.checkValid: nmrConstraintStore:
         value is not of class ccp.nmr.NmrConstraint.NmrConstraintStore""" % self.qualifiedName
         + ": %s" % (value,)
        )

      root = dataDict.get('topObject').__dict__.get('memopsRoot')
      root.refreshTopObjects('molsim.NmrSim')
      tobjList = root.__dict__.get('nmrSimStores').values()
      for tobj in tobjList:
        if (not (tobj.__dict__.get('isLoaded'))):
          tobj.load()

      values = dataDict.get('nmrSimEnergyTerms')
      for value in values:
        from molsim.api.NmrSim import NmrSimEnergyTerm as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: nmrSimEnergyTerms:
           value is not of class molsim.NmrSim.NmrSimEnergyTerm""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('constraintLists')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: nmrSimEnergyTerms:
           non-reciprocal link HBondConstraintList from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

    # check explicit class constraints
    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('details')
    values = dataDict.get('experimentSerials')
    values = dataDict.get('measureListSerials')
    value = dataDict.get('name')
    value = dataDict.get('unit')
    value = dataDict.get('usedForCalculation')
    if (value is None):
      raise ApiError("""%s.checkValid: usedForCalculation:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    # check roles
    value = dataDict.get('access')
    value = dataDict.get('conditionState')
    values = dataDict.get('constraints').values()
    value = dataDict.get('method')
    values = dataDict.get('nmrConstraintListValidations')
    for value in values:
      ll= value.keywordDefinition.targetNames
      isValid = (not ll or self.qualifiedName in ll)
      if (not (isValid)):
        raise ApiError("""%s.checkValid: nmrConstraintListValidations:
         nmrConstraintListValidations constraint KeywordDefinition_fits_ConstraintList violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    value = dataDict.get('nmrConstraintStore')
    if (value is None):
      raise ApiError("""%s.checkValid: nmrConstraintStore:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    values = dataDict.get('nmrSimEnergyTerms')

  delete = memops.api.Implementation.DataObject.delete

  findAllApplicationData = memops.api.Implementation.DataObject.findAllApplicationData
  
  def findAllConstraints(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.HBondConstraintList.constraints
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('constraints').values()
      result = set(currentValues)

    else:
      currentValues = dataDict.get('constraints').values()
      result = set()
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('details', 'error', 'lowerLimit', 'origData', 'serial', 'targetValue', 'upperLimit', 'weight', 'access', 'method', 'parentList',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result.add(v)

    return result

  findAllExperiments = AbstractConstraintList.findAllExperiments

  findAllMeasurementLists = AbstractConstraintList.findAllMeasurementLists

  findAllNmrConstraintListValidations = AbstractConstraintList.findAllNmrConstraintListValidations

  findAllNmrSimEnergyTerms = AbstractConstraintList.findAllNmrSimEnergyTerms

  findFirstApplicationData = memops.api.Implementation.DataObject.findFirstApplicationData
  
  def findFirstConstraint(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.HBondConstraintList.constraints
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('constraints').values()
      if (currentValues):
        result = iter(currentValues).next()
      else:
        result = None

    else:
      objKey = conditions.get('serial')
      if (objKey is not None):
        result = dataDict.get('constraints').get(objKey)

        if (result is None):
          return result

        elif (len(conditions) <= 1):
          return result

        else:
          currentValues = set()
          currentValues.add(result)

      else:
        currentValues = dataDict.get('constraints').values()

      result = None
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('details', 'error', 'lowerLimit', 'origData', 'serial', 'targetValue', 'upperLimit', 'weight', 'access', 'method', 'parentList',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result = v; break

    return result

  findFirstExperiment = AbstractConstraintList.findFirstExperiment

  findFirstMeasurementList = AbstractConstraintList.findFirstMeasurementList

  findFirstNmrConstraintListValidation = AbstractConstraintList.findFirstNmrConstraintListValidation

  findFirstNmrSimEnergyTerm = AbstractConstraintList.findFirstNmrSimEnergyTerm
  
  def get(self, name):
    """
    GetAttr for ccp.nmr.NmrConstraint.HBondConstraintList
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getAccess = memops.api.Implementation.DataObject.getAccess

  getApplicationData = memops.api.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.HBondConstraintList
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (2 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.HBondConstraintList'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (1 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.HBondConstraintList'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-1]
      obj2 = obj1.__dict__.get('constraintLists').get(objKey)
      if (isinstance(obj2, HBondConstraintList)):
        result = obj2

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = memops.api.Implementation.MemopsObject.getByNavigation

  getClassName = memops.api.Implementation.ComplexDataType.getClassName

  getConditionState = AbstractConstraintList.getConditionState
  
  def getConstraints(self):
    """
    Get for ccp.nmr.NmrConstraint.HBondConstraintList.constraints
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('constraints').values()
    result = frozenset(tempVar)
    return result

  getDetails = AbstractConstraintList.getDetails

  getExpandedKey = memops.api.Implementation.MemopsObject.getExpandedKey

  getExperimentSerials = AbstractConstraintList.getExperimentSerials

  getExperiments = AbstractConstraintList.getExperiments

  getFieldNames = memops.api.Implementation.ComplexDataType.getFieldNames

  getFullKey = AbstractConstraintList.getFullKey

  getInConstructor = memops.api.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = memops.api.Implementation.MemopsObject.getIsDeleted

  getLocalKey = AbstractConstraintList.getLocalKey

  getMeasureListSerials = AbstractConstraintList.getMeasureListSerials

  getMeasurementLists = AbstractConstraintList.getMeasurementLists

  getMetaclass = memops.api.Implementation.ComplexDataType.getMetaclass

  getMethod = AbstractConstraintList.getMethod

  getName = AbstractConstraintList.getName

  getNmrConstraintListValidations = AbstractConstraintList.getNmrConstraintListValidations

  getNmrConstraintStore = AbstractConstraintList.getNmrConstraintStore

  getNmrSimEnergyTerms = AbstractConstraintList.getNmrSimEnergyTerms

  getPackageName = memops.api.Implementation.ComplexDataType.getPackageName

  getPackageShortName = memops.api.Implementation.ComplexDataType.getPackageShortName

  getParent = AbstractConstraintList.getParent

  getQualifiedName = memops.api.Implementation.ComplexDataType.getQualifiedName

  getRoot = memops.api.Implementation.MemopsObject.getRoot

  getSerial = AbstractConstraintList.getSerial

  getTopObject = memops.api.Implementation.DataObject.getTopObject

  getUnit = AbstractConstraintList.getUnit

  getUsedForCalculation = AbstractConstraintList.getUsedForCalculation
  
  def newHBondConstraint(self, **attrlinks):
    """
    Factory function to create ccp.nmr.NmrConstraint.HBondConstraint
    """
    return HBondConstraint(self, **attrlinks)

  removeApplicationData = memops.api.Implementation.DataObject.removeApplicationData

  removeExperiment = AbstractConstraintList.removeExperiment

  removeExperimentSerial = AbstractConstraintList.removeExperimentSerial

  removeMeasureListSerial = AbstractConstraintList.removeMeasureListSerial

  removeMeasurementList = AbstractConstraintList.removeMeasurementList

  removeNmrConstraintListValidation = AbstractConstraintList.removeNmrConstraintListValidation

  removeNmrSimEnergyTerm = AbstractConstraintList.removeNmrSimEnergyTerm
  
  def set(self, name, value):
    """
    SetAttr for ccp.nmr.NmrConstraint.HBondConstraintList
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setAccess = memops.api.Implementation.DataObject.setAccess

  setApplicationData = memops.api.Implementation.DataObject.setApplicationData

  setConditionState = AbstractConstraintList.setConditionState

  setDetails = AbstractConstraintList.setDetails

  setExperimentSerials = AbstractConstraintList.setExperimentSerials

  setExperiments = AbstractConstraintList.setExperiments

  setMeasureListSerials = AbstractConstraintList.setMeasureListSerials

  setMeasurementLists = AbstractConstraintList.setMeasurementLists

  setMethod = AbstractConstraintList.setMethod

  setName = AbstractConstraintList.setName

  setNmrConstraintListValidations = AbstractConstraintList.setNmrConstraintListValidations

  setNmrSimEnergyTerms = AbstractConstraintList.setNmrSimEnergyTerms

  setSerial = AbstractConstraintList.setSerial

  setUnit = AbstractConstraintList.setUnit

  setUsedForCalculation = AbstractConstraintList.setUsedForCalculation
  
  def sortedConstraints(self):
    """
    Sorted for ccp.nmr.NmrConstraint.HBondConstraintList.constraints
    """
    dataDict = self.__dict__
    sortdd = dataDict.get('constraints')
    
    ll = sortdd.keys()
    ll.sort()
    result = [sortdd[x] for x in ll]
    return result

  sortedExperiments = AbstractConstraintList.sortedExperiments

  sortedMeasurementLists = AbstractConstraintList.sortedMeasurementLists

  sortedNmrConstraintListValidations = AbstractConstraintList.sortedNmrConstraintListValidations

  sortedNmrSimEnergyTerms = AbstractConstraintList.sortedNmrSimEnergyTerms

  toDetailedString = memops.api.Implementation.ComplexDataType.toDetailedString

  applicationData = memops.api.Implementation.DataObject.applicationData

  className = memops.api.Implementation.ComplexDataType.className

  details = AbstractConstraintList.details

  experimentSerials = AbstractConstraintList.experimentSerials

  fieldNames = memops.api.Implementation.ComplexDataType.fieldNames

  inConstructor = memops.api.Implementation.ComplexDataType.inConstructor

  isDeleted = memops.api.Implementation.MemopsObject.isDeleted

  measureListSerials = AbstractConstraintList.measureListSerials

  metaclass = memops.api.Implementation.ComplexDataType.metaclass

  name = AbstractConstraintList.name

  packageName = memops.api.Implementation.ComplexDataType.packageName

  packageShortName = memops.api.Implementation.ComplexDataType.packageShortName

  qualifiedName = memops.api.Implementation.ComplexDataType.qualifiedName

  serial = AbstractConstraintList.serial

  unit = AbstractConstraintList.unit

  usedForCalculation = AbstractConstraintList.usedForCalculation

  access = memops.api.Implementation.DataObject.access

  conditionState = AbstractConstraintList.conditionState
  
  constraints = property(getConstraints,  None, None,
  r"""child link to class HBondConstraint
  """)

  experiments = AbstractConstraintList.experiments

  measurementLists = AbstractConstraintList.measurementLists

  method = AbstractConstraintList.method

  nmrConstraintListValidations = AbstractConstraintList.nmrConstraintListValidations

  nmrConstraintStore = AbstractConstraintList.nmrConstraintStore

  nmrSimEnergyTerms = AbstractConstraintList.nmrSimEnergyTerms

  parent = AbstractConstraintList.parent

  root = memops.api.Implementation.MemopsObject.root

  topObject = memops.api.Implementation.DataObject.topObject

###############################################################################
class DistanceConstraintList(AbstractConstraintList):
  r"""List of Distance Constraints
  """
  #   from data model element ccp.nmr.NmrConstraint.DistanceConstraintList revision 1.36.2.9
  _metaclass = metaPackage.getElement('DistanceConstraintList')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('applicationData', 'className', 'details', 'experimentSerials', 'fieldNames', 'inConstructor', 'isDeleted', 'measureListSerials', 'metaclass', 'name', 'packageName', 'packageShortName', 'qualifiedName', 'serial', 'unit', 'usedForCalculation', 'access', 'conditionState', 'constraints', 'experiments', 'measurementLists', 'method', 'nmrConstraintListValidations', 'nmrConstraintStore', 'nmrSimEnergyTerms', 'parent', 'root', 'topObject',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccp.nmr.NmrConstraint.DistanceConstraintList
    """
    dataDict = self.__dict__
    dataDict['nmrConstraintStore'] = parent
    if (not isinstance(parent, NmrConstraintStore)):
      raise ApiError("""%s.__init__:
       value is not of class ccp.nmr.NmrConstraint.NmrConstraintStore""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:
      if (not ((parent.__dict__.get('isLoaded') or parent.__dict__.get('isReading')))):
        parent.load()

      dataDict['applicationData'] = list()
      dataDict['details'] = None
      dataDict['experimentSerials'] = set()
      dataDict['measureListSerials'] = set()
      dataDict['name'] = None
      dataDict['serial'] = None
      dataDict['unit'] = None
      dataDict['usedForCalculation'] = True
      dataDict['access'] = None
      dataDict['conditionState'] = None
      dataDict['constraints'] = {}
      dataDict['method'] = None
      dataDict['nmrConstraintListValidations'] = set()
      dataDict['nmrSimEnergyTerms'] = set()

      dataDict['inConstructor'] = True
      try:
        
        for key, value in attrlinks.iteritems():
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        del dataDict['inConstructor']
      except:
        print "ERROR in ccp.nmr.NmrConstraint.DistanceConstraintList.__init__"
        del dataDict['inConstructor']
        raise

      if (notOverride):
        if (dataDict.get('serial') is None):
          dataDict['inConstructor'] = True
          self.setSerial(-1)
          del dataDict['inConstructor']
        else:
          raise ApiError("""%s.__init__:
           Cannot pass in explicit serial if not reading""" % self.qualifiedName
           + ": %s:%s" % (parent, 'ccp.nmr.NmrConstraint.DistanceConstraintList')
          )

      serialDict = {}
      serialDict['constraints'] = 0
      dataDict['_serialDict'] = serialDict

      if (notIsReading):
        childrenDict = parent.__dict__.get('constraintLists')
        objKey = dataDict.get('serial')
        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['serial'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        print '''WARNING Error in clean-up of incorrectly created object. 
        Data may be left in an illegal state'''
        del dataDict['inConstructor']
      raise exc_info[0], exc_info[1], exc_info[2]

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccp.nmr.NmrConstraint.DistanceConstraintList:
       
    determines cascading deletes to follow from delete of object.
       
    *Implementation function* - should be called only by API delete 
    function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
      dataDict.get('topObject').load()

    access = dataDict.get('access')
    if (access is not None):
      topObject = access.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    constraints = dataDict.get('constraints').values()
    for constraint in constraints:
      if (not (constraint in objsToBeDeleted)):
        objsToBeDeleted.add(constraint)
        objsToBeChecked.append(constraint)

    method = dataDict.get('method')
    if (method is not None):
      topObject = method.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    nmrConstraintListValidations = dataDict.get('nmrConstraintListValidations')
    pass
    for nmrConstraintListValidation in nmrConstraintListValidations:
      topObject = nmrConstraintListValidation.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    root = dataDict.get('topObject').__dict__.get('memopsRoot')
    root.refreshTopObjects('molsim.NmrSim')
    tobjList = root.__dict__.get('nmrSimStores').values()
    for tobj in tobjList:
      if (not (tobj.__dict__.get('isLoaded'))):
        tobj.load()

    nmrSimEnergyTerms = dataDict.get('nmrSimEnergyTerms')
    pass
    for nmrSimEnergyTerm in nmrSimEnergyTerms:
      topObject = nmrSimEnergyTerm.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccp.nmr.NmrConstraint.DistanceConstraintList:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    access = dataDict.get('access')
    if ((access is not None and not (access in objsToBeDeleted))):
      dataObjects = access.__dict__.get('dataObjects')
      dataObjects.remove(self)

    conditionState = dataDict.get('conditionState')
    if ((conditionState is not None and not (conditionState in objsToBeDeleted))):
      constraintLists = conditionState.__dict__.get('constraintLists')
      constraintLists.remove(self)

    method = dataDict.get('method')
    if ((method is not None and not (method in objsToBeDeleted))):
      constraintLists = method.__dict__.get('constraintLists')
      constraintLists.remove(self)

    for nmrConstraintListValidation in dataDict.get('nmrConstraintListValidations'):
      if (not (nmrConstraintListValidation in objsToBeDeleted)):
        nmrConstraintLists = nmrConstraintListValidation.__dict__.get('nmrConstraintLists')
        nmrConstraintLists.remove(self)

    for nmrSimEnergyTerm in dataDict.get('nmrSimEnergyTerms'):
      if (not (nmrSimEnergyTerm in objsToBeDeleted)):
        constraintLists = nmrSimEnergyTerm.__dict__.get('constraintLists')
        constraintLists.remove(self)

    nmrConstraintStore = dataDict.get('nmrConstraintStore')
    if (not (nmrConstraintStore in objsToBeDeleted)):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = nmrConstraintStore.__dict__.get('constraintLists')
        if (self is dd.get(objKey)):
          del dd[objKey]

  addApplicationData = memops.api.Implementation.DataObject.addApplicationData

  addExperiment = AbstractConstraintList.addExperiment

  addExperimentSerial = AbstractConstraintList.addExperimentSerial

  addMeasureListSerial = AbstractConstraintList.addMeasureListSerial

  addMeasurementList = AbstractConstraintList.addMeasurementList

  addNmrConstraintListValidation = AbstractConstraintList.addNmrConstraintListValidation

  addNmrSimEnergyTerm = AbstractConstraintList.addNmrSimEnergyTerm
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccp.nmr.NmrConstraint.DistanceConstraintList
    """
    dataDict = self.__dict__
    self.checkValid(complete)
    values = dataDict.get('constraints').values()
    for value in values:
      value.checkAllValid(complete)

  def checkValid(self, complete=False):
    """
    CheckValid for ccp.nmr.NmrConstraint.DistanceConstraintList
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('nmrConstraintStore')
        dd = value.__dict__.get('constraintLists')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'nmrConstraintStore' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from memops.api.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('details')
      if (value is not None):
        if (isinstance(value, memops.api.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: details:
           memops.Implementation.String input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      values = dataDict.get('experimentSerials')
      for value in values:
        if (isinstance(value, memops.api.Implementation.Int.PythonType)):
          pass
        elif ([x for x in memops.api.Implementation.Int.compatibleTypes if isinstance(value, x)]):
          castValue = memops.api.Implementation.Int.create(value)
          values.remove(value)
          if (castValue in values):
            values.add(value)
            raise ApiError("""%s.checkValid: experimentSerials:
             replacement value already in unique collection """ % self.qualifiedName
             + ": %s" % (castValue,)
            )
          else:
            values.add(castValue)

          value = castValue
        else:
          raise ApiError("""%s.checkValid: experimentSerials:
           memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      values = dataDict.get('measureListSerials')
      for value in values:
        if (isinstance(value, memops.api.Implementation.Int.PythonType)):
          pass
        elif ([x for x in memops.api.Implementation.Int.compatibleTypes if isinstance(value, x)]):
          castValue = memops.api.Implementation.Int.create(value)
          values.remove(value)
          if (castValue in values):
            values.add(value)
            raise ApiError("""%s.checkValid: measureListSerials:
             replacement value already in unique collection """ % self.qualifiedName
             + ": %s" % (castValue,)
            )
          else:
            values.add(castValue)

          value = castValue
        else:
          raise ApiError("""%s.checkValid: measureListSerials:
           memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('name')
      if (value is not None):
        if (isinstance(value, memops.api.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: name:
           memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 80):
          raise ApiError("""%s.checkValid: name:
           memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: name:
           memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.splitlines()) <= 1)):
          raise ApiError("""%s.checkValid: name:
           Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, memops.api.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('serial')
      if (value is None):
        raise ApiError("""%s.checkValid: serial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, memops.api.Implementation.Int.PythonType)):
        pass
      elif ([x for x in memops.api.Implementation.Int.compatibleTypes if isinstance(value, x)]):
        value = memops.api.Implementation.Int.create(value)
      else:
        raise ApiError("""%s.checkValid: serial:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('unit')
      if (value is not None):
        if (isinstance(value, memops.api.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: unit:
           memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 32):
          raise ApiError("""%s.checkValid: unit:
           memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: unit:
           memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.split()) == 1)):
          raise ApiError("""%s.checkValid: unit:
           Word constraint contains_no_white_space violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('usedForCalculation')
      if (not (value in [True, False])):
        raise ApiError("""%s.checkValid: usedForCalculation:
         memops.Implementation.Boolean input is not in enumeration [True, False]""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('access')
      if (value is not None):
        from memops.api.AccessControl import AccessObject as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: access:
           value is not of class memops.AccessControl.AccessObject""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('dataObjects')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: access:
           non-reciprocal link DistanceConstraintList from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      value = dataDict.get('conditionState')
      if (value is not None):
        if (not isinstance(value, ConditionState)):
          raise ApiError("""%s.checkValid: conditionState:
           value is not of class ccp.nmr.NmrConstraint.ConditionState""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('constraintLists')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: conditionState:
           non-reciprocal link DistanceConstraintList from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('constraints').values()
      for value in values:
        if (not isinstance(value, DistanceConstraint)):
          raise ApiError("""%s.checkValid: constraints:
           value is not of class ccp.nmr.NmrConstraint.DistanceConstraint""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('parentList')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: constraints:
           non-reciprocal link DistanceConstraintList from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = self.getExperiments()
      for value in values:
        from ccp.api.nmr.Nmr import Experiment as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: experiments:
           value is not of class ccp.nmr.Nmr.Experiment""" % self.qualifiedName
           + ": %s" % (value,)
          )

        xx1 = dataDict.get('topObject')
        xx2 = xx1.__dict__.get('nmrProject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx2 is yy1)):
          raise ApiError("""%s.checkValid: experiments:
           Link experiments between objects from separate partitions
           - ccp.nmr.NmrConstraint.NmrConstraintStore.nmrProject not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = self.getMeasurementLists()
      for value in values:
        from ccp.api.nmr.Nmr import AbstractMeasurementList as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: measurementLists:
           value is not of class ccp.nmr.Nmr.AbstractMeasurementList""" % self.qualifiedName
           + ": %s" % (value,)
          )

        xx1 = dataDict.get('topObject')
        xx2 = xx1.__dict__.get('nmrProject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx2 is yy1)):
          raise ApiError("""%s.checkValid: measurementLists:
           Link measurementLists between objects from separate partitions
           - ccp.nmr.NmrConstraint.NmrConstraintStore.nmrProject not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      value = dataDict.get('method')
      if (value is not None):
        from ccp.api.general.Method import Method as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: method:
           value is not of class ccp.general.Method.Method""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('constraintLists')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: method:
           non-reciprocal link DistanceConstraintList from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('nmrConstraintListValidations')
      for value in values:
        from ccp.api.molecule.Validation import NmrConstraintListValidation as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: nmrConstraintListValidations:
           value is not of class ccp.molecule.Validation.NmrConstraintListValidation""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('nmrConstraintLists')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: nmrConstraintListValidations:
           non-reciprocal link DistanceConstraintList from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        yy2 = yy1.__dict__.get('nmrConstraintStore')
        if (not (xx1 is yy2)):
          raise ApiError("""%s.checkValid: nmrConstraintListValidations:
           Link nmrConstraintListValidations between objects from separate partitions
           - ccp.molecule.Validation.ValidationStore.nmrConstraintStore not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      value = dataDict.get('nmrConstraintStore')
      if (not isinstance(value, NmrConstraintStore)):
        raise ApiError("""%s.checkValid: nmrConstraintStore:
         value is not of class ccp.nmr.NmrConstraint.NmrConstraintStore""" % self.qualifiedName
         + ": %s" % (value,)
        )

      root = dataDict.get('topObject').__dict__.get('memopsRoot')
      root.refreshTopObjects('molsim.NmrSim')
      tobjList = root.__dict__.get('nmrSimStores').values()
      for tobj in tobjList:
        if (not (tobj.__dict__.get('isLoaded'))):
          tobj.load()

      values = dataDict.get('nmrSimEnergyTerms')
      for value in values:
        from molsim.api.NmrSim import NmrSimEnergyTerm as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: nmrSimEnergyTerms:
           value is not of class molsim.NmrSim.NmrSimEnergyTerm""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('constraintLists')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: nmrSimEnergyTerms:
           non-reciprocal link DistanceConstraintList from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

    # check explicit class constraints
    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('details')
    values = dataDict.get('experimentSerials')
    values = dataDict.get('measureListSerials')
    value = dataDict.get('name')
    value = dataDict.get('unit')
    value = dataDict.get('usedForCalculation')
    if (value is None):
      raise ApiError("""%s.checkValid: usedForCalculation:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    # check roles
    value = dataDict.get('access')
    value = dataDict.get('conditionState')
    values = dataDict.get('constraints').values()
    value = dataDict.get('method')
    values = dataDict.get('nmrConstraintListValidations')
    for value in values:
      ll= value.keywordDefinition.targetNames
      isValid = (not ll or self.qualifiedName in ll)
      if (not (isValid)):
        raise ApiError("""%s.checkValid: nmrConstraintListValidations:
         nmrConstraintListValidations constraint KeywordDefinition_fits_ConstraintList violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    value = dataDict.get('nmrConstraintStore')
    if (value is None):
      raise ApiError("""%s.checkValid: nmrConstraintStore:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    values = dataDict.get('nmrSimEnergyTerms')

  delete = memops.api.Implementation.DataObject.delete

  findAllApplicationData = memops.api.Implementation.DataObject.findAllApplicationData
  
  def findAllConstraints(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.DistanceConstraintList.constraints
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('constraints').values()
      result = set(currentValues)

    else:
      currentValues = dataDict.get('constraints').values()
      result = set()
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('backCalcVolume', 'details', 'error', 'lowerLimit', 'origData', 'serial', 'targetValue', 'upperLimit', 'weight', 'access', 'method', 'parentList',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result.add(v)

    return result

  findAllExperiments = AbstractConstraintList.findAllExperiments

  findAllMeasurementLists = AbstractConstraintList.findAllMeasurementLists

  findAllNmrConstraintListValidations = AbstractConstraintList.findAllNmrConstraintListValidations

  findAllNmrSimEnergyTerms = AbstractConstraintList.findAllNmrSimEnergyTerms

  findFirstApplicationData = memops.api.Implementation.DataObject.findFirstApplicationData
  
  def findFirstConstraint(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.DistanceConstraintList.constraints
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('constraints').values()
      if (currentValues):
        result = iter(currentValues).next()
      else:
        result = None

    else:
      objKey = conditions.get('serial')
      if (objKey is not None):
        result = dataDict.get('constraints').get(objKey)

        if (result is None):
          return result

        elif (len(conditions) <= 1):
          return result

        else:
          currentValues = set()
          currentValues.add(result)

      else:
        currentValues = dataDict.get('constraints').values()

      result = None
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('backCalcVolume', 'details', 'error', 'lowerLimit', 'origData', 'serial', 'targetValue', 'upperLimit', 'weight', 'access', 'method', 'parentList',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result = v; break

    return result

  findFirstExperiment = AbstractConstraintList.findFirstExperiment

  findFirstMeasurementList = AbstractConstraintList.findFirstMeasurementList

  findFirstNmrConstraintListValidation = AbstractConstraintList.findFirstNmrConstraintListValidation

  findFirstNmrSimEnergyTerm = AbstractConstraintList.findFirstNmrSimEnergyTerm
  
  def get(self, name):
    """
    GetAttr for ccp.nmr.NmrConstraint.DistanceConstraintList
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getAccess = memops.api.Implementation.DataObject.getAccess

  getApplicationData = memops.api.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.DistanceConstraintList
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (2 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.DistanceConstraintList'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (1 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.DistanceConstraintList'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-1]
      obj2 = obj1.__dict__.get('constraintLists').get(objKey)
      if (isinstance(obj2, DistanceConstraintList)):
        result = obj2

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = memops.api.Implementation.MemopsObject.getByNavigation

  getClassName = memops.api.Implementation.ComplexDataType.getClassName

  getConditionState = AbstractConstraintList.getConditionState
  
  def getConstraints(self):
    """
    Get for ccp.nmr.NmrConstraint.DistanceConstraintList.constraints
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('constraints').values()
    result = frozenset(tempVar)
    return result

  getDetails = AbstractConstraintList.getDetails

  getExpandedKey = memops.api.Implementation.MemopsObject.getExpandedKey

  getExperimentSerials = AbstractConstraintList.getExperimentSerials

  getExperiments = AbstractConstraintList.getExperiments

  getFieldNames = memops.api.Implementation.ComplexDataType.getFieldNames

  getFullKey = AbstractConstraintList.getFullKey

  getInConstructor = memops.api.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = memops.api.Implementation.MemopsObject.getIsDeleted

  getLocalKey = AbstractConstraintList.getLocalKey

  getMeasureListSerials = AbstractConstraintList.getMeasureListSerials

  getMeasurementLists = AbstractConstraintList.getMeasurementLists

  getMetaclass = memops.api.Implementation.ComplexDataType.getMetaclass

  getMethod = AbstractConstraintList.getMethod

  getName = AbstractConstraintList.getName

  getNmrConstraintListValidations = AbstractConstraintList.getNmrConstraintListValidations

  getNmrConstraintStore = AbstractConstraintList.getNmrConstraintStore

  getNmrSimEnergyTerms = AbstractConstraintList.getNmrSimEnergyTerms

  getPackageName = memops.api.Implementation.ComplexDataType.getPackageName

  getPackageShortName = memops.api.Implementation.ComplexDataType.getPackageShortName

  getParent = AbstractConstraintList.getParent

  getQualifiedName = memops.api.Implementation.ComplexDataType.getQualifiedName

  getRoot = memops.api.Implementation.MemopsObject.getRoot

  getSerial = AbstractConstraintList.getSerial

  getTopObject = memops.api.Implementation.DataObject.getTopObject

  getUnit = AbstractConstraintList.getUnit

  getUsedForCalculation = AbstractConstraintList.getUsedForCalculation
  
  def newDistanceConstraint(self, **attrlinks):
    """
    Factory function to create ccp.nmr.NmrConstraint.DistanceConstraint
    """
    return DistanceConstraint(self, **attrlinks)

  removeApplicationData = memops.api.Implementation.DataObject.removeApplicationData

  removeExperiment = AbstractConstraintList.removeExperiment

  removeExperimentSerial = AbstractConstraintList.removeExperimentSerial

  removeMeasureListSerial = AbstractConstraintList.removeMeasureListSerial

  removeMeasurementList = AbstractConstraintList.removeMeasurementList

  removeNmrConstraintListValidation = AbstractConstraintList.removeNmrConstraintListValidation

  removeNmrSimEnergyTerm = AbstractConstraintList.removeNmrSimEnergyTerm
  
  def set(self, name, value):
    """
    SetAttr for ccp.nmr.NmrConstraint.DistanceConstraintList
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setAccess = memops.api.Implementation.DataObject.setAccess

  setApplicationData = memops.api.Implementation.DataObject.setApplicationData

  setConditionState = AbstractConstraintList.setConditionState

  setDetails = AbstractConstraintList.setDetails

  setExperimentSerials = AbstractConstraintList.setExperimentSerials

  setExperiments = AbstractConstraintList.setExperiments

  setMeasureListSerials = AbstractConstraintList.setMeasureListSerials

  setMeasurementLists = AbstractConstraintList.setMeasurementLists

  setMethod = AbstractConstraintList.setMethod

  setName = AbstractConstraintList.setName

  setNmrConstraintListValidations = AbstractConstraintList.setNmrConstraintListValidations

  setNmrSimEnergyTerms = AbstractConstraintList.setNmrSimEnergyTerms

  setSerial = AbstractConstraintList.setSerial

  setUnit = AbstractConstraintList.setUnit

  setUsedForCalculation = AbstractConstraintList.setUsedForCalculation
  
  def sortedConstraints(self):
    """
    Sorted for ccp.nmr.NmrConstraint.DistanceConstraintList.constraints
    """
    dataDict = self.__dict__
    sortdd = dataDict.get('constraints')
    
    ll = sortdd.keys()
    ll.sort()
    result = [sortdd[x] for x in ll]
    return result

  sortedExperiments = AbstractConstraintList.sortedExperiments

  sortedMeasurementLists = AbstractConstraintList.sortedMeasurementLists

  sortedNmrConstraintListValidations = AbstractConstraintList.sortedNmrConstraintListValidations

  sortedNmrSimEnergyTerms = AbstractConstraintList.sortedNmrSimEnergyTerms

  toDetailedString = memops.api.Implementation.ComplexDataType.toDetailedString

  applicationData = memops.api.Implementation.DataObject.applicationData

  className = memops.api.Implementation.ComplexDataType.className

  details = AbstractConstraintList.details

  experimentSerials = AbstractConstraintList.experimentSerials

  fieldNames = memops.api.Implementation.ComplexDataType.fieldNames

  inConstructor = memops.api.Implementation.ComplexDataType.inConstructor

  isDeleted = memops.api.Implementation.MemopsObject.isDeleted

  measureListSerials = AbstractConstraintList.measureListSerials

  metaclass = memops.api.Implementation.ComplexDataType.metaclass

  name = AbstractConstraintList.name

  packageName = memops.api.Implementation.ComplexDataType.packageName

  packageShortName = memops.api.Implementation.ComplexDataType.packageShortName

  qualifiedName = memops.api.Implementation.ComplexDataType.qualifiedName

  serial = AbstractConstraintList.serial

  unit = AbstractConstraintList.unit

  usedForCalculation = AbstractConstraintList.usedForCalculation

  access = memops.api.Implementation.DataObject.access

  conditionState = AbstractConstraintList.conditionState
  
  constraints = property(getConstraints,  None, None,
  r"""child link to class DistanceConstraint
  """)

  experiments = AbstractConstraintList.experiments

  measurementLists = AbstractConstraintList.measurementLists

  method = AbstractConstraintList.method

  nmrConstraintListValidations = AbstractConstraintList.nmrConstraintListValidations

  nmrConstraintStore = AbstractConstraintList.nmrConstraintStore

  nmrSimEnergyTerms = AbstractConstraintList.nmrSimEnergyTerms

  parent = AbstractConstraintList.parent

  root = memops.api.Implementation.MemopsObject.root

  topObject = memops.api.Implementation.DataObject.topObject

###############################################################################
class JCouplingConstraintList(AbstractConstraintList):
  r"""Lis of J coupling constraints, in the form of J coupling values that 
should be reproduced by the structure.
  """
  #   from data model element ccp.nmr.NmrConstraint.JCouplingConstraintList revision 1.36.2.9
  _metaclass = metaPackage.getElement('JCouplingConstraintList')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('applicationData', 'className', 'details', 'experimentSerials', 'fieldNames', 'inConstructor', 'isDeleted', 'measureListSerials', 'metaclass', 'name', 'packageName', 'packageShortName', 'qualifiedName', 'serial', 'unit', 'usedForCalculation', 'access', 'conditionState', 'constraints', 'experiments', 'measurementLists', 'method', 'nmrConstraintListValidations', 'nmrConstraintStore', 'nmrSimEnergyTerms', 'parent', 'root', 'topObject',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccp.nmr.NmrConstraint.JCouplingConstraintList
    """
    dataDict = self.__dict__
    dataDict['nmrConstraintStore'] = parent
    if (not isinstance(parent, NmrConstraintStore)):
      raise ApiError("""%s.__init__:
       value is not of class ccp.nmr.NmrConstraint.NmrConstraintStore""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:
      if (not ((parent.__dict__.get('isLoaded') or parent.__dict__.get('isReading')))):
        parent.load()

      dataDict['applicationData'] = list()
      dataDict['details'] = None
      dataDict['experimentSerials'] = set()
      dataDict['measureListSerials'] = set()
      dataDict['name'] = None
      dataDict['serial'] = None
      dataDict['unit'] = None
      dataDict['usedForCalculation'] = True
      dataDict['access'] = None
      dataDict['conditionState'] = None
      dataDict['constraints'] = {}
      dataDict['method'] = None
      dataDict['nmrConstraintListValidations'] = set()
      dataDict['nmrSimEnergyTerms'] = set()

      dataDict['inConstructor'] = True
      try:
        
        for key, value in attrlinks.iteritems():
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        del dataDict['inConstructor']
      except:
        print "ERROR in ccp.nmr.NmrConstraint.JCouplingConstraintList.__init__"
        del dataDict['inConstructor']
        raise

      if (notOverride):
        if (dataDict.get('serial') is None):
          dataDict['inConstructor'] = True
          self.setSerial(-1)
          del dataDict['inConstructor']
        else:
          raise ApiError("""%s.__init__:
           Cannot pass in explicit serial if not reading""" % self.qualifiedName
           + ": %s:%s" % (parent, 'ccp.nmr.NmrConstraint.JCouplingConstraintList')
          )

      serialDict = {}
      serialDict['constraints'] = 0
      dataDict['_serialDict'] = serialDict

      if (notIsReading):
        childrenDict = parent.__dict__.get('constraintLists')
        objKey = dataDict.get('serial')
        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['serial'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        print '''WARNING Error in clean-up of incorrectly created object. 
        Data may be left in an illegal state'''
        del dataDict['inConstructor']
      raise exc_info[0], exc_info[1], exc_info[2]

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccp.nmr.NmrConstraint.JCouplingConstraintList:
       
    determines cascading deletes to follow from delete of object.
       
    *Implementation function* - should be called only by API delete 
    function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
      dataDict.get('topObject').load()

    access = dataDict.get('access')
    if (access is not None):
      topObject = access.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    constraints = dataDict.get('constraints').values()
    for constraint in constraints:
      if (not (constraint in objsToBeDeleted)):
        objsToBeDeleted.add(constraint)
        objsToBeChecked.append(constraint)

    method = dataDict.get('method')
    if (method is not None):
      topObject = method.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    nmrConstraintListValidations = dataDict.get('nmrConstraintListValidations')
    pass
    for nmrConstraintListValidation in nmrConstraintListValidations:
      topObject = nmrConstraintListValidation.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    root = dataDict.get('topObject').__dict__.get('memopsRoot')
    root.refreshTopObjects('molsim.NmrSim')
    tobjList = root.__dict__.get('nmrSimStores').values()
    for tobj in tobjList:
      if (not (tobj.__dict__.get('isLoaded'))):
        tobj.load()

    nmrSimEnergyTerms = dataDict.get('nmrSimEnergyTerms')
    pass
    for nmrSimEnergyTerm in nmrSimEnergyTerms:
      topObject = nmrSimEnergyTerm.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccp.nmr.NmrConstraint.JCouplingConstraintList:
    deletes objects
    *Implementation function* - will CORRUPT DATA if called 
    outside the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    access = dataDict.get('access')
    if ((access is not None and not (access in objsToBeDeleted))):
      dataObjects = access.__dict__.get('dataObjects')
      dataObjects.remove(self)

    conditionState = dataDict.get('conditionState')
    if ((conditionState is not None and not (conditionState in objsToBeDeleted))):
      constraintLists = conditionState.__dict__.get('constraintLists')
      constraintLists.remove(self)

    method = dataDict.get('method')
    if ((method is not None and not (method in objsToBeDeleted))):
      constraintLists = method.__dict__.get('constraintLists')
      constraintLists.remove(self)

    for nmrConstraintListValidation in dataDict.get('nmrConstraintListValidations'):
      if (not (nmrConstraintListValidation in objsToBeDeleted)):
        nmrConstraintLists = nmrConstraintListValidation.__dict__.get('nmrConstraintLists')
        nmrConstraintLists.remove(self)

    for nmrSimEnergyTerm in dataDict.get('nmrSimEnergyTerms'):
      if (not (nmrSimEnergyTerm in objsToBeDeleted)):
        constraintLists = nmrSimEnergyTerm.__dict__.get('constraintLists')
        constraintLists.remove(self)

    nmrConstraintStore = dataDict.get('nmrConstraintStore')
    if (not (nmrConstraintStore in objsToBeDeleted)):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = nmrConstraintStore.__dict__.get('constraintLists')
        if (self is dd.get(objKey)):
          del dd[objKey]

  addApplicationData = memops.api.Implementation.DataObject.addApplicationData

  addExperiment = AbstractConstraintList.addExperiment

  addExperimentSerial = AbstractConstraintList.addExperimentSerial

  addMeasureListSerial = AbstractConstraintList.addMeasureListSerial

  addMeasurementList = AbstractConstraintList.addMeasurementList

  addNmrConstraintListValidation = AbstractConstraintList.addNmrConstraintListValidation

  addNmrSimEnergyTerm = AbstractConstraintList.addNmrSimEnergyTerm
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccp.nmr.NmrConstraint.JCouplingConstraintList
    """
    dataDict = self.__dict__
    self.checkValid(complete)
    values = dataDict.get('constraints').values()
    for value in values:
      value.checkAllValid(complete)

  def checkValid(self, complete=False):
    """
    CheckValid for ccp.nmr.NmrConstraint.JCouplingConstraintList
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('nmrConstraintStore')
        dd = value.__dict__.get('constraintLists')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'nmrConstraintStore' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from memops.api.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('details')
      if (value is not None):
        if (isinstance(value, memops.api.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: details:
           memops.Implementation.String input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      values = dataDict.get('experimentSerials')
      for value in values:
        if (isinstance(value, memops.api.Implementation.Int.PythonType)):
          pass
        elif ([x for x in memops.api.Implementation.Int.compatibleTypes if isinstance(value, x)]):
          castValue = memops.api.Implementation.Int.create(value)
          values.remove(value)
          if (castValue in values):
            values.add(value)
            raise ApiError("""%s.checkValid: experimentSerials:
             replacement value already in unique collection """ % self.qualifiedName
             + ": %s" % (castValue,)
            )
          else:
            values.add(castValue)

          value = castValue
        else:
          raise ApiError("""%s.checkValid: experimentSerials:
           memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      values = dataDict.get('measureListSerials')
      for value in values:
        if (isinstance(value, memops.api.Implementation.Int.PythonType)):
          pass
        elif ([x for x in memops.api.Implementation.Int.compatibleTypes if isinstance(value, x)]):
          castValue = memops.api.Implementation.Int.create(value)
          values.remove(value)
          if (castValue in values):
            values.add(value)
            raise ApiError("""%s.checkValid: measureListSerials:
             replacement value already in unique collection """ % self.qualifiedName
             + ": %s" % (castValue,)
            )
          else:
            values.add(castValue)

          value = castValue
        else:
          raise ApiError("""%s.checkValid: measureListSerials:
           memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('name')
      if (value is not None):
        if (isinstance(value, memops.api.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: name:
           memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 80):
          raise ApiError("""%s.checkValid: name:
           memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: name:
           memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.splitlines()) <= 1)):
          raise ApiError("""%s.checkValid: name:
           Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, memops.api.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('serial')
      if (value is None):
        raise ApiError("""%s.checkValid: serial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, memops.api.Implementation.Int.PythonType)):
        pass
      elif ([x for x in memops.api.Implementation.Int.compatibleTypes if isinstance(value, x)]):
        value = memops.api.Implementation.Int.create(value)
      else:
        raise ApiError("""%s.checkValid: serial:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('unit')
      if (value is not None):
        if (isinstance(value, memops.api.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: unit:
           memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 32):
          raise ApiError("""%s.checkValid: unit:
           memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: unit:
           memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.split()) == 1)):
          raise ApiError("""%s.checkValid: unit:
           Word constraint contains_no_white_space violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('usedForCalculation')
      if (not (value in [True, False])):
        raise ApiError("""%s.checkValid: usedForCalculation:
         memops.Implementation.Boolean input is not in enumeration [True, False]""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('access')
      if (value is not None):
        from memops.api.AccessControl import AccessObject as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: access:
           value is not of class memops.AccessControl.AccessObject""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('dataObjects')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: access:
           non-reciprocal link JCouplingConstraintList from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      value = dataDict.get('conditionState')
      if (value is not None):
        if (not isinstance(value, ConditionState)):
          raise ApiError("""%s.checkValid: conditionState:
           value is not of class ccp.nmr.NmrConstraint.ConditionState""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('constraintLists')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: conditionState:
           non-reciprocal link JCouplingConstraintList from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('constraints').values()
      for value in values:
        if (not isinstance(value, JCouplingConstraint)):
          raise ApiError("""%s.checkValid: constraints:
           value is not of class ccp.nmr.NmrConstraint.JCouplingConstraint""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('parentList')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: constraints:
           non-reciprocal link JCouplingConstraintList from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = self.getExperiments()
      for value in values:
        from ccp.api.nmr.Nmr import Experiment as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: experiments:
           value is not of class ccp.nmr.Nmr.Experiment""" % self.qualifiedName
           + ": %s" % (value,)
          )

        xx1 = dataDict.get('topObject')
        xx2 = xx1.__dict__.get('nmrProject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx2 is yy1)):
          raise ApiError("""%s.checkValid: experiments:
           Link experiments between objects from separate partitions
           - ccp.nmr.NmrConstraint.NmrConstraintStore.nmrProject not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = self.getMeasurementLists()
      for value in values:
        from ccp.api.nmr.Nmr import AbstractMeasurementList as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: measurementLists:
           value is not of class ccp.nmr.Nmr.AbstractMeasurementList""" % self.qualifiedName
           + ": %s" % (value,)
          )

        xx1 = dataDict.get('topObject')
        xx2 = xx1.__dict__.get('nmrProject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx2 is yy1)):
          raise ApiError("""%s.checkValid: measurementLists:
           Link measurementLists between objects from separate partitions
           - ccp.nmr.NmrConstraint.NmrConstraintStore.nmrProject not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      value = dataDict.get('method')
      if (value is not None):
        from ccp.api.general.Method import Method as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: method:
           value is not of class ccp.general.Method.Method""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('constraintLists')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: method:
           non-reciprocal link JCouplingConstraintList from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('nmrConstraintListValidations')
      for value in values:
        from ccp.api.molecule.Validation import NmrConstraintListValidation as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: nmrConstraintListValidations:
           value is not of class ccp.molecule.Validation.NmrConstraintListValidation""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('nmrConstraintLists')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: nmrConstraintListValidations:
           non-reciprocal link JCouplingConstraintList from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        yy2 = yy1.__dict__.get('nmrConstraintStore')
        if (not (xx1 is yy2)):
          raise ApiError("""%s.checkValid: nmrConstraintListValidations:
           Link nmrConstraintListValidations between objects from separate partitions
           - ccp.molecule.Validation.ValidationStore.nmrConstraintStore not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      value = dataDict.get('nmrConstraintStore')
      if (not isinstance(value, NmrConstraintStore)):
        raise ApiError("""%s.checkValid: nmrConstraintStore:
         value is not of class ccp.nmr.NmrConstraint.NmrConstraintStore""" % self.qualifiedName
         + ": %s" % (value,)
        )

      root = dataDict.get('topObject').__dict__.get('memopsRoot')
      root.refreshTopObjects('molsim.NmrSim')
      tobjList = root.__dict__.get('nmrSimStores').values()
      for tobj in tobjList:
        if (not (tobj.__dict__.get('isLoaded'))):
          tobj.load()

      values = dataDict.get('nmrSimEnergyTerms')
      for value in values:
        from molsim.api.NmrSim import NmrSimEnergyTerm as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: nmrSimEnergyTerms:
           value is not of class molsim.NmrSim.NmrSimEnergyTerm""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('constraintLists')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: nmrSimEnergyTerms:
           non-reciprocal link JCouplingConstraintList from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

    # check explicit class constraints
    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('details')
    values = dataDict.get('experimentSerials')
    values = dataDict.get('measureListSerials')
    value = dataDict.get('name')
    value = dataDict.get('unit')
    value = dataDict.get('usedForCalculation')
    if (value is None):
      raise ApiError("""%s.checkValid: usedForCalculation:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    # check roles
    value = dataDict.get('access')
    value = dataDict.get('conditionState')
    values = dataDict.get('constraints').values()
    value = dataDict.get('method')
    values = dataDict.get('nmrConstraintListValidations')
    for value in values:
      ll= value.keywordDefinition.targetNames
      isValid = (not ll or self.qualifiedName in ll)
      if (not (isValid)):
        raise ApiError("""%s.checkValid: nmrConstraintListValidations:
         nmrConstraintListValidations constraint KeywordDefinition_fits_ConstraintList violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    value = dataDict.get('nmrConstraintStore')
    if (value is None):
      raise ApiError("""%s.checkValid: nmrConstraintStore:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    values = dataDict.get('nmrSimEnergyTerms')

  delete = memops.api.Implementation.DataObject.delete

  findAllApplicationData = memops.api.Implementation.DataObject.findAllApplicationData
  
  def findAllConstraints(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.JCouplingConstraintList.constraints
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('constraints').values()
      result = set(currentValues)

    else:
      currentValues = dataDict.get('constraints').values()
      result = set()
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('details', 'error', 'lowerLimit', 'origData', 'serial', 'targetValue', 'upperLimit', 'weight', 'access', 'method', 'parentList',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result.add(v)

    return result

  findAllExperiments = AbstractConstraintList.findAllExperiments

  findAllMeasurementLists = AbstractConstraintList.findAllMeasurementLists

  findAllNmrConstraintListValidations = AbstractConstraintList.findAllNmrConstraintListValidations

  findAllNmrSimEnergyTerms = AbstractConstraintList.findAllNmrSimEnergyTerms

  findFirstApplicationData = memops.api.Implementation.DataObject.findFirstApplicationData
  
  def findFirstConstraint(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.JCouplingConstraintList.constraints
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('constraints').values()
      if (currentValues):
        result = iter(currentValues).next()
      else:
        result = None

    else:
      objKey = conditions.get('serial')
      if (objKey is not None):
        result = dataDict.get('constraints').get(objKey)

        if (result is None):
          return result

        elif (len(conditions) <= 1):
          return result

        else:
          currentValues = set()
          currentValues.add(result)

      else:
        currentValues = dataDict.get('constraints').values()

      result = None
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('details', 'error', 'lowerLimit', 'origData', 'serial', 'targetValue', 'upperLimit', 'weight', 'access', 'method', 'parentList',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result = v; break

    return result

  findFirstExperiment = AbstractConstraintList.findFirstExperiment

  findFirstMeasurementList = AbstractConstraintList.findFirstMeasurementList

  findFirstNmrConstraintListValidation = AbstractConstraintList.findFirstNmrConstraintListValidation

  findFirstNmrSimEnergyTerm = AbstractConstraintList.findFirstNmrSimEnergyTerm
  
  def get(self, name):
    """
    GetAttr for ccp.nmr.NmrConstraint.JCouplingConstraintList
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getAccess = memops.api.Implementation.DataObject.getAccess

  getApplicationData = memops.api.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.JCouplingConstraintList
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (2 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.JCouplingConstraintList'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (1 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.JCouplingConstraintList'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-1]
      obj2 = obj1.__dict__.get('constraintLists').get(objKey)
      if (isinstance(obj2, JCouplingConstraintList)):
        result = obj2

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = memops.api.Implementation.MemopsObject.getByNavigation

  getClassName = memops.api.Implementation.ComplexDataType.getClassName

  getConditionState = AbstractConstraintList.getConditionState
  
  def getConstraints(self):
    """
    Get for ccp.nmr.NmrConstraint.JCouplingConstraintList.constraints
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('constraints').values()
    result = frozenset(tempVar)
    return result

  getDetails = AbstractConstraintList.getDetails

  getExpandedKey = memops.api.Implementation.MemopsObject.getExpandedKey

  getExperimentSerials = AbstractConstraintList.getExperimentSerials

  getExperiments = AbstractConstraintList.getExperiments

  getFieldNames = memops.api.Implementation.ComplexDataType.getFieldNames

  getFullKey = AbstractConstraintList.getFullKey

  getInConstructor = memops.api.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = memops.api.Implementation.MemopsObject.getIsDeleted

  getLocalKey = AbstractConstraintList.getLocalKey

  getMeasureListSerials = AbstractConstraintList.getMeasureListSerials

  getMeasurementLists = AbstractConstraintList.getMeasurementLists

  getMetaclass = memops.api.Implementation.ComplexDataType.getMetaclass

  getMethod = AbstractConstraintList.getMethod

  getName = AbstractConstraintList.getName

  getNmrConstraintListValidations = AbstractConstraintList.getNmrConstraintListValidations

  getNmrConstraintStore = AbstractConstraintList.getNmrConstraintStore

  getNmrSimEnergyTerms = AbstractConstraintList.getNmrSimEnergyTerms

  getPackageName = memops.api.Implementation.ComplexDataType.getPackageName

  getPackageShortName = memops.api.Implementation.ComplexDataType.getPackageShortName

  getParent = AbstractConstraintList.getParent

  getQualifiedName = memops.api.Implementation.ComplexDataType.getQualifiedName

  getRoot = memops.api.Implementation.MemopsObject.getRoot

  getSerial = AbstractConstraintList.getSerial

  getTopObject = memops.api.Implementation.DataObject.getTopObject

  getUnit = AbstractConstraintList.getUnit

  getUsedForCalculation = AbstractConstraintList.getUsedForCalculation
  
  def newJCouplingConstraint(self, **attrlinks):
    """
    Factory function to create ccp.nmr.NmrConstraint.JCouplingConstraint
    """
    return JCouplingConstraint(self, **attrlinks)

  removeApplicationData = memops.api.Implementation.DataObject.removeApplicationData

  removeExperiment = AbstractConstraintList.removeExperiment

  removeExperimentSerial = AbstractConstraintList.removeExperimentSerial

  removeMeasureListSerial = AbstractConstraintList.removeMeasureListSerial

  removeMeasurementList = AbstractConstraintList.removeMeasurementList

  removeNmrConstraintListValidation = AbstractConstraintList.removeNmrConstraintListValidation

  removeNmrSimEnergyTerm = AbstractConstraintList.removeNmrSimEnergyTerm
  
  def set(self, name, value):
    """
    SetAttr for ccp.nmr.NmrConstraint.JCouplingConstraintList
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setAccess = memops.api.Implementation.DataObject.setAccess

  setApplicationData = memops.api.Implementation.DataObject.setApplicationData

  setConditionState = AbstractConstraintList.setConditionState

  setDetails = AbstractConstraintList.setDetails

  setExperimentSerials = AbstractConstraintList.setExperimentSerials

  setExperiments = AbstractConstraintList.setExperiments

  setMeasureListSerials = AbstractConstraintList.setMeasureListSerials

  setMeasurementLists = AbstractConstraintList.setMeasurementLists

  setMethod = AbstractConstraintList.setMethod

  setName = AbstractConstraintList.setName

  setNmrConstraintListValidations = AbstractConstraintList.setNmrConstraintListValidations

  setNmrSimEnergyTerms = AbstractConstraintList.setNmrSimEnergyTerms

  setSerial = AbstractConstraintList.setSerial

  setUnit = AbstractConstraintList.setUnit

  setUsedForCalculation = AbstractConstraintList.setUsedForCalculation
  
  def sortedConstraints(self):
    """
    Sorted for ccp.nmr.NmrConstraint.JCouplingConstraintList.constraints
    """
    dataDict = self.__dict__
    sortdd = dataDict.get('constraints')
    
    ll = sortdd.keys()
    ll.sort()
    result = [sortdd[x] for x in ll]
    return result

  sortedExperiments = AbstractConstraintList.sortedExperiments

  sortedMeasurementLists = AbstractConstraintList.sortedMeasurementLists

  sortedNmrConstraintListValidations = AbstractConstraintList.sortedNmrConstraintListValidations

  sortedNmrSimEnergyTerms = AbstractConstraintList.sortedNmrSimEnergyTerms

  toDetailedString = memops.api.Implementation.ComplexDataType.toDetailedString

  applicationData = memops.api.Implementation.DataObject.applicationData

  className = memops.api.Implementation.ComplexDataType.className

  details = AbstractConstraintList.details

  experimentSerials = AbstractConstraintList.experimentSerials

  fieldNames = memops.api.Implementation.ComplexDataType.fieldNames

  inConstructor = memops.api.Implementation.ComplexDataType.inConstructor

  isDeleted = memops.api.Implementation.MemopsObject.isDeleted

  measureListSerials = AbstractConstraintList.measureListSerials

  metaclass = memops.api.Implementation.ComplexDataType.metaclass

  name = AbstractConstraintList.name

  packageName = memops.api.Implementation.ComplexDataType.packageName

  packageShortName = memops.api.Implementation.ComplexDataType.packageShortName

  qualifiedName = memops.api.Implementation.ComplexDataType.qualifiedName

  serial = AbstractConstraintList.serial

  unit = AbstractConstraintList.unit

  usedForCalculation = AbstractConstraintList.usedForCalculation

  access = memops.api.Implementation.DataObject.access

  conditionState = AbstractConstraintList.conditionState
  
  constraints = property(getConstraints,  None, None,
  r"""child link to class JCouplingConstraint
  """)

  experiments = AbstractConstraintList.experiments

  measurementLists = AbstractConstraintList.measurementLists

  method = AbstractConstraintList.method

  nmrConstraintListValidations = AbstractConstraintList.nmrConstraintListValidations

  nmrConstraintStore = AbstractConstraintList.nmrConstraintStore

  nmrSimEnergyTerms = AbstractConstraintList.nmrSimEnergyTerms

  parent = AbstractConstraintList.parent

  root = memops.api.Implementation.MemopsObject.root

  topObject = memops.api.Implementation.DataObject.topObject

###############################################################################
class CsaConstraintList(AbstractConstraintList):
  r"""
  """
  #   from data model element ccp.nmr.NmrConstraint.CsaConstraintList revision 1.1.2.9
  _metaclass = metaPackage.getElement('CsaConstraintList')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('applicationData', 'className', 'details', 'experimentSerials', 'fieldNames', 'inConstructor', 'isDeleted', 'isotopeCode', 'measureListSerials', 'metaclass', 'name', 'packageName', 'packageShortName', 'qualifiedName', 'serial', 'unit', 'usedForCalculation', 'access', 'conditionState', 'constraints', 'experiments', 'isotope', 'measurementLists', 'method', 'nmrConstraintListValidations', 'nmrConstraintStore', 'nmrSimEnergyTerms', 'parent', 'root', 'topObject',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccp.nmr.NmrConstraint.CsaConstraintList
    """
    dataDict = self.__dict__
    dataDict['nmrConstraintStore'] = parent
    if (not isinstance(parent, NmrConstraintStore)):
      raise ApiError("""%s.__init__:
       value is not of class ccp.nmr.NmrConstraint.NmrConstraintStore""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:
      if (not ((parent.__dict__.get('isLoaded') or parent.__dict__.get('isReading')))):
        parent.load()

      dataDict['applicationData'] = list()
      dataDict['details'] = None
      dataDict['experimentSerials'] = set()
      dataDict['isotopeCode'] = None
      dataDict['measureListSerials'] = set()
      dataDict['name'] = None
      dataDict['serial'] = None
      dataDict['unit'] = None
      dataDict['usedForCalculation'] = True
      dataDict['access'] = None
      dataDict['conditionState'] = None
      dataDict['constraints'] = {}
      dataDict['method'] = None
      dataDict['nmrConstraintListValidations'] = set()
      dataDict['nmrSimEnergyTerms'] = set()

      dataDict['inConstructor'] = True
      try:
        
        for key, value in attrlinks.iteritems():
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        del dataDict['inConstructor']
      except:
        print "ERROR in ccp.nmr.NmrConstraint.CsaConstraintList.__init__"
        del dataDict['inConstructor']
        raise

      if (notOverride):
        if (dataDict.get('serial') is None):
          dataDict['inConstructor'] = True
          self.setSerial(-1)
          del dataDict['inConstructor']
        else:
          raise ApiError("""%s.__init__:
           Cannot pass in explicit serial if not reading""" % self.qualifiedName
           + ": %s:%s" % (parent, 'ccp.nmr.NmrConstraint.CsaConstraintList')
          )

      serialDict = {}
      serialDict['constraints'] = 0
      dataDict['_serialDict'] = serialDict

      if (notIsReading):
        childrenDict = parent.__dict__.get('constraintLists')
        objKey = dataDict.get('serial')
        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['serial'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        print '''WARNING Error in clean-up of incorrectly created object. 
        Data may be left in an illegal state'''
        del dataDict['inConstructor']
      raise exc_info[0], exc_info[1], exc_info[2]

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccp.nmr.NmrConstraint.CsaConstraintList:
       determines 
    cascading deletes to follow from delete of object.
       *Implementation 
    function* - should be called only by API delete function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
      dataDict.get('topObject').load()

    access = dataDict.get('access')
    if (access is not None):
      topObject = access.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    constraints = dataDict.get('constraints').values()
    for constraint in constraints:
      if (not (constraint in objsToBeDeleted)):
        objsToBeDeleted.add(constraint)
        objsToBeChecked.append(constraint)

    method = dataDict.get('method')
    if (method is not None):
      topObject = method.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    nmrConstraintListValidations = dataDict.get('nmrConstraintListValidations')
    pass
    for nmrConstraintListValidation in nmrConstraintListValidations:
      topObject = nmrConstraintListValidation.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    root = dataDict.get('topObject').__dict__.get('memopsRoot')
    root.refreshTopObjects('molsim.NmrSim')
    tobjList = root.__dict__.get('nmrSimStores').values()
    for tobj in tobjList:
      if (not (tobj.__dict__.get('isLoaded'))):
        tobj.load()

    nmrSimEnergyTerms = dataDict.get('nmrSimEnergyTerms')
    pass
    for nmrSimEnergyTerm in nmrSimEnergyTerms:
      topObject = nmrSimEnergyTerm.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccp.nmr.NmrConstraint.CsaConstraintList:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    access = dataDict.get('access')
    if ((access is not None and not (access in objsToBeDeleted))):
      dataObjects = access.__dict__.get('dataObjects')
      dataObjects.remove(self)

    conditionState = dataDict.get('conditionState')
    if ((conditionState is not None and not (conditionState in objsToBeDeleted))):
      constraintLists = conditionState.__dict__.get('constraintLists')
      constraintLists.remove(self)

    method = dataDict.get('method')
    if ((method is not None and not (method in objsToBeDeleted))):
      constraintLists = method.__dict__.get('constraintLists')
      constraintLists.remove(self)

    for nmrConstraintListValidation in dataDict.get('nmrConstraintListValidations'):
      if (not (nmrConstraintListValidation in objsToBeDeleted)):
        nmrConstraintLists = nmrConstraintListValidation.__dict__.get('nmrConstraintLists')
        nmrConstraintLists.remove(self)

    for nmrSimEnergyTerm in dataDict.get('nmrSimEnergyTerms'):
      if (not (nmrSimEnergyTerm in objsToBeDeleted)):
        constraintLists = nmrSimEnergyTerm.__dict__.get('constraintLists')
        constraintLists.remove(self)

    nmrConstraintStore = dataDict.get('nmrConstraintStore')
    if (not (nmrConstraintStore in objsToBeDeleted)):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = nmrConstraintStore.__dict__.get('constraintLists')
        if (self is dd.get(objKey)):
          del dd[objKey]

  addApplicationData = memops.api.Implementation.DataObject.addApplicationData

  addExperiment = AbstractConstraintList.addExperiment

  addExperimentSerial = AbstractConstraintList.addExperimentSerial

  addMeasureListSerial = AbstractConstraintList.addMeasureListSerial

  addMeasurementList = AbstractConstraintList.addMeasurementList

  addNmrConstraintListValidation = AbstractConstraintList.addNmrConstraintListValidation

  addNmrSimEnergyTerm = AbstractConstraintList.addNmrSimEnergyTerm
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccp.nmr.NmrConstraint.CsaConstraintList
    """
    dataDict = self.__dict__
    self.checkValid(complete)
    values = dataDict.get('constraints').values()
    for value in values:
      value.checkAllValid(complete)

  def checkValid(self, complete=False):
    """
    CheckValid for ccp.nmr.NmrConstraint.CsaConstraintList
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('nmrConstraintStore')
        dd = value.__dict__.get('constraintLists')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'nmrConstraintStore' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from memops.api.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('details')
      if (value is not None):
        if (isinstance(value, memops.api.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: details:
           memops.Implementation.String input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      values = dataDict.get('experimentSerials')
      for value in values:
        if (isinstance(value, memops.api.Implementation.Int.PythonType)):
          pass
        elif ([x for x in memops.api.Implementation.Int.compatibleTypes if isinstance(value, x)]):
          castValue = memops.api.Implementation.Int.create(value)
          values.remove(value)
          if (castValue in values):
            values.add(value)
            raise ApiError("""%s.checkValid: experimentSerials:
             replacement value already in unique collection """ % self.qualifiedName
             + ": %s" % (castValue,)
            )
          else:
            values.add(castValue)

          value = castValue
        else:
          raise ApiError("""%s.checkValid: experimentSerials:
           memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('isotopeCode')
      if (value is not None):
        if (isinstance(value, memops.api.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: isotopeCode:
           memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 32):
          raise ApiError("""%s.checkValid: isotopeCode:
           memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: isotopeCode:
           memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.split()) == 1)):
          raise ApiError("""%s.checkValid: isotopeCode:
           Word constraint contains_no_white_space violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      values = dataDict.get('measureListSerials')
      for value in values:
        if (isinstance(value, memops.api.Implementation.Int.PythonType)):
          pass
        elif ([x for x in memops.api.Implementation.Int.compatibleTypes if isinstance(value, x)]):
          castValue = memops.api.Implementation.Int.create(value)
          values.remove(value)
          if (castValue in values):
            values.add(value)
            raise ApiError("""%s.checkValid: measureListSerials:
             replacement value already in unique collection """ % self.qualifiedName
             + ": %s" % (castValue,)
            )
          else:
            values.add(castValue)

          value = castValue
        else:
          raise ApiError("""%s.checkValid: measureListSerials:
           memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('name')
      if (value is not None):
        if (isinstance(value, memops.api.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: name:
           memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 80):
          raise ApiError("""%s.checkValid: name:
           memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: name:
           memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.splitlines()) <= 1)):
          raise ApiError("""%s.checkValid: name:
           Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, memops.api.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('serial')
      if (value is None):
        raise ApiError("""%s.checkValid: serial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, memops.api.Implementation.Int.PythonType)):
        pass
      elif ([x for x in memops.api.Implementation.Int.compatibleTypes if isinstance(value, x)]):
        value = memops.api.Implementation.Int.create(value)
      else:
        raise ApiError("""%s.checkValid: serial:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('unit')
      if (value is not None):
        if (isinstance(value, memops.api.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: unit:
           memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 32):
          raise ApiError("""%s.checkValid: unit:
           memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: unit:
           memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.split()) == 1)):
          raise ApiError("""%s.checkValid: unit:
           Word constraint contains_no_white_space violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('usedForCalculation')
      if (not (value in [True, False])):
        raise ApiError("""%s.checkValid: usedForCalculation:
         memops.Implementation.Boolean input is not in enumeration [True, False]""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('access')
      if (value is not None):
        from memops.api.AccessControl import AccessObject as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: access:
           value is not of class memops.AccessControl.AccessObject""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('dataObjects')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: access:
           non-reciprocal link CsaConstraintList from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      value = dataDict.get('conditionState')
      if (value is not None):
        if (not isinstance(value, ConditionState)):
          raise ApiError("""%s.checkValid: conditionState:
           value is not of class ccp.nmr.NmrConstraint.ConditionState""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('constraintLists')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: conditionState:
           non-reciprocal link CsaConstraintList from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('constraints').values()
      for value in values:
        if (not isinstance(value, CsaConstraint)):
          raise ApiError("""%s.checkValid: constraints:
           value is not of class ccp.nmr.NmrConstraint.CsaConstraint""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('parentList')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: constraints:
           non-reciprocal link CsaConstraintList from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = self.getExperiments()
      for value in values:
        from ccp.api.nmr.Nmr import Experiment as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: experiments:
           value is not of class ccp.nmr.Nmr.Experiment""" % self.qualifiedName
           + ": %s" % (value,)
          )

        xx1 = dataDict.get('topObject')
        xx2 = xx1.__dict__.get('nmrProject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx2 is yy1)):
          raise ApiError("""%s.checkValid: experiments:
           Link experiments between objects from separate partitions
           - ccp.nmr.NmrConstraint.NmrConstraintStore.nmrProject not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      value = self.getIsotope()
      if (value is not None):
        from ccp.api.molecule.ChemElement import Isotope as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: isotope:
           value is not of class ccp.molecule.ChemElement.Isotope""" % self.qualifiedName
           + ": %s" % (value,)
          )

        xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
        yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: isotope:
           Link isotope between objects from separate partitions
           - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = self.getMeasurementLists()
      for value in values:
        from ccp.api.nmr.Nmr import AbstractMeasurementList as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: measurementLists:
           value is not of class ccp.nmr.Nmr.AbstractMeasurementList""" % self.qualifiedName
           + ": %s" % (value,)
          )

        xx1 = dataDict.get('topObject')
        xx2 = xx1.__dict__.get('nmrProject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx2 is yy1)):
          raise ApiError("""%s.checkValid: measurementLists:
           Link measurementLists between objects from separate partitions
           - ccp.nmr.NmrConstraint.NmrConstraintStore.nmrProject not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      value = dataDict.get('method')
      if (value is not None):
        from ccp.api.general.Method import Method as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: method:
           value is not of class ccp.general.Method.Method""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('constraintLists')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: method:
           non-reciprocal link CsaConstraintList from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('nmrConstraintListValidations')
      for value in values:
        from ccp.api.molecule.Validation import NmrConstraintListValidation as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: nmrConstraintListValidations:
           value is not of class ccp.molecule.Validation.NmrConstraintListValidation""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('nmrConstraintLists')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: nmrConstraintListValidations:
           non-reciprocal link CsaConstraintList from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        yy2 = yy1.__dict__.get('nmrConstraintStore')
        if (not (xx1 is yy2)):
          raise ApiError("""%s.checkValid: nmrConstraintListValidations:
           Link nmrConstraintListValidations between objects from separate partitions
           - ccp.molecule.Validation.ValidationStore.nmrConstraintStore not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      value = dataDict.get('nmrConstraintStore')
      if (not isinstance(value, NmrConstraintStore)):
        raise ApiError("""%s.checkValid: nmrConstraintStore:
         value is not of class ccp.nmr.NmrConstraint.NmrConstraintStore""" % self.qualifiedName
         + ": %s" % (value,)
        )

      root = dataDict.get('topObject').__dict__.get('memopsRoot')
      root.refreshTopObjects('molsim.NmrSim')
      tobjList = root.__dict__.get('nmrSimStores').values()
      for tobj in tobjList:
        if (not (tobj.__dict__.get('isLoaded'))):
          tobj.load()

      values = dataDict.get('nmrSimEnergyTerms')
      for value in values:
        from molsim.api.NmrSim import NmrSimEnergyTerm as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: nmrSimEnergyTerms:
           value is not of class molsim.NmrSim.NmrSimEnergyTerm""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('constraintLists')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: nmrSimEnergyTerms:
           non-reciprocal link CsaConstraintList from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

    # check explicit class constraints
    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('details')
    values = dataDict.get('experimentSerials')
    value = dataDict.get('isotopeCode')
    values = dataDict.get('measureListSerials')
    value = dataDict.get('name')
    value = dataDict.get('unit')
    value = dataDict.get('usedForCalculation')
    if (value is None):
      raise ApiError("""%s.checkValid: usedForCalculation:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    # check roles
    value = dataDict.get('access')
    value = dataDict.get('conditionState')
    values = dataDict.get('constraints').values()
    value = dataDict.get('method')
    values = dataDict.get('nmrConstraintListValidations')
    for value in values:
      ll= value.keywordDefinition.targetNames
      isValid = (not ll or self.qualifiedName in ll)
      if (not (isValid)):
        raise ApiError("""%s.checkValid: nmrConstraintListValidations:
         nmrConstraintListValidations constraint KeywordDefinition_fits_ConstraintList violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    value = dataDict.get('nmrConstraintStore')
    if (value is None):
      raise ApiError("""%s.checkValid: nmrConstraintStore:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    values = dataDict.get('nmrSimEnergyTerms')

  delete = memops.api.Implementation.DataObject.delete

  findAllApplicationData = memops.api.Implementation.DataObject.findAllApplicationData
  
  def findAllConstraints(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.CsaConstraintList.constraints
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('constraints').values()
      result = set(currentValues)

    else:
      currentValues = dataDict.get('constraints').values()
      result = set()
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('details', 'error', 'lowerLimit', 'origData', 'serial', 'targetValue', 'upperLimit', 'weight', 'access', 'method', 'parentList', 'resonance',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result.add(v)

    return result

  findAllExperiments = AbstractConstraintList.findAllExperiments

  findAllMeasurementLists = AbstractConstraintList.findAllMeasurementLists

  findAllNmrConstraintListValidations = AbstractConstraintList.findAllNmrConstraintListValidations

  findAllNmrSimEnergyTerms = AbstractConstraintList.findAllNmrSimEnergyTerms

  findFirstApplicationData = memops.api.Implementation.DataObject.findFirstApplicationData
  
  def findFirstConstraint(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.CsaConstraintList.constraints
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('constraints').values()
      if (currentValues):
        result = iter(currentValues).next()
      else:
        result = None

    else:
      objKey = conditions.get('serial')
      if (objKey is not None):
        result = dataDict.get('constraints').get(objKey)

        if (result is None):
          return result

        elif (len(conditions) <= 1):
          return result

        else:
          currentValues = set()
          currentValues.add(result)

      else:
        currentValues = dataDict.get('constraints').values()

      result = None
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('details', 'error', 'lowerLimit', 'origData', 'serial', 'targetValue', 'upperLimit', 'weight', 'access', 'method', 'parentList', 'resonance',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result = v; break

    return result

  findFirstExperiment = AbstractConstraintList.findFirstExperiment

  findFirstMeasurementList = AbstractConstraintList.findFirstMeasurementList

  findFirstNmrConstraintListValidation = AbstractConstraintList.findFirstNmrConstraintListValidation

  findFirstNmrSimEnergyTerm = AbstractConstraintList.findFirstNmrSimEnergyTerm
  
  def get(self, name):
    """
    GetAttr for ccp.nmr.NmrConstraint.CsaConstraintList
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getAccess = memops.api.Implementation.DataObject.getAccess

  getApplicationData = memops.api.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.CsaConstraintList
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (2 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.CsaConstraintList'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (1 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.CsaConstraintList'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-1]
      obj2 = obj1.__dict__.get('constraintLists').get(objKey)
      if (isinstance(obj2, CsaConstraintList)):
        result = obj2

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = memops.api.Implementation.MemopsObject.getByNavigation

  getClassName = memops.api.Implementation.ComplexDataType.getClassName

  getConditionState = AbstractConstraintList.getConditionState
  
  def getConstraints(self):
    """
    Get for ccp.nmr.NmrConstraint.CsaConstraintList.constraints
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('constraints').values()
    result = frozenset(tempVar)
    return result

  getDetails = AbstractConstraintList.getDetails

  getExpandedKey = memops.api.Implementation.MemopsObject.getExpandedKey

  getExperimentSerials = AbstractConstraintList.getExperimentSerials

  getExperiments = AbstractConstraintList.getExperiments

  getFieldNames = memops.api.Implementation.ComplexDataType.getFieldNames

  getFullKey = AbstractConstraintList.getFullKey

  getInConstructor = memops.api.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = memops.api.Implementation.MemopsObject.getIsDeleted
  
  def getIsotope(self):
    """
    getter for derived link isotope
    """
    dataDict = self.__dict__
    ss = self.isotopeCode
    if ss is None:
      result = None
    else:
      if ss[-2] in '0123456789':
        firstLetter = -1
      else:
        firstLetter = -2
      atomSymbol = ss[firstLetter:].capitalize()
      massNumber = int(ss[:firstLetter])
    
      result = ccp.api.molecule.ChemElement.Isotope.getByKey(self.root.currentChemElementStore, (atomSymbol, massNumber))
    return result
  
  def getIsotopeCode(self):
    """
    Get for ccp.nmr.NmrConstraint.CsaConstraintList.isotopeCode
    """
    dataDict = self.__dict__
    result = dataDict.get('isotopeCode')
    return result

  getLocalKey = AbstractConstraintList.getLocalKey

  getMeasureListSerials = AbstractConstraintList.getMeasureListSerials

  getMeasurementLists = AbstractConstraintList.getMeasurementLists

  getMetaclass = memops.api.Implementation.ComplexDataType.getMetaclass

  getMethod = AbstractConstraintList.getMethod

  getName = AbstractConstraintList.getName

  getNmrConstraintListValidations = AbstractConstraintList.getNmrConstraintListValidations

  getNmrConstraintStore = AbstractConstraintList.getNmrConstraintStore

  getNmrSimEnergyTerms = AbstractConstraintList.getNmrSimEnergyTerms

  getPackageName = memops.api.Implementation.ComplexDataType.getPackageName

  getPackageShortName = memops.api.Implementation.ComplexDataType.getPackageShortName

  getParent = AbstractConstraintList.getParent

  getQualifiedName = memops.api.Implementation.ComplexDataType.getQualifiedName

  getRoot = memops.api.Implementation.MemopsObject.getRoot

  getSerial = AbstractConstraintList.getSerial

  getTopObject = memops.api.Implementation.DataObject.getTopObject

  getUnit = AbstractConstraintList.getUnit

  getUsedForCalculation = AbstractConstraintList.getUsedForCalculation
  
  def newCsaConstraint(self, **attrlinks):
    """
    Factory function to create ccp.nmr.NmrConstraint.CsaConstraint
    """
    return CsaConstraint(self, **attrlinks)

  removeApplicationData = memops.api.Implementation.DataObject.removeApplicationData

  removeExperiment = AbstractConstraintList.removeExperiment

  removeExperimentSerial = AbstractConstraintList.removeExperimentSerial

  removeMeasureListSerial = AbstractConstraintList.removeMeasureListSerial

  removeMeasurementList = AbstractConstraintList.removeMeasurementList

  removeNmrConstraintListValidation = AbstractConstraintList.removeNmrConstraintListValidation

  removeNmrSimEnergyTerm = AbstractConstraintList.removeNmrSimEnergyTerm
  
  def set(self, name, value):
    """
    SetAttr for ccp.nmr.NmrConstraint.CsaConstraintList
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setAccess = memops.api.Implementation.DataObject.setAccess

  setApplicationData = memops.api.Implementation.DataObject.setApplicationData

  setConditionState = AbstractConstraintList.setConditionState

  setDetails = AbstractConstraintList.setDetails

  setExperimentSerials = AbstractConstraintList.setExperimentSerials

  setExperiments = AbstractConstraintList.setExperiments
  
  def setIsotopeCode(self, value):
    """
    Set for ccp.nmr.NmrConstraint.CsaConstraintList.isotopeCode
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, memops.api.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.setIsotopeCode:
         memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 32):
        raise ApiError("""%s.setIsotopeCode:
         memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.setIsotopeCode:
         memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.split()) == 1)):
        raise ApiError("""%s.setIsotopeCode:
         Word constraint contains_no_white_space violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('isotopeCode')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setIsotopeCode:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setIsotopeCode:
       called on deleted object""" % self.qualifiedName
      )

    if (value == currentValue):
      return

    if (notOverride):
      pass

    dataDict['isotopeCode'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setIsotopeCode')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  setMeasureListSerials = AbstractConstraintList.setMeasureListSerials

  setMeasurementLists = AbstractConstraintList.setMeasurementLists

  setMethod = AbstractConstraintList.setMethod

  setName = AbstractConstraintList.setName

  setNmrConstraintListValidations = AbstractConstraintList.setNmrConstraintListValidations

  setNmrSimEnergyTerms = AbstractConstraintList.setNmrSimEnergyTerms

  setSerial = AbstractConstraintList.setSerial

  setUnit = AbstractConstraintList.setUnit

  setUsedForCalculation = AbstractConstraintList.setUsedForCalculation
  
  def sortedConstraints(self):
    """
    Sorted for ccp.nmr.NmrConstraint.CsaConstraintList.constraints
    """
    dataDict = self.__dict__
    sortdd = dataDict.get('constraints')
    
    ll = sortdd.keys()
    ll.sort()
    result = [sortdd[x] for x in ll]
    return result

  sortedExperiments = AbstractConstraintList.sortedExperiments

  sortedMeasurementLists = AbstractConstraintList.sortedMeasurementLists

  sortedNmrConstraintListValidations = AbstractConstraintList.sortedNmrConstraintListValidations

  sortedNmrSimEnergyTerms = AbstractConstraintList.sortedNmrSimEnergyTerms

  toDetailedString = memops.api.Implementation.ComplexDataType.toDetailedString

  applicationData = memops.api.Implementation.DataObject.applicationData

  className = memops.api.Implementation.ComplexDataType.className

  details = AbstractConstraintList.details

  experimentSerials = AbstractConstraintList.experimentSerials

  fieldNames = memops.api.Implementation.ComplexDataType.fieldNames

  inConstructor = memops.api.Implementation.ComplexDataType.inConstructor

  isDeleted = memops.api.Implementation.MemopsObject.isDeleted
  
  isotopeCode = property(getIsotopeCode, setIsotopeCode, None,
  r"""String indicating Isotope (e.g. 13C, 3He, 2H, 235U  ...) to which all 
  chemical shift anisotropies in list should belong
  """)

  measureListSerials = AbstractConstraintList.measureListSerials

  metaclass = memops.api.Implementation.ComplexDataType.metaclass

  name = AbstractConstraintList.name

  packageName = memops.api.Implementation.ComplexDataType.packageName

  packageShortName = memops.api.Implementation.ComplexDataType.packageShortName

  qualifiedName = memops.api.Implementation.ComplexDataType.qualifiedName

  serial = AbstractConstraintList.serial

  unit = AbstractConstraintList.unit

  usedForCalculation = AbstractConstraintList.usedForCalculation

  access = memops.api.Implementation.DataObject.access

  conditionState = AbstractConstraintList.conditionState
  
  constraints = property(getConstraints,  None, None,
  r"""child link to class CsaConstraint
  """)

  experiments = AbstractConstraintList.experiments
  
  isotope = property(getIsotope, None, None,
  r"""Isotope for Constraints in Chemical Shift Anisotropy Constraint List
  """)

  measurementLists = AbstractConstraintList.measurementLists

  method = AbstractConstraintList.method

  nmrConstraintListValidations = AbstractConstraintList.nmrConstraintListValidations

  nmrConstraintStore = AbstractConstraintList.nmrConstraintStore

  nmrSimEnergyTerms = AbstractConstraintList.nmrSimEnergyTerms

  parent = AbstractConstraintList.parent

  root = memops.api.Implementation.MemopsObject.root

  topObject = memops.api.Implementation.DataObject.topObject

###############################################################################
class DihedralConstraintList(AbstractConstraintList):
  r"""List of Dihedral angle restraints, including those that arise from J 
couplings.
  """
  #   from data model element ccp.nmr.NmrConstraint.DihedralConstraintList revision 1.36.2.9
  _metaclass = metaPackage.getElement('DihedralConstraintList')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('applicationData', 'className', 'details', 'experimentSerials', 'fieldNames', 'inConstructor', 'isDeleted', 'measureListSerials', 'metaclass', 'name', 'packageName', 'packageShortName', 'qualifiedName', 'serial', 'unit', 'usedForCalculation', 'access', 'conditionState', 'constraints', 'experiments', 'measurementLists', 'method', 'nmrConstraintListValidations', 'nmrConstraintStore', 'nmrSimEnergyTerms', 'parent', 'root', 'topObject',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccp.nmr.NmrConstraint.DihedralConstraintList
    """
    dataDict = self.__dict__
    dataDict['nmrConstraintStore'] = parent
    if (not isinstance(parent, NmrConstraintStore)):
      raise ApiError("""%s.__init__:
       value is not of class ccp.nmr.NmrConstraint.NmrConstraintStore""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:
      if (not ((parent.__dict__.get('isLoaded') or parent.__dict__.get('isReading')))):
        parent.load()

      dataDict['applicationData'] = list()
      dataDict['details'] = None
      dataDict['experimentSerials'] = set()
      dataDict['measureListSerials'] = set()
      dataDict['name'] = None
      dataDict['serial'] = None
      dataDict['unit'] = None
      dataDict['usedForCalculation'] = True
      dataDict['access'] = None
      dataDict['conditionState'] = None
      dataDict['constraints'] = {}
      dataDict['method'] = None
      dataDict['nmrConstraintListValidations'] = set()
      dataDict['nmrSimEnergyTerms'] = set()

      dataDict['inConstructor'] = True
      try:
        
        for key, value in attrlinks.iteritems():
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        del dataDict['inConstructor']
      except:
        print "ERROR in ccp.nmr.NmrConstraint.DihedralConstraintList.__init__"
        del dataDict['inConstructor']
        raise

      if (notOverride):
        if (dataDict.get('serial') is None):
          dataDict['inConstructor'] = True
          self.setSerial(-1)
          del dataDict['inConstructor']
        else:
          raise ApiError("""%s.__init__:
           Cannot pass in explicit serial if not reading""" % self.qualifiedName
           + ": %s:%s" % (parent, 'ccp.nmr.NmrConstraint.DihedralConstraintList')
          )

      serialDict = {}
      serialDict['constraints'] = 0
      dataDict['_serialDict'] = serialDict

      if (notIsReading):
        childrenDict = parent.__dict__.get('constraintLists')
        objKey = dataDict.get('serial')
        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['serial'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        print '''WARNING Error in clean-up of incorrectly created object. 
        Data may be left in an illegal state'''
        del dataDict['inConstructor']
      raise exc_info[0], exc_info[1], exc_info[2]

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccp.nmr.NmrConstraint.DihedralConstraintList:
       
    determines cascading deletes to follow from delete of object.
       
    *Implementation function* - should be called only by API delete 
    function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
      dataDict.get('topObject').load()

    access = dataDict.get('access')
    if (access is not None):
      topObject = access.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    constraints = dataDict.get('constraints').values()
    for constraint in constraints:
      if (not (constraint in objsToBeDeleted)):
        objsToBeDeleted.add(constraint)
        objsToBeChecked.append(constraint)

    method = dataDict.get('method')
    if (method is not None):
      topObject = method.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    nmrConstraintListValidations = dataDict.get('nmrConstraintListValidations')
    pass
    for nmrConstraintListValidation in nmrConstraintListValidations:
      topObject = nmrConstraintListValidation.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    root = dataDict.get('topObject').__dict__.get('memopsRoot')
    root.refreshTopObjects('molsim.NmrSim')
    tobjList = root.__dict__.get('nmrSimStores').values()
    for tobj in tobjList:
      if (not (tobj.__dict__.get('isLoaded'))):
        tobj.load()

    nmrSimEnergyTerms = dataDict.get('nmrSimEnergyTerms')
    pass
    for nmrSimEnergyTerm in nmrSimEnergyTerms:
      topObject = nmrSimEnergyTerm.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccp.nmr.NmrConstraint.DihedralConstraintList:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    access = dataDict.get('access')
    if ((access is not None and not (access in objsToBeDeleted))):
      dataObjects = access.__dict__.get('dataObjects')
      dataObjects.remove(self)

    conditionState = dataDict.get('conditionState')
    if ((conditionState is not None and not (conditionState in objsToBeDeleted))):
      constraintLists = conditionState.__dict__.get('constraintLists')
      constraintLists.remove(self)

    method = dataDict.get('method')
    if ((method is not None and not (method in objsToBeDeleted))):
      constraintLists = method.__dict__.get('constraintLists')
      constraintLists.remove(self)

    for nmrConstraintListValidation in dataDict.get('nmrConstraintListValidations'):
      if (not (nmrConstraintListValidation in objsToBeDeleted)):
        nmrConstraintLists = nmrConstraintListValidation.__dict__.get('nmrConstraintLists')
        nmrConstraintLists.remove(self)

    for nmrSimEnergyTerm in dataDict.get('nmrSimEnergyTerms'):
      if (not (nmrSimEnergyTerm in objsToBeDeleted)):
        constraintLists = nmrSimEnergyTerm.__dict__.get('constraintLists')
        constraintLists.remove(self)

    nmrConstraintStore = dataDict.get('nmrConstraintStore')
    if (not (nmrConstraintStore in objsToBeDeleted)):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = nmrConstraintStore.__dict__.get('constraintLists')
        if (self is dd.get(objKey)):
          del dd[objKey]

  addApplicationData = memops.api.Implementation.DataObject.addApplicationData

  addExperiment = AbstractConstraintList.addExperiment

  addExperimentSerial = AbstractConstraintList.addExperimentSerial

  addMeasureListSerial = AbstractConstraintList.addMeasureListSerial

  addMeasurementList = AbstractConstraintList.addMeasurementList

  addNmrConstraintListValidation = AbstractConstraintList.addNmrConstraintListValidation

  addNmrSimEnergyTerm = AbstractConstraintList.addNmrSimEnergyTerm
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccp.nmr.NmrConstraint.DihedralConstraintList
    """
    dataDict = self.__dict__
    self.checkValid(complete)
    values = dataDict.get('constraints').values()
    for value in values:
      value.checkAllValid(complete)

  def checkValid(self, complete=False):
    """
    CheckValid for ccp.nmr.NmrConstraint.DihedralConstraintList
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('nmrConstraintStore')
        dd = value.__dict__.get('constraintLists')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'nmrConstraintStore' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from memops.api.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('details')
      if (value is not None):
        if (isinstance(value, memops.api.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: details:
           memops.Implementation.String input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      values = dataDict.get('experimentSerials')
      for value in values:
        if (isinstance(value, memops.api.Implementation.Int.PythonType)):
          pass
        elif ([x for x in memops.api.Implementation.Int.compatibleTypes if isinstance(value, x)]):
          castValue = memops.api.Implementation.Int.create(value)
          values.remove(value)
          if (castValue in values):
            values.add(value)
            raise ApiError("""%s.checkValid: experimentSerials:
             replacement value already in unique collection """ % self.qualifiedName
             + ": %s" % (castValue,)
            )
          else:
            values.add(castValue)

          value = castValue
        else:
          raise ApiError("""%s.checkValid: experimentSerials:
           memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      values = dataDict.get('measureListSerials')
      for value in values:
        if (isinstance(value, memops.api.Implementation.Int.PythonType)):
          pass
        elif ([x for x in memops.api.Implementation.Int.compatibleTypes if isinstance(value, x)]):
          castValue = memops.api.Implementation.Int.create(value)
          values.remove(value)
          if (castValue in values):
            values.add(value)
            raise ApiError("""%s.checkValid: measureListSerials:
             replacement value already in unique collection """ % self.qualifiedName
             + ": %s" % (castValue,)
            )
          else:
            values.add(castValue)

          value = castValue
        else:
          raise ApiError("""%s.checkValid: measureListSerials:
           memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('name')
      if (value is not None):
        if (isinstance(value, memops.api.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: name:
           memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 80):
          raise ApiError("""%s.checkValid: name:
           memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: name:
           memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.splitlines()) <= 1)):
          raise ApiError("""%s.checkValid: name:
           Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, memops.api.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('serial')
      if (value is None):
        raise ApiError("""%s.checkValid: serial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, memops.api.Implementation.Int.PythonType)):
        pass
      elif ([x for x in memops.api.Implementation.Int.compatibleTypes if isinstance(value, x)]):
        value = memops.api.Implementation.Int.create(value)
      else:
        raise ApiError("""%s.checkValid: serial:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('unit')
      if (value is not None):
        if (isinstance(value, memops.api.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: unit:
           memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 32):
          raise ApiError("""%s.checkValid: unit:
           memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: unit:
           memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.split()) == 1)):
          raise ApiError("""%s.checkValid: unit:
           Word constraint contains_no_white_space violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('usedForCalculation')
      if (not (value in [True, False])):
        raise ApiError("""%s.checkValid: usedForCalculation:
         memops.Implementation.Boolean input is not in enumeration [True, False]""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('access')
      if (value is not None):
        from memops.api.AccessControl import AccessObject as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: access:
           value is not of class memops.AccessControl.AccessObject""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('dataObjects')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: access:
           non-reciprocal link DihedralConstraintList from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      value = dataDict.get('conditionState')
      if (value is not None):
        if (not isinstance(value, ConditionState)):
          raise ApiError("""%s.checkValid: conditionState:
           value is not of class ccp.nmr.NmrConstraint.ConditionState""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('constraintLists')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: conditionState:
           non-reciprocal link DihedralConstraintList from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('constraints').values()
      for value in values:
        if (not isinstance(value, DihedralConstraint)):
          raise ApiError("""%s.checkValid: constraints:
           value is not of class ccp.nmr.NmrConstraint.DihedralConstraint""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('parentList')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: constraints:
           non-reciprocal link DihedralConstraintList from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = self.getExperiments()
      for value in values:
        from ccp.api.nmr.Nmr import Experiment as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: experiments:
           value is not of class ccp.nmr.Nmr.Experiment""" % self.qualifiedName
           + ": %s" % (value,)
          )

        xx1 = dataDict.get('topObject')
        xx2 = xx1.__dict__.get('nmrProject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx2 is yy1)):
          raise ApiError("""%s.checkValid: experiments:
           Link experiments between objects from separate partitions
           - ccp.nmr.NmrConstraint.NmrConstraintStore.nmrProject not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = self.getMeasurementLists()
      for value in values:
        from ccp.api.nmr.Nmr import AbstractMeasurementList as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: measurementLists:
           value is not of class ccp.nmr.Nmr.AbstractMeasurementList""" % self.qualifiedName
           + ": %s" % (value,)
          )

        xx1 = dataDict.get('topObject')
        xx2 = xx1.__dict__.get('nmrProject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx2 is yy1)):
          raise ApiError("""%s.checkValid: measurementLists:
           Link measurementLists between objects from separate partitions
           - ccp.nmr.NmrConstraint.NmrConstraintStore.nmrProject not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      value = dataDict.get('method')
      if (value is not None):
        from ccp.api.general.Method import Method as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: method:
           value is not of class ccp.general.Method.Method""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('constraintLists')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: method:
           non-reciprocal link DihedralConstraintList from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('nmrConstraintListValidations')
      for value in values:
        from ccp.api.molecule.Validation import NmrConstraintListValidation as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: nmrConstraintListValidations:
           value is not of class ccp.molecule.Validation.NmrConstraintListValidation""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('nmrConstraintLists')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: nmrConstraintListValidations:
           non-reciprocal link DihedralConstraintList from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        yy2 = yy1.__dict__.get('nmrConstraintStore')
        if (not (xx1 is yy2)):
          raise ApiError("""%s.checkValid: nmrConstraintListValidations:
           Link nmrConstraintListValidations between objects from separate partitions
           - ccp.molecule.Validation.ValidationStore.nmrConstraintStore not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      value = dataDict.get('nmrConstraintStore')
      if (not isinstance(value, NmrConstraintStore)):
        raise ApiError("""%s.checkValid: nmrConstraintStore:
         value is not of class ccp.nmr.NmrConstraint.NmrConstraintStore""" % self.qualifiedName
         + ": %s" % (value,)
        )

      root = dataDict.get('topObject').__dict__.get('memopsRoot')
      root.refreshTopObjects('molsim.NmrSim')
      tobjList = root.__dict__.get('nmrSimStores').values()
      for tobj in tobjList:
        if (not (tobj.__dict__.get('isLoaded'))):
          tobj.load()

      values = dataDict.get('nmrSimEnergyTerms')
      for value in values:
        from molsim.api.NmrSim import NmrSimEnergyTerm as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: nmrSimEnergyTerms:
           value is not of class molsim.NmrSim.NmrSimEnergyTerm""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('constraintLists')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: nmrSimEnergyTerms:
           non-reciprocal link DihedralConstraintList from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

    # check explicit class constraints
    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('details')
    values = dataDict.get('experimentSerials')
    values = dataDict.get('measureListSerials')
    value = dataDict.get('name')
    value = dataDict.get('unit')
    value = dataDict.get('usedForCalculation')
    if (value is None):
      raise ApiError("""%s.checkValid: usedForCalculation:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    # check roles
    value = dataDict.get('access')
    value = dataDict.get('conditionState')
    values = dataDict.get('constraints').values()
    value = dataDict.get('method')
    values = dataDict.get('nmrConstraintListValidations')
    for value in values:
      ll= value.keywordDefinition.targetNames
      isValid = (not ll or self.qualifiedName in ll)
      if (not (isValid)):
        raise ApiError("""%s.checkValid: nmrConstraintListValidations:
         nmrConstraintListValidations constraint KeywordDefinition_fits_ConstraintList violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    value = dataDict.get('nmrConstraintStore')
    if (value is None):
      raise ApiError("""%s.checkValid: nmrConstraintStore:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    values = dataDict.get('nmrSimEnergyTerms')

  delete = memops.api.Implementation.DataObject.delete

  findAllApplicationData = memops.api.Implementation.DataObject.findAllApplicationData
  
  def findAllConstraints(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.DihedralConstraintList.constraints
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('constraints').values()
      result = set(currentValues)

    else:
      currentValues = dataDict.get('constraints').values()
      result = set()
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('details', 'origData', 'serial', 'weight', 'access', 'method', 'parentList',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result.add(v)

    return result

  findAllExperiments = AbstractConstraintList.findAllExperiments

  findAllMeasurementLists = AbstractConstraintList.findAllMeasurementLists

  findAllNmrConstraintListValidations = AbstractConstraintList.findAllNmrConstraintListValidations

  findAllNmrSimEnergyTerms = AbstractConstraintList.findAllNmrSimEnergyTerms

  findFirstApplicationData = memops.api.Implementation.DataObject.findFirstApplicationData
  
  def findFirstConstraint(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.DihedralConstraintList.constraints
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('constraints').values()
      if (currentValues):
        result = iter(currentValues).next()
      else:
        result = None

    else:
      objKey = conditions.get('serial')
      if (objKey is not None):
        result = dataDict.get('constraints').get(objKey)

        if (result is None):
          return result

        elif (len(conditions) <= 1):
          return result

        else:
          currentValues = set()
          currentValues.add(result)

      else:
        currentValues = dataDict.get('constraints').values()

      result = None
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('details', 'origData', 'serial', 'weight', 'access', 'method', 'parentList',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result = v; break

    return result

  findFirstExperiment = AbstractConstraintList.findFirstExperiment

  findFirstMeasurementList = AbstractConstraintList.findFirstMeasurementList

  findFirstNmrConstraintListValidation = AbstractConstraintList.findFirstNmrConstraintListValidation

  findFirstNmrSimEnergyTerm = AbstractConstraintList.findFirstNmrSimEnergyTerm
  
  def get(self, name):
    """
    GetAttr for ccp.nmr.NmrConstraint.DihedralConstraintList
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getAccess = memops.api.Implementation.DataObject.getAccess

  getApplicationData = memops.api.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.DihedralConstraintList
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (2 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.DihedralConstraintList'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (1 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.DihedralConstraintList'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-1]
      obj2 = obj1.__dict__.get('constraintLists').get(objKey)
      if (isinstance(obj2, DihedralConstraintList)):
        result = obj2

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = memops.api.Implementation.MemopsObject.getByNavigation

  getClassName = memops.api.Implementation.ComplexDataType.getClassName

  getConditionState = AbstractConstraintList.getConditionState
  
  def getConstraints(self):
    """
    Get for ccp.nmr.NmrConstraint.DihedralConstraintList.constraints
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('constraints').values()
    result = frozenset(tempVar)
    return result

  getDetails = AbstractConstraintList.getDetails

  getExpandedKey = memops.api.Implementation.MemopsObject.getExpandedKey

  getExperimentSerials = AbstractConstraintList.getExperimentSerials

  getExperiments = AbstractConstraintList.getExperiments

  getFieldNames = memops.api.Implementation.ComplexDataType.getFieldNames

  getFullKey = AbstractConstraintList.getFullKey

  getInConstructor = memops.api.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = memops.api.Implementation.MemopsObject.getIsDeleted

  getLocalKey = AbstractConstraintList.getLocalKey

  getMeasureListSerials = AbstractConstraintList.getMeasureListSerials

  getMeasurementLists = AbstractConstraintList.getMeasurementLists

  getMetaclass = memops.api.Implementation.ComplexDataType.getMetaclass

  getMethod = AbstractConstraintList.getMethod

  getName = AbstractConstraintList.getName

  getNmrConstraintListValidations = AbstractConstraintList.getNmrConstraintListValidations

  getNmrConstraintStore = AbstractConstraintList.getNmrConstraintStore

  getNmrSimEnergyTerms = AbstractConstraintList.getNmrSimEnergyTerms

  getPackageName = memops.api.Implementation.ComplexDataType.getPackageName

  getPackageShortName = memops.api.Implementation.ComplexDataType.getPackageShortName

  getParent = AbstractConstraintList.getParent

  getQualifiedName = memops.api.Implementation.ComplexDataType.getQualifiedName

  getRoot = memops.api.Implementation.MemopsObject.getRoot

  getSerial = AbstractConstraintList.getSerial

  getTopObject = memops.api.Implementation.DataObject.getTopObject

  getUnit = AbstractConstraintList.getUnit

  getUsedForCalculation = AbstractConstraintList.getUsedForCalculation
  
  def newDihedralConstraint(self, **attrlinks):
    """
    Factory function to create ccp.nmr.NmrConstraint.DihedralConstraint
    """
    return DihedralConstraint(self, **attrlinks)

  removeApplicationData = memops.api.Implementation.DataObject.removeApplicationData

  removeExperiment = AbstractConstraintList.removeExperiment

  removeExperimentSerial = AbstractConstraintList.removeExperimentSerial

  removeMeasureListSerial = AbstractConstraintList.removeMeasureListSerial

  removeMeasurementList = AbstractConstraintList.removeMeasurementList

  removeNmrConstraintListValidation = AbstractConstraintList.removeNmrConstraintListValidation

  removeNmrSimEnergyTerm = AbstractConstraintList.removeNmrSimEnergyTerm
  
  def set(self, name, value):
    """
    SetAttr for ccp.nmr.NmrConstraint.DihedralConstraintList
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setAccess = memops.api.Implementation.DataObject.setAccess

  setApplicationData = memops.api.Implementation.DataObject.setApplicationData

  setConditionState = AbstractConstraintList.setConditionState

  setDetails = AbstractConstraintList.setDetails

  setExperimentSerials = AbstractConstraintList.setExperimentSerials

  setExperiments = AbstractConstraintList.setExperiments

  setMeasureListSerials = AbstractConstraintList.setMeasureListSerials

  setMeasurementLists = AbstractConstraintList.setMeasurementLists

  setMethod = AbstractConstraintList.setMethod

  setName = AbstractConstraintList.setName

  setNmrConstraintListValidations = AbstractConstraintList.setNmrConstraintListValidations

  setNmrSimEnergyTerms = AbstractConstraintList.setNmrSimEnergyTerms

  setSerial = AbstractConstraintList.setSerial

  setUnit = AbstractConstraintList.setUnit

  setUsedForCalculation = AbstractConstraintList.setUsedForCalculation
  
  def sortedConstraints(self):
    """
    Sorted for ccp.nmr.NmrConstraint.DihedralConstraintList.constraints
    """
    dataDict = self.__dict__
    sortdd = dataDict.get('constraints')
    
    ll = sortdd.keys()
    ll.sort()
    result = [sortdd[x] for x in ll]
    return result

  sortedExperiments = AbstractConstraintList.sortedExperiments

  sortedMeasurementLists = AbstractConstraintList.sortedMeasurementLists

  sortedNmrConstraintListValidations = AbstractConstraintList.sortedNmrConstraintListValidations

  sortedNmrSimEnergyTerms = AbstractConstraintList.sortedNmrSimEnergyTerms

  toDetailedString = memops.api.Implementation.ComplexDataType.toDetailedString

  applicationData = memops.api.Implementation.DataObject.applicationData

  className = memops.api.Implementation.ComplexDataType.className

  details = AbstractConstraintList.details

  experimentSerials = AbstractConstraintList.experimentSerials

  fieldNames = memops.api.Implementation.ComplexDataType.fieldNames

  inConstructor = memops.api.Implementation.ComplexDataType.inConstructor

  isDeleted = memops.api.Implementation.MemopsObject.isDeleted

  measureListSerials = AbstractConstraintList.measureListSerials

  metaclass = memops.api.Implementation.ComplexDataType.metaclass

  name = AbstractConstraintList.name

  packageName = memops.api.Implementation.ComplexDataType.packageName

  packageShortName = memops.api.Implementation.ComplexDataType.packageShortName

  qualifiedName = memops.api.Implementation.ComplexDataType.qualifiedName

  serial = AbstractConstraintList.serial

  unit = AbstractConstraintList.unit

  usedForCalculation = AbstractConstraintList.usedForCalculation

  access = memops.api.Implementation.DataObject.access

  conditionState = AbstractConstraintList.conditionState
  
  constraints = property(getConstraints,  None, None,
  r"""child link to class DihedralConstraint
  """)

  experiments = AbstractConstraintList.experiments

  measurementLists = AbstractConstraintList.measurementLists

  method = AbstractConstraintList.method

  nmrConstraintListValidations = AbstractConstraintList.nmrConstraintListValidations

  nmrConstraintStore = AbstractConstraintList.nmrConstraintStore

  nmrSimEnergyTerms = AbstractConstraintList.nmrSimEnergyTerms

  parent = AbstractConstraintList.parent

  root = memops.api.Implementation.MemopsObject.root

  topObject = memops.api.Implementation.DataObject.topObject

###############################################################################
class ChemShiftConstraintList(AbstractConstraintList):
  r"""List of chemical shift constraints
  """
  #   from data model element ccp.nmr.NmrConstraint.ChemShiftConstraintList revision 1.41.2.9
  _metaclass = metaPackage.getElement('ChemShiftConstraintList')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('applicationData', 'className', 'details', 'experimentSerials', 'fieldNames', 'inConstructor', 'isDeleted', 'isotopeCode', 'measureListSerials', 'metaclass', 'name', 'packageName', 'packageShortName', 'qualifiedName', 'serial', 'unit', 'usedForCalculation', 'access', 'conditionState', 'constraints', 'experiments', 'isotope', 'measurementLists', 'method', 'nmrConstraintListValidations', 'nmrConstraintStore', 'nmrSimEnergyTerms', 'parent', 'root', 'topObject',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccp.nmr.NmrConstraint.ChemShiftConstraintList
    """
    dataDict = self.__dict__
    dataDict['nmrConstraintStore'] = parent
    if (not isinstance(parent, NmrConstraintStore)):
      raise ApiError("""%s.__init__:
       value is not of class ccp.nmr.NmrConstraint.NmrConstraintStore""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:
      if (not ((parent.__dict__.get('isLoaded') or parent.__dict__.get('isReading')))):
        parent.load()

      dataDict['applicationData'] = list()
      dataDict['details'] = None
      dataDict['experimentSerials'] = set()
      dataDict['isotopeCode'] = None
      dataDict['measureListSerials'] = set()
      dataDict['name'] = None
      dataDict['serial'] = None
      dataDict['unit'] = None
      dataDict['usedForCalculation'] = True
      dataDict['access'] = None
      dataDict['conditionState'] = None
      dataDict['constraints'] = {}
      dataDict['method'] = None
      dataDict['nmrConstraintListValidations'] = set()
      dataDict['nmrSimEnergyTerms'] = set()

      dataDict['inConstructor'] = True
      try:
        
        for key, value in attrlinks.iteritems():
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        del dataDict['inConstructor']
      except:
        print "ERROR in ccp.nmr.NmrConstraint.ChemShiftConstraintList.__init__"
        del dataDict['inConstructor']
        raise

      if (notOverride):
        if (dataDict.get('serial') is None):
          dataDict['inConstructor'] = True
          self.setSerial(-1)
          del dataDict['inConstructor']
        else:
          raise ApiError("""%s.__init__:
           Cannot pass in explicit serial if not reading""" % self.qualifiedName
           + ": %s:%s" % (parent, 'ccp.nmr.NmrConstraint.ChemShiftConstraintList')
          )

      serialDict = {}
      serialDict['constraints'] = 0
      dataDict['_serialDict'] = serialDict

      if (notIsReading):
        childrenDict = parent.__dict__.get('constraintLists')
        objKey = dataDict.get('serial')
        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['serial'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        print '''WARNING Error in clean-up of incorrectly created object. 
        Data may be left in an illegal state'''
        del dataDict['inConstructor']
      raise exc_info[0], exc_info[1], exc_info[2]

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccp.nmr.NmrConstraint.ChemShiftConstraintList:
       
    determines cascading deletes to follow from delete of object.
       
    *Implementation function* - should be called only by API delete 
    function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
      dataDict.get('topObject').load()

    access = dataDict.get('access')
    if (access is not None):
      topObject = access.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    constraints = dataDict.get('constraints').values()
    for constraint in constraints:
      if (not (constraint in objsToBeDeleted)):
        objsToBeDeleted.add(constraint)
        objsToBeChecked.append(constraint)

    method = dataDict.get('method')
    if (method is not None):
      topObject = method.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    nmrConstraintListValidations = dataDict.get('nmrConstraintListValidations')
    pass
    for nmrConstraintListValidation in nmrConstraintListValidations:
      topObject = nmrConstraintListValidation.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    root = dataDict.get('topObject').__dict__.get('memopsRoot')
    root.refreshTopObjects('molsim.NmrSim')
    tobjList = root.__dict__.get('nmrSimStores').values()
    for tobj in tobjList:
      if (not (tobj.__dict__.get('isLoaded'))):
        tobj.load()

    nmrSimEnergyTerms = dataDict.get('nmrSimEnergyTerms')
    pass
    for nmrSimEnergyTerm in nmrSimEnergyTerms:
      topObject = nmrSimEnergyTerm.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccp.nmr.NmrConstraint.ChemShiftConstraintList:
    deletes objects
    *Implementation function* - will CORRUPT DATA if called 
    outside the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    access = dataDict.get('access')
    if ((access is not None and not (access in objsToBeDeleted))):
      dataObjects = access.__dict__.get('dataObjects')
      dataObjects.remove(self)

    conditionState = dataDict.get('conditionState')
    if ((conditionState is not None and not (conditionState in objsToBeDeleted))):
      constraintLists = conditionState.__dict__.get('constraintLists')
      constraintLists.remove(self)

    method = dataDict.get('method')
    if ((method is not None and not (method in objsToBeDeleted))):
      constraintLists = method.__dict__.get('constraintLists')
      constraintLists.remove(self)

    for nmrConstraintListValidation in dataDict.get('nmrConstraintListValidations'):
      if (not (nmrConstraintListValidation in objsToBeDeleted)):
        nmrConstraintLists = nmrConstraintListValidation.__dict__.get('nmrConstraintLists')
        nmrConstraintLists.remove(self)

    for nmrSimEnergyTerm in dataDict.get('nmrSimEnergyTerms'):
      if (not (nmrSimEnergyTerm in objsToBeDeleted)):
        constraintLists = nmrSimEnergyTerm.__dict__.get('constraintLists')
        constraintLists.remove(self)

    nmrConstraintStore = dataDict.get('nmrConstraintStore')
    if (not (nmrConstraintStore in objsToBeDeleted)):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = nmrConstraintStore.__dict__.get('constraintLists')
        if (self is dd.get(objKey)):
          del dd[objKey]

  addApplicationData = memops.api.Implementation.DataObject.addApplicationData

  addExperiment = AbstractConstraintList.addExperiment

  addExperimentSerial = AbstractConstraintList.addExperimentSerial

  addMeasureListSerial = AbstractConstraintList.addMeasureListSerial

  addMeasurementList = AbstractConstraintList.addMeasurementList

  addNmrConstraintListValidation = AbstractConstraintList.addNmrConstraintListValidation

  addNmrSimEnergyTerm = AbstractConstraintList.addNmrSimEnergyTerm
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccp.nmr.NmrConstraint.ChemShiftConstraintList
    """
    dataDict = self.__dict__
    self.checkValid(complete)
    values = dataDict.get('constraints').values()
    for value in values:
      value.checkAllValid(complete)

  def checkValid(self, complete=False):
    """
    CheckValid for ccp.nmr.NmrConstraint.ChemShiftConstraintList
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('nmrConstraintStore')
        dd = value.__dict__.get('constraintLists')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'nmrConstraintStore' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from memops.api.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('details')
      if (value is not None):
        if (isinstance(value, memops.api.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: details:
           memops.Implementation.String input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      values = dataDict.get('experimentSerials')
      for value in values:
        if (isinstance(value, memops.api.Implementation.Int.PythonType)):
          pass
        elif ([x for x in memops.api.Implementation.Int.compatibleTypes if isinstance(value, x)]):
          castValue = memops.api.Implementation.Int.create(value)
          values.remove(value)
          if (castValue in values):
            values.add(value)
            raise ApiError("""%s.checkValid: experimentSerials:
             replacement value already in unique collection """ % self.qualifiedName
             + ": %s" % (castValue,)
            )
          else:
            values.add(castValue)

          value = castValue
        else:
          raise ApiError("""%s.checkValid: experimentSerials:
           memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('isotopeCode')
      if (value is not None):
        if (isinstance(value, memops.api.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: isotopeCode:
           memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 32):
          raise ApiError("""%s.checkValid: isotopeCode:
           memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: isotopeCode:
           memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.split()) == 1)):
          raise ApiError("""%s.checkValid: isotopeCode:
           Word constraint contains_no_white_space violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      values = dataDict.get('measureListSerials')
      for value in values:
        if (isinstance(value, memops.api.Implementation.Int.PythonType)):
          pass
        elif ([x for x in memops.api.Implementation.Int.compatibleTypes if isinstance(value, x)]):
          castValue = memops.api.Implementation.Int.create(value)
          values.remove(value)
          if (castValue in values):
            values.add(value)
            raise ApiError("""%s.checkValid: measureListSerials:
             replacement value already in unique collection """ % self.qualifiedName
             + ": %s" % (castValue,)
            )
          else:
            values.add(castValue)

          value = castValue
        else:
          raise ApiError("""%s.checkValid: measureListSerials:
           memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('name')
      if (value is not None):
        if (isinstance(value, memops.api.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: name:
           memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 80):
          raise ApiError("""%s.checkValid: name:
           memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: name:
           memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.splitlines()) <= 1)):
          raise ApiError("""%s.checkValid: name:
           Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, memops.api.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('serial')
      if (value is None):
        raise ApiError("""%s.checkValid: serial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, memops.api.Implementation.Int.PythonType)):
        pass
      elif ([x for x in memops.api.Implementation.Int.compatibleTypes if isinstance(value, x)]):
        value = memops.api.Implementation.Int.create(value)
      else:
        raise ApiError("""%s.checkValid: serial:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('unit')
      if (value is not None):
        if (isinstance(value, memops.api.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: unit:
           memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 32):
          raise ApiError("""%s.checkValid: unit:
           memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: unit:
           memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (len(value.split()) == 1)):
          raise ApiError("""%s.checkValid: unit:
           Word constraint contains_no_white_space violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('usedForCalculation')
      if (not (value in [True, False])):
        raise ApiError("""%s.checkValid: usedForCalculation:
         memops.Implementation.Boolean input is not in enumeration [True, False]""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('access')
      if (value is not None):
        from memops.api.AccessControl import AccessObject as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: access:
           value is not of class memops.AccessControl.AccessObject""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('dataObjects')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: access:
           non-reciprocal link ChemShiftConstraintList from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      value = dataDict.get('conditionState')
      if (value is not None):
        if (not isinstance(value, ConditionState)):
          raise ApiError("""%s.checkValid: conditionState:
           value is not of class ccp.nmr.NmrConstraint.ConditionState""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('constraintLists')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: conditionState:
           non-reciprocal link ChemShiftConstraintList from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('constraints').values()
      for value in values:
        if (not isinstance(value, ChemShiftConstraint)):
          raise ApiError("""%s.checkValid: constraints:
           value is not of class ccp.nmr.NmrConstraint.ChemShiftConstraint""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('parentList')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: constraints:
           non-reciprocal link ChemShiftConstraintList from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = self.getExperiments()
      for value in values:
        from ccp.api.nmr.Nmr import Experiment as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: experiments:
           value is not of class ccp.nmr.Nmr.Experiment""" % self.qualifiedName
           + ": %s" % (value,)
          )

        xx1 = dataDict.get('topObject')
        xx2 = xx1.__dict__.get('nmrProject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx2 is yy1)):
          raise ApiError("""%s.checkValid: experiments:
           Link experiments between objects from separate partitions
           - ccp.nmr.NmrConstraint.NmrConstraintStore.nmrProject not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      value = self.getIsotope()
      if (value is None):
        raise ApiError("""%s.checkValid: isotope:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      from ccp.api.molecule.ChemElement import Isotope as importedType
      if (not isinstance(value, importedType)):
        raise ApiError("""%s.checkValid: isotope:
         value is not of class ccp.molecule.ChemElement.Isotope""" % self.qualifiedName
         + ": %s" % (value,)
        )

      xx1 = dataDict.get('topObject').__dict__.get('memopsRoot')
      yy1 = value.__dict__.get('topObject').__dict__.get('memopsRoot')
      if (not (xx1 is yy1)):
        raise ApiError("""%s.checkValid: isotope:
         Link isotope between objects from separate partitions
         - memops.Implementation.MemopsRoot does not match""" % self.qualifiedName
         + ": %s:%s" % (self, value)
        )

      values = self.getMeasurementLists()
      for value in values:
        from ccp.api.nmr.Nmr import AbstractMeasurementList as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: measurementLists:
           value is not of class ccp.nmr.Nmr.AbstractMeasurementList""" % self.qualifiedName
           + ": %s" % (value,)
          )

        xx1 = dataDict.get('topObject')
        xx2 = xx1.__dict__.get('nmrProject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx2 is yy1)):
          raise ApiError("""%s.checkValid: measurementLists:
           Link measurementLists between objects from separate partitions
           - ccp.nmr.NmrConstraint.NmrConstraintStore.nmrProject not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      value = dataDict.get('method')
      if (value is not None):
        from ccp.api.general.Method import Method as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: method:
           value is not of class ccp.general.Method.Method""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('constraintLists')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: method:
           non-reciprocal link ChemShiftConstraintList from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('nmrConstraintListValidations')
      for value in values:
        from ccp.api.molecule.Validation import NmrConstraintListValidation as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: nmrConstraintListValidations:
           value is not of class ccp.molecule.Validation.NmrConstraintListValidation""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('nmrConstraintLists')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: nmrConstraintListValidations:
           non-reciprocal link ChemShiftConstraintList from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        yy2 = yy1.__dict__.get('nmrConstraintStore')
        if (not (xx1 is yy2)):
          raise ApiError("""%s.checkValid: nmrConstraintListValidations:
           Link nmrConstraintListValidations between objects from separate partitions
           - ccp.molecule.Validation.ValidationStore.nmrConstraintStore not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      value = dataDict.get('nmrConstraintStore')
      if (not isinstance(value, NmrConstraintStore)):
        raise ApiError("""%s.checkValid: nmrConstraintStore:
         value is not of class ccp.nmr.NmrConstraint.NmrConstraintStore""" % self.qualifiedName
         + ": %s" % (value,)
        )

      root = dataDict.get('topObject').__dict__.get('memopsRoot')
      root.refreshTopObjects('molsim.NmrSim')
      tobjList = root.__dict__.get('nmrSimStores').values()
      for tobj in tobjList:
        if (not (tobj.__dict__.get('isLoaded'))):
          tobj.load()

      values = dataDict.get('nmrSimEnergyTerms')
      for value in values:
        from molsim.api.NmrSim import NmrSimEnergyTerm as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: nmrSimEnergyTerms:
           value is not of class molsim.NmrSim.NmrSimEnergyTerm""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('constraintLists')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: nmrSimEnergyTerms:
           non-reciprocal link ChemShiftConstraintList from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

    # check explicit class constraints
    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('details')
    values = dataDict.get('experimentSerials')
    value = dataDict.get('isotopeCode')
    values = dataDict.get('measureListSerials')
    value = dataDict.get('name')
    value = dataDict.get('unit')
    value = dataDict.get('usedForCalculation')
    if (value is None):
      raise ApiError("""%s.checkValid: usedForCalculation:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    # check roles
    value = dataDict.get('access')
    value = dataDict.get('conditionState')
    values = dataDict.get('constraints').values()
    value = dataDict.get('method')
    values = dataDict.get('nmrConstraintListValidations')
    for value in values:
      ll= value.keywordDefinition.targetNames
      isValid = (not ll or self.qualifiedName in ll)
      if (not (isValid)):
        raise ApiError("""%s.checkValid: nmrConstraintListValidations:
         nmrConstraintListValidations constraint KeywordDefinition_fits_ConstraintList violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    value = dataDict.get('nmrConstraintStore')
    if (value is None):
      raise ApiError("""%s.checkValid: nmrConstraintStore:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    values = dataDict.get('nmrSimEnergyTerms')

  delete = memops.api.Implementation.DataObject.delete

  findAllApplicationData = memops.api.Implementation.DataObject.findAllApplicationData
  
  def findAllConstraints(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.ChemShiftConstraintList.constraints
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('constraints').values()
      result = set(currentValues)

    else:
      currentValues = dataDict.get('constraints').values()
      result = set()
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('details', 'error', 'lowerLimit', 'origData', 'serial', 'targetValue', 'upperLimit', 'weight', 'access', 'method', 'parentList', 'resonance',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result.add(v)

    return result

  findAllExperiments = AbstractConstraintList.findAllExperiments

  findAllMeasurementLists = AbstractConstraintList.findAllMeasurementLists

  findAllNmrConstraintListValidations = AbstractConstraintList.findAllNmrConstraintListValidations

  findAllNmrSimEnergyTerms = AbstractConstraintList.findAllNmrSimEnergyTerms

  findFirstApplicationData = memops.api.Implementation.DataObject.findFirstApplicationData
  
  def findFirstConstraint(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.ChemShiftConstraintList.constraints
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('constraints').values()
      if (currentValues):
        result = iter(currentValues).next()
      else:
        result = None

    else:
      objKey = conditions.get('serial')
      if (objKey is not None):
        result = dataDict.get('constraints').get(objKey)

        if (result is None):
          return result

        elif (len(conditions) <= 1):
          return result

        else:
          currentValues = set()
          currentValues.add(result)

      else:
        currentValues = dataDict.get('constraints').values()

      result = None
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('details', 'error', 'lowerLimit', 'origData', 'serial', 'targetValue', 'upperLimit', 'weight', 'access', 'method', 'parentList', 'resonance',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result = v; break

    return result

  findFirstExperiment = AbstractConstraintList.findFirstExperiment

  findFirstMeasurementList = AbstractConstraintList.findFirstMeasurementList

  findFirstNmrConstraintListValidation = AbstractConstraintList.findFirstNmrConstraintListValidation

  findFirstNmrSimEnergyTerm = AbstractConstraintList.findFirstNmrSimEnergyTerm
  
  def get(self, name):
    """
    GetAttr for ccp.nmr.NmrConstraint.ChemShiftConstraintList
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getAccess = memops.api.Implementation.DataObject.getAccess

  getApplicationData = memops.api.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.ChemShiftConstraintList
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (2 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.ChemShiftConstraintList'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (1 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.ChemShiftConstraintList'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-1]
      obj2 = obj1.__dict__.get('constraintLists').get(objKey)
      if (isinstance(obj2, ChemShiftConstraintList)):
        result = obj2

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = memops.api.Implementation.MemopsObject.getByNavigation

  getClassName = memops.api.Implementation.ComplexDataType.getClassName

  getConditionState = AbstractConstraintList.getConditionState
  
  def getConstraints(self):
    """
    Get for ccp.nmr.NmrConstraint.ChemShiftConstraintList.constraints
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('constraints').values()
    result = frozenset(tempVar)
    return result

  getDetails = AbstractConstraintList.getDetails

  getExpandedKey = memops.api.Implementation.MemopsObject.getExpandedKey

  getExperimentSerials = AbstractConstraintList.getExperimentSerials

  getExperiments = AbstractConstraintList.getExperiments

  getFieldNames = memops.api.Implementation.ComplexDataType.getFieldNames

  getFullKey = AbstractConstraintList.getFullKey

  getInConstructor = memops.api.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = memops.api.Implementation.MemopsObject.getIsDeleted
  
  def getIsotope(self):
    """
    getfunction for derived link Isotope
    """
    dataDict = self.__dict__
    ss = self.isotopeCode
    if ss is None:
      result = None
    else:
      if ss[-2] in '0123456789':
        firstLetter = -1
      else:
        firstLetter = -2
      atomSymbol = ss[firstLetter:].capitalize()
      massNumber = int(ss[:firstLetter])
    
      result = ccp.api.molecule.ChemElement.Isotope.getByKey(self.root.currentChemElementStore, (atomSymbol, massNumber))
    return result
  
  def getIsotopeCode(self):
    """
    Get for ccp.nmr.NmrConstraint.ChemShiftConstraintList.isotopeCode
    """
    dataDict = self.__dict__
    result = dataDict.get('isotopeCode')
    return result

  getLocalKey = AbstractConstraintList.getLocalKey

  getMeasureListSerials = AbstractConstraintList.getMeasureListSerials

  getMeasurementLists = AbstractConstraintList.getMeasurementLists

  getMetaclass = memops.api.Implementation.ComplexDataType.getMetaclass

  getMethod = AbstractConstraintList.getMethod

  getName = AbstractConstraintList.getName

  getNmrConstraintListValidations = AbstractConstraintList.getNmrConstraintListValidations

  getNmrConstraintStore = AbstractConstraintList.getNmrConstraintStore

  getNmrSimEnergyTerms = AbstractConstraintList.getNmrSimEnergyTerms

  getPackageName = memops.api.Implementation.ComplexDataType.getPackageName

  getPackageShortName = memops.api.Implementation.ComplexDataType.getPackageShortName

  getParent = AbstractConstraintList.getParent

  getQualifiedName = memops.api.Implementation.ComplexDataType.getQualifiedName

  getRoot = memops.api.Implementation.MemopsObject.getRoot

  getSerial = AbstractConstraintList.getSerial

  getTopObject = memops.api.Implementation.DataObject.getTopObject

  getUnit = AbstractConstraintList.getUnit

  getUsedForCalculation = AbstractConstraintList.getUsedForCalculation
  
  def newChemShiftConstraint(self, **attrlinks):
    """
    Factory function to create ccp.nmr.NmrConstraint.ChemShiftConstraint
    """
    return ChemShiftConstraint(self, **attrlinks)

  removeApplicationData = memops.api.Implementation.DataObject.removeApplicationData

  removeExperiment = AbstractConstraintList.removeExperiment

  removeExperimentSerial = AbstractConstraintList.removeExperimentSerial

  removeMeasureListSerial = AbstractConstraintList.removeMeasureListSerial

  removeMeasurementList = AbstractConstraintList.removeMeasurementList

  removeNmrConstraintListValidation = AbstractConstraintList.removeNmrConstraintListValidation

  removeNmrSimEnergyTerm = AbstractConstraintList.removeNmrSimEnergyTerm
  
  def set(self, name, value):
    """
    SetAttr for ccp.nmr.NmrConstraint.ChemShiftConstraintList
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setAccess = memops.api.Implementation.DataObject.setAccess

  setApplicationData = memops.api.Implementation.DataObject.setApplicationData

  setConditionState = AbstractConstraintList.setConditionState

  setDetails = AbstractConstraintList.setDetails

  setExperimentSerials = AbstractConstraintList.setExperimentSerials

  setExperiments = AbstractConstraintList.setExperiments
  
  def setIsotopeCode(self, value):
    """
    Set for ccp.nmr.NmrConstraint.ChemShiftConstraintList.isotopeCode
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, memops.api.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.setIsotopeCode:
         memops.Implementation.Word input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 32):
        raise ApiError("""%s.setIsotopeCode:
         memops.Implementation.Word maximum length is 32 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.setIsotopeCode:
         memops.Implementation.Word: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.split()) == 1)):
        raise ApiError("""%s.setIsotopeCode:
         Word constraint contains_no_white_space violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('isotopeCode')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setIsotopeCode:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setIsotopeCode:
       called on deleted object""" % self.qualifiedName
      )

    if (value == currentValue):
      return

    if (notOverride):
      pass

    dataDict['isotopeCode'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setIsotopeCode')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  setMeasureListSerials = AbstractConstraintList.setMeasureListSerials

  setMeasurementLists = AbstractConstraintList.setMeasurementLists

  setMethod = AbstractConstraintList.setMethod

  setName = AbstractConstraintList.setName

  setNmrConstraintListValidations = AbstractConstraintList.setNmrConstraintListValidations

  setNmrSimEnergyTerms = AbstractConstraintList.setNmrSimEnergyTerms

  setSerial = AbstractConstraintList.setSerial

  setUnit = AbstractConstraintList.setUnit

  setUsedForCalculation = AbstractConstraintList.setUsedForCalculation
  
  def sortedConstraints(self):
    """
    Sorted for ccp.nmr.NmrConstraint.ChemShiftConstraintList.constraints
    """
    dataDict = self.__dict__
    sortdd = dataDict.get('constraints')
    
    ll = sortdd.keys()
    ll.sort()
    result = [sortdd[x] for x in ll]
    return result

  sortedExperiments = AbstractConstraintList.sortedExperiments

  sortedMeasurementLists = AbstractConstraintList.sortedMeasurementLists

  sortedNmrConstraintListValidations = AbstractConstraintList.sortedNmrConstraintListValidations

  sortedNmrSimEnergyTerms = AbstractConstraintList.sortedNmrSimEnergyTerms

  toDetailedString = memops.api.Implementation.ComplexDataType.toDetailedString

  applicationData = memops.api.Implementation.DataObject.applicationData

  className = memops.api.Implementation.ComplexDataType.className

  details = AbstractConstraintList.details

  experimentSerials = AbstractConstraintList.experimentSerials

  fieldNames = memops.api.Implementation.ComplexDataType.fieldNames

  inConstructor = memops.api.Implementation.ComplexDataType.inConstructor

  isDeleted = memops.api.Implementation.MemopsObject.isDeleted
  
  isotopeCode = property(getIsotopeCode, setIsotopeCode, None,
  r"""String indicating Isotope (e.g. 13C, 3He, 2H, 235U  ...) to which all 
  chemical shifts in list should belong
  """)

  measureListSerials = AbstractConstraintList.measureListSerials

  metaclass = memops.api.Implementation.ComplexDataType.metaclass

  name = AbstractConstraintList.name

  packageName = memops.api.Implementation.ComplexDataType.packageName

  packageShortName = memops.api.Implementation.ComplexDataType.packageShortName

  qualifiedName = memops.api.Implementation.ComplexDataType.qualifiedName

  serial = AbstractConstraintList.serial

  unit = AbstractConstraintList.unit

  usedForCalculation = AbstractConstraintList.usedForCalculation

  access = memops.api.Implementation.DataObject.access

  conditionState = AbstractConstraintList.conditionState
  
  constraints = property(getConstraints,  None, None,
  r"""child link to class ChemShiftConstraint
  """)

  experiments = AbstractConstraintList.experiments
  
  isotope = property(getIsotope, None, None,
  r"""Isotope for Constraints in Chemical Shift Constraint List
  """)

  measurementLists = AbstractConstraintList.measurementLists

  method = AbstractConstraintList.method

  nmrConstraintListValidations = AbstractConstraintList.nmrConstraintListValidations

  nmrConstraintStore = AbstractConstraintList.nmrConstraintStore

  nmrSimEnergyTerms = AbstractConstraintList.nmrSimEnergyTerms

  parent = AbstractConstraintList.parent

  root = memops.api.Implementation.MemopsObject.root

  topObject = memops.api.Implementation.DataObject.topObject

###############################################################################
class RdcConstraintItem(PairwiseConstraintItem):
  r"""Pair of Resonances involved in a reduced dipolarcoupling restraint
  """
  #   from data model element ccp.nmr.NmrConstraint.RdcConstraintItem revision 1.37.2.9
  _metaclass = metaPackage.getElement('RdcConstraintItem')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('applicationData', 'className', 'fieldNames', 'inConstructor', 'isDeleted', 'metaclass', 'packageName', 'packageShortName', 'qualifiedName', 'access', 'constraint', 'firstResonance', 'orderedResonances', 'parent', 'resonances', 'root', 'topObject',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccp.nmr.NmrConstraint.RdcConstraintItem
    """
    dataDict = self.__dict__
    dataDict['constraint'] = parent
    if (not isinstance(parent, RdcConstraint)):
      raise ApiError("""%s.__init__:
       value is not of class ccp.nmr.NmrConstraint.RdcConstraint""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:

      dataDict['applicationData'] = list()
      dataDict['access'] = None
      dataDict['firstResonance'] = None
      dataDict['resonances'] = set()

      dataDict['inConstructor'] = True
      try:
        
        for key, value in attrlinks.iteritems():
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        del dataDict['inConstructor']
      except:
        print "ERROR in ccp.nmr.NmrConstraint.RdcConstraintItem.__init__"
        del dataDict['inConstructor']
        raise

      if (notIsReading):
        childrenDict = parent.__dict__.get('items')
        objKey = dataDict.get('resonances')
        if (objKey is not None):
          objKey = frozenset(objKey)

        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['resonances'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        print '''WARNING Error in clean-up of incorrectly created object. 
        Data may be left in an illegal state'''
        del dataDict['inConstructor']
      raise exc_info[0], exc_info[1], exc_info[2]

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccp.nmr.NmrConstraint.RdcConstraintItem:
       determines 
    cascading deletes to follow from delete of object.
       *Implementation 
    function* - should be called only by API delete function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
      dataDict.get('topObject').load()

    access = dataDict.get('access')
    if (access is not None):
      topObject = access.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccp.nmr.NmrConstraint.RdcConstraintItem:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    access = dataDict.get('access')
    if ((access is not None and not (access in objsToBeDeleted))):
      dataObjects = access.__dict__.get('dataObjects')
      dataObjects.remove(self)

    for resonance in dataDict.get('resonances'):
      if (not (resonance in objsToBeDeleted)):
        pairwiseConstraintItems = resonance.__dict__.get('pairwiseConstraintItems')
        pairwiseConstraintItems.remove(self)

    constraint = dataDict.get('constraint')
    if (not (constraint in objsToBeDeleted)):
      objKey = dataDict.get('resonances')
      if (objKey is not None):
        objKey = frozenset(objKey)

      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = constraint.__dict__.get('items')
        if (self is dd.get(objKey)):
          del dd[objKey]

  addApplicationData = memops.api.Implementation.DataObject.addApplicationData

  addOrderedResonance = PairwiseConstraintItem.addOrderedResonance
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccp.nmr.NmrConstraint.RdcConstraintItem
    """
    dataDict = self.__dict__
    self.checkValid(complete)
  
  def checkValid(self, complete=False):
    """
    CheckValid for ccp.nmr.NmrConstraint.RdcConstraintItem
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('resonances')
      if (objKey is not None):
        objKey = frozenset(objKey)

      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('constraint')
        dd = value.__dict__.get('items')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'constraint' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from memops.api.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, memops.api.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('access')
      if (value is not None):
        from memops.api.AccessControl import AccessObject as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: access:
           value is not of class memops.AccessControl.AccessObject""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('dataObjects')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: access:
           non-reciprocal link RdcConstraintItem from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      value = dataDict.get('constraint')
      if (not isinstance(value, RdcConstraint)):
        raise ApiError("""%s.checkValid: constraint:
         value is not of class ccp.nmr.NmrConstraint.RdcConstraint""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('firstResonance')
      if (value is not None):
        if (not isinstance(value, FixedResonance)):
          raise ApiError("""%s.checkValid: firstResonance:
           value is not of class ccp.nmr.NmrConstraint.FixedResonance""" % self.qualifiedName
           + ": %s" % (value,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: firstResonance:
           Link firstResonance between objects from separate partitions
           - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = self.getOrderedResonances()
      if (len(values) > 2):
        raise ApiError("""%s.checkValid: orderedResonances:
         hicard: values must be of length <= 2""" % self.qualifiedName
         + ": %s" % (self,)
        )

      for value in values:
        if (not isinstance(value, FixedResonance)):
          raise ApiError("""%s.checkValid: orderedResonances:
           value is not of class ccp.nmr.NmrConstraint.FixedResonance""" % self.qualifiedName
           + ": %s" % (value,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: orderedResonances:
           Link orderedResonances between objects from separate partitions
           - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = dataDict.get('resonances')
      for value in values:
        if (not isinstance(value, FixedResonance)):
          raise ApiError("""%s.checkValid: resonances:
           value is not of class ccp.nmr.NmrConstraint.FixedResonance""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('pairwiseConstraintItems')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: resonances:
           non-reciprocal link RdcConstraintItem from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

    # check explicit class constraints
    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    # check roles
    value = dataDict.get('access')
    value = dataDict.get('constraint')
    if (value is None):
      raise ApiError("""%s.checkValid: constraint:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    value = dataDict.get('firstResonance')
    if (value is not None):
      if (not (value in self.resonances)):
        raise ApiError("""%s.checkValid: firstResonance:
         firstResonance constraint FirstResonance_must_be_in_resonances violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    values = dataDict.get('resonances')
    if (not (len(values) == 2)):
      raise ApiError("""%s.checkValid: resonances:
       locard, hicard: values must be of length == 2""" % self.qualifiedName
       + ": %s" % (self,)
      )

  delete = memops.api.Implementation.DataObject.delete

  findAllApplicationData = memops.api.Implementation.DataObject.findAllApplicationData

  findAllOrderedResonances = PairwiseConstraintItem.findAllOrderedResonances

  findAllResonances = PairwiseConstraintItem.findAllResonances

  findFirstApplicationData = memops.api.Implementation.DataObject.findFirstApplicationData

  findFirstOrderedResonance = PairwiseConstraintItem.findFirstOrderedResonance

  findFirstResonance = PairwiseConstraintItem.findFirstResonance
  
  def get(self, name):
    """
    GetAttr for ccp.nmr.NmrConstraint.RdcConstraintItem
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getAccess = memops.api.Implementation.DataObject.getAccess

  getApplicationData = memops.api.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.RdcConstraintItem
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (5 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.RdcConstraintItem'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (4 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.RdcConstraintItem'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-4]
      obj2 = obj1.__dict__.get('constraintLists').get(objKey)

      if (obj2 is not None):
        objKey = fullKey[-3]
        obj3 = obj2.__dict__.get('constraints').get(objKey)

        if (obj3 is not None):
          tempList = list()
          tempList.append(fullKey[-2])
          tempList.append(fullKey[-1])
          objKey = frozenset(tempList)
          obj4 = obj3.__dict__.get('items').get(objKey)
          result = obj4

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = memops.api.Implementation.MemopsObject.getByNavigation

  getClassName = memops.api.Implementation.ComplexDataType.getClassName
  
  def getConstraint(self):
    """
    Get for ccp.nmr.NmrConstraint.RdcConstraintItem.constraint
    """
    dataDict = self.__dict__
    result = dataDict.get('constraint')
    return result

  getExpandedKey = memops.api.Implementation.MemopsObject.getExpandedKey

  getFieldNames = memops.api.Implementation.ComplexDataType.getFieldNames

  getFirstResonance = PairwiseConstraintItem.getFirstResonance
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccp.nmr.NmrConstraint.RdcConstraintItem
    """
    dataDict = self.__dict__
    result = list()

    obj3 = dataDict.get('constraint')
    obj2 = obj3.__dict__.get('parentList')
    obj1 = obj2.__dict__.get('nmrConstraintStore')

    if (useGuid):
      result.append(obj1.__dict__.get('guid'))
    else:
      result.append(obj1.__dict__.get('serial'))

    result.append(obj2.__dict__.get('serial'))
    result.append(obj3.__dict__.get('serial'))
    for xx in dataDict.get('resonances'):
      result.append(xx)

    return result

  getInConstructor = memops.api.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = memops.api.Implementation.MemopsObject.getIsDeleted
  
  def getLocalKey(self):
    """
    GetLocalKey for ccp.nmr.NmrConstraint.RdcConstraintItem
    """
    dataDict = self.__dict__
    result = dataDict.get('resonances')
    if (result is not None):
      result = frozenset(result)

    return result

  getMetaclass = memops.api.Implementation.ComplexDataType.getMetaclass

  getOrderedResonances = PairwiseConstraintItem.getOrderedResonances

  getPackageName = memops.api.Implementation.ComplexDataType.getPackageName

  getPackageShortName = memops.api.Implementation.ComplexDataType.getPackageShortName
  
  def getParent(self):
    """
    Get for ccp.nmr.NmrConstraint.RdcConstraintItem.parent
    """
    dataDict = self.__dict__
    result = dataDict.get('constraint')
    return result

  getQualifiedName = memops.api.Implementation.ComplexDataType.getQualifiedName

  getResonances = PairwiseConstraintItem.getResonances

  getRoot = memops.api.Implementation.MemopsObject.getRoot

  getTopObject = memops.api.Implementation.DataObject.getTopObject

  removeApplicationData = memops.api.Implementation.DataObject.removeApplicationData

  removeOrderedResonance = PairwiseConstraintItem.removeOrderedResonance
  
  def set(self, name, value):
    """
    SetAttr for ccp.nmr.NmrConstraint.RdcConstraintItem
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setAccess = memops.api.Implementation.DataObject.setAccess

  setApplicationData = memops.api.Implementation.DataObject.setApplicationData

  setFirstResonance = PairwiseConstraintItem.setFirstResonance

  setOrderedResonances = PairwiseConstraintItem.setOrderedResonances

  setResonances = PairwiseConstraintItem.setResonances

  sortedResonances = PairwiseConstraintItem.sortedResonances

  toDetailedString = memops.api.Implementation.ComplexDataType.toDetailedString

  applicationData = memops.api.Implementation.DataObject.applicationData

  className = memops.api.Implementation.ComplexDataType.className

  fieldNames = memops.api.Implementation.ComplexDataType.fieldNames

  inConstructor = memops.api.Implementation.ComplexDataType.inConstructor

  isDeleted = memops.api.Implementation.MemopsObject.isDeleted

  metaclass = memops.api.Implementation.ComplexDataType.metaclass

  packageName = memops.api.Implementation.ComplexDataType.packageName

  packageShortName = memops.api.Implementation.ComplexDataType.packageShortName

  qualifiedName = memops.api.Implementation.ComplexDataType.qualifiedName

  access = memops.api.Implementation.DataObject.access
  
  constraint = property(getConstraint,  None, None,
  r"""parent link
  """)

  firstResonance = PairwiseConstraintItem.firstResonance

  orderedResonances = PairwiseConstraintItem.orderedResonances
  
  parent = property(getParent, None, None,
  r"""link to parent object - synonym for constraint
  """)

  resonances = PairwiseConstraintItem.resonances

  root = memops.api.Implementation.MemopsObject.root

  topObject = memops.api.Implementation.DataObject.topObject

###############################################################################
class HBondConstraintItem(PairwiseConstraintItem):
  r"""Pair of Resonances involved in a hydrogen bond restraint.
The two 
Resonances pointed to are given in the order 1) Hydrogen, 2) Hydrogen 
acceptor
  """
  #   from data model element ccp.nmr.NmrConstraint.HBondConstraintItem revision 1.37.2.9
  _metaclass = metaPackage.getElement('HBondConstraintItem')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('applicationData', 'className', 'fieldNames', 'inConstructor', 'isDeleted', 'metaclass', 'packageName', 'packageShortName', 'qualifiedName', 'access', 'constraint', 'firstResonance', 'orderedResonances', 'parent', 'resonances', 'root', 'topObject',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccp.nmr.NmrConstraint.HBondConstraintItem
    """
    dataDict = self.__dict__
    dataDict['constraint'] = parent
    if (not isinstance(parent, HBondConstraint)):
      raise ApiError("""%s.__init__:
       value is not of class ccp.nmr.NmrConstraint.HBondConstraint""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:

      dataDict['applicationData'] = list()
      dataDict['access'] = None
      dataDict['firstResonance'] = None
      dataDict['resonances'] = set()

      dataDict['inConstructor'] = True
      try:
        
        for key, value in attrlinks.iteritems():
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        del dataDict['inConstructor']
      except:
        print "ERROR in ccp.nmr.NmrConstraint.HBondConstraintItem.__init__"
        del dataDict['inConstructor']
        raise

      if (notIsReading):
        childrenDict = parent.__dict__.get('items')
        objKey = dataDict.get('resonances')
        if (objKey is not None):
          objKey = frozenset(objKey)

        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['resonances'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        print '''WARNING Error in clean-up of incorrectly created object. 
        Data may be left in an illegal state'''
        del dataDict['inConstructor']
      raise exc_info[0], exc_info[1], exc_info[2]

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccp.nmr.NmrConstraint.HBondConstraintItem:
       determines 
    cascading deletes to follow from delete of object.
       *Implementation 
    function* - should be called only by API delete function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
      dataDict.get('topObject').load()

    access = dataDict.get('access')
    if (access is not None):
      topObject = access.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccp.nmr.NmrConstraint.HBondConstraintItem:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    access = dataDict.get('access')
    if ((access is not None and not (access in objsToBeDeleted))):
      dataObjects = access.__dict__.get('dataObjects')
      dataObjects.remove(self)

    for resonance in dataDict.get('resonances'):
      if (not (resonance in objsToBeDeleted)):
        pairwiseConstraintItems = resonance.__dict__.get('pairwiseConstraintItems')
        pairwiseConstraintItems.remove(self)

    constraint = dataDict.get('constraint')
    if (not (constraint in objsToBeDeleted)):
      objKey = dataDict.get('resonances')
      if (objKey is not None):
        objKey = frozenset(objKey)

      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = constraint.__dict__.get('items')
        if (self is dd.get(objKey)):
          del dd[objKey]

  addApplicationData = memops.api.Implementation.DataObject.addApplicationData

  addOrderedResonance = PairwiseConstraintItem.addOrderedResonance
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccp.nmr.NmrConstraint.HBondConstraintItem
    """
    dataDict = self.__dict__
    self.checkValid(complete)
  
  def checkValid(self, complete=False):
    """
    CheckValid for ccp.nmr.NmrConstraint.HBondConstraintItem
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('resonances')
      if (objKey is not None):
        objKey = frozenset(objKey)

      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('constraint')
        dd = value.__dict__.get('items')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'constraint' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from memops.api.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, memops.api.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('access')
      if (value is not None):
        from memops.api.AccessControl import AccessObject as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: access:
           value is not of class memops.AccessControl.AccessObject""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('dataObjects')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: access:
           non-reciprocal link HBondConstraintItem from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      value = dataDict.get('constraint')
      if (not isinstance(value, HBondConstraint)):
        raise ApiError("""%s.checkValid: constraint:
         value is not of class ccp.nmr.NmrConstraint.HBondConstraint""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('firstResonance')
      if (value is not None):
        if (not isinstance(value, FixedResonance)):
          raise ApiError("""%s.checkValid: firstResonance:
           value is not of class ccp.nmr.NmrConstraint.FixedResonance""" % self.qualifiedName
           + ": %s" % (value,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: firstResonance:
           Link firstResonance between objects from separate partitions
           - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = self.getOrderedResonances()
      if (len(values) > 2):
        raise ApiError("""%s.checkValid: orderedResonances:
         hicard: values must be of length <= 2""" % self.qualifiedName
         + ": %s" % (self,)
        )

      for value in values:
        if (not isinstance(value, FixedResonance)):
          raise ApiError("""%s.checkValid: orderedResonances:
           value is not of class ccp.nmr.NmrConstraint.FixedResonance""" % self.qualifiedName
           + ": %s" % (value,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: orderedResonances:
           Link orderedResonances between objects from separate partitions
           - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = dataDict.get('resonances')
      for value in values:
        if (not isinstance(value, FixedResonance)):
          raise ApiError("""%s.checkValid: resonances:
           value is not of class ccp.nmr.NmrConstraint.FixedResonance""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('pairwiseConstraintItems')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: resonances:
           non-reciprocal link HBondConstraintItem from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

    # check explicit class constraints
    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    # check roles
    value = dataDict.get('access')
    value = dataDict.get('constraint')
    if (value is None):
      raise ApiError("""%s.checkValid: constraint:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    value = dataDict.get('firstResonance')
    if (value is not None):
      if (not (value in self.resonances)):
        raise ApiError("""%s.checkValid: firstResonance:
         firstResonance constraint FirstResonance_must_be_in_resonances violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    values = dataDict.get('resonances')
    if (not (len(values) == 2)):
      raise ApiError("""%s.checkValid: resonances:
       locard, hicard: values must be of length == 2""" % self.qualifiedName
       + ": %s" % (self,)
      )

  delete = memops.api.Implementation.DataObject.delete

  findAllApplicationData = memops.api.Implementation.DataObject.findAllApplicationData

  findAllOrderedResonances = PairwiseConstraintItem.findAllOrderedResonances

  findAllResonances = PairwiseConstraintItem.findAllResonances

  findFirstApplicationData = memops.api.Implementation.DataObject.findFirstApplicationData

  findFirstOrderedResonance = PairwiseConstraintItem.findFirstOrderedResonance

  findFirstResonance = PairwiseConstraintItem.findFirstResonance
  
  def get(self, name):
    """
    GetAttr for ccp.nmr.NmrConstraint.HBondConstraintItem
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getAccess = memops.api.Implementation.DataObject.getAccess

  getApplicationData = memops.api.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.HBondConstraintItem
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (5 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.HBondConstraintItem'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (4 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.HBondConstraintItem'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-4]
      obj2 = obj1.__dict__.get('constraintLists').get(objKey)

      if (obj2 is not None):
        objKey = fullKey[-3]
        obj3 = obj2.__dict__.get('constraints').get(objKey)

        if (obj3 is not None):
          tempList = list()
          tempList.append(fullKey[-2])
          tempList.append(fullKey[-1])
          objKey = frozenset(tempList)
          obj4 = obj3.__dict__.get('items').get(objKey)
          result = obj4

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = memops.api.Implementation.MemopsObject.getByNavigation

  getClassName = memops.api.Implementation.ComplexDataType.getClassName
  
  def getConstraint(self):
    """
    Get for ccp.nmr.NmrConstraint.HBondConstraintItem.constraint
    """
    dataDict = self.__dict__
    result = dataDict.get('constraint')
    return result

  getExpandedKey = memops.api.Implementation.MemopsObject.getExpandedKey

  getFieldNames = memops.api.Implementation.ComplexDataType.getFieldNames

  getFirstResonance = PairwiseConstraintItem.getFirstResonance
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccp.nmr.NmrConstraint.HBondConstraintItem
    """
    dataDict = self.__dict__
    result = list()

    obj3 = dataDict.get('constraint')
    obj2 = obj3.__dict__.get('parentList')
    obj1 = obj2.__dict__.get('nmrConstraintStore')

    if (useGuid):
      result.append(obj1.__dict__.get('guid'))
    else:
      result.append(obj1.__dict__.get('serial'))

    result.append(obj2.__dict__.get('serial'))
    result.append(obj3.__dict__.get('serial'))
    for xx in dataDict.get('resonances'):
      result.append(xx)

    return result

  getInConstructor = memops.api.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = memops.api.Implementation.MemopsObject.getIsDeleted
  
  def getLocalKey(self):
    """
    GetLocalKey for ccp.nmr.NmrConstraint.HBondConstraintItem
    """
    dataDict = self.__dict__
    result = dataDict.get('resonances')
    if (result is not None):
      result = frozenset(result)

    return result

  getMetaclass = memops.api.Implementation.ComplexDataType.getMetaclass

  getOrderedResonances = PairwiseConstraintItem.getOrderedResonances

  getPackageName = memops.api.Implementation.ComplexDataType.getPackageName

  getPackageShortName = memops.api.Implementation.ComplexDataType.getPackageShortName
  
  def getParent(self):
    """
    Get for ccp.nmr.NmrConstraint.HBondConstraintItem.parent
    """
    dataDict = self.__dict__
    result = dataDict.get('constraint')
    return result

  getQualifiedName = memops.api.Implementation.ComplexDataType.getQualifiedName

  getResonances = PairwiseConstraintItem.getResonances

  getRoot = memops.api.Implementation.MemopsObject.getRoot

  getTopObject = memops.api.Implementation.DataObject.getTopObject

  removeApplicationData = memops.api.Implementation.DataObject.removeApplicationData

  removeOrderedResonance = PairwiseConstraintItem.removeOrderedResonance
  
  def set(self, name, value):
    """
    SetAttr for ccp.nmr.NmrConstraint.HBondConstraintItem
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setAccess = memops.api.Implementation.DataObject.setAccess

  setApplicationData = memops.api.Implementation.DataObject.setApplicationData

  setFirstResonance = PairwiseConstraintItem.setFirstResonance

  setOrderedResonances = PairwiseConstraintItem.setOrderedResonances

  setResonances = PairwiseConstraintItem.setResonances

  sortedResonances = PairwiseConstraintItem.sortedResonances

  toDetailedString = memops.api.Implementation.ComplexDataType.toDetailedString

  applicationData = memops.api.Implementation.DataObject.applicationData

  className = memops.api.Implementation.ComplexDataType.className

  fieldNames = memops.api.Implementation.ComplexDataType.fieldNames

  inConstructor = memops.api.Implementation.ComplexDataType.inConstructor

  isDeleted = memops.api.Implementation.MemopsObject.isDeleted

  metaclass = memops.api.Implementation.ComplexDataType.metaclass

  packageName = memops.api.Implementation.ComplexDataType.packageName

  packageShortName = memops.api.Implementation.ComplexDataType.packageShortName

  qualifiedName = memops.api.Implementation.ComplexDataType.qualifiedName

  access = memops.api.Implementation.DataObject.access
  
  constraint = property(getConstraint,  None, None,
  r"""parent link
  """)

  firstResonance = PairwiseConstraintItem.firstResonance

  orderedResonances = PairwiseConstraintItem.orderedResonances
  
  parent = property(getParent, None, None,
  r"""link to parent object - synonym for constraint
  """)

  resonances = PairwiseConstraintItem.resonances

  root = memops.api.Implementation.MemopsObject.root

  topObject = memops.api.Implementation.DataObject.topObject

###############################################################################
class JCouplingConstraintItem(PairwiseConstraintItem):
  r"""Pair of Resonances involved in a J coupling restraint
  """
  #   from data model element ccp.nmr.NmrConstraint.JCouplingConstraintItem revision 1.37.2.9
  _metaclass = metaPackage.getElement('JCouplingConstraintItem')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('applicationData', 'className', 'fieldNames', 'inConstructor', 'isDeleted', 'metaclass', 'packageName', 'packageShortName', 'qualifiedName', 'access', 'constraint', 'firstResonance', 'orderedResonances', 'parent', 'resonances', 'root', 'topObject',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccp.nmr.NmrConstraint.JCouplingConstraintItem
    """
    dataDict = self.__dict__
    dataDict['constraint'] = parent
    if (not isinstance(parent, JCouplingConstraint)):
      raise ApiError("""%s.__init__:
       value is not of class ccp.nmr.NmrConstraint.JCouplingConstraint""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:

      dataDict['applicationData'] = list()
      dataDict['access'] = None
      dataDict['firstResonance'] = None
      dataDict['resonances'] = set()

      dataDict['inConstructor'] = True
      try:
        
        for key, value in attrlinks.iteritems():
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        del dataDict['inConstructor']
      except:
        print "ERROR in ccp.nmr.NmrConstraint.JCouplingConstraintItem.__init__"
        del dataDict['inConstructor']
        raise

      if (notIsReading):
        childrenDict = parent.__dict__.get('items')
        objKey = dataDict.get('resonances')
        if (objKey is not None):
          objKey = frozenset(objKey)

        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['resonances'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        print '''WARNING Error in clean-up of incorrectly created object. 
        Data may be left in an illegal state'''
        del dataDict['inConstructor']
      raise exc_info[0], exc_info[1], exc_info[2]

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccp.nmr.NmrConstraint.JCouplingConstraintItem:
       
    determines cascading deletes to follow from delete of object.
       
    *Implementation function* - should be called only by API delete 
    function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
      dataDict.get('topObject').load()

    access = dataDict.get('access')
    if (access is not None):
      topObject = access.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccp.nmr.NmrConstraint.JCouplingConstraintItem:
    deletes objects
    *Implementation function* - will CORRUPT DATA if called 
    outside the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    access = dataDict.get('access')
    if ((access is not None and not (access in objsToBeDeleted))):
      dataObjects = access.__dict__.get('dataObjects')
      dataObjects.remove(self)

    for resonance in dataDict.get('resonances'):
      if (not (resonance in objsToBeDeleted)):
        pairwiseConstraintItems = resonance.__dict__.get('pairwiseConstraintItems')
        pairwiseConstraintItems.remove(self)

    constraint = dataDict.get('constraint')
    if (not (constraint in objsToBeDeleted)):
      objKey = dataDict.get('resonances')
      if (objKey is not None):
        objKey = frozenset(objKey)

      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = constraint.__dict__.get('items')
        if (self is dd.get(objKey)):
          del dd[objKey]

  addApplicationData = memops.api.Implementation.DataObject.addApplicationData

  addOrderedResonance = PairwiseConstraintItem.addOrderedResonance
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccp.nmr.NmrConstraint.JCouplingConstraintItem
    """
    dataDict = self.__dict__
    self.checkValid(complete)
  
  def checkValid(self, complete=False):
    """
    CheckValid for ccp.nmr.NmrConstraint.JCouplingConstraintItem
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('resonances')
      if (objKey is not None):
        objKey = frozenset(objKey)

      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('constraint')
        dd = value.__dict__.get('items')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'constraint' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from memops.api.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, memops.api.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('access')
      if (value is not None):
        from memops.api.AccessControl import AccessObject as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: access:
           value is not of class memops.AccessControl.AccessObject""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('dataObjects')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: access:
           non-reciprocal link JCouplingConstraintItem from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      value = dataDict.get('constraint')
      if (not isinstance(value, JCouplingConstraint)):
        raise ApiError("""%s.checkValid: constraint:
         value is not of class ccp.nmr.NmrConstraint.JCouplingConstraint""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('firstResonance')
      if (value is not None):
        if (not isinstance(value, FixedResonance)):
          raise ApiError("""%s.checkValid: firstResonance:
           value is not of class ccp.nmr.NmrConstraint.FixedResonance""" % self.qualifiedName
           + ": %s" % (value,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: firstResonance:
           Link firstResonance between objects from separate partitions
           - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = self.getOrderedResonances()
      if (len(values) > 2):
        raise ApiError("""%s.checkValid: orderedResonances:
         hicard: values must be of length <= 2""" % self.qualifiedName
         + ": %s" % (self,)
        )

      for value in values:
        if (not isinstance(value, FixedResonance)):
          raise ApiError("""%s.checkValid: orderedResonances:
           value is not of class ccp.nmr.NmrConstraint.FixedResonance""" % self.qualifiedName
           + ": %s" % (value,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: orderedResonances:
           Link orderedResonances between objects from separate partitions
           - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = dataDict.get('resonances')
      for value in values:
        if (not isinstance(value, FixedResonance)):
          raise ApiError("""%s.checkValid: resonances:
           value is not of class ccp.nmr.NmrConstraint.FixedResonance""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('pairwiseConstraintItems')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: resonances:
           non-reciprocal link JCouplingConstraintItem from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

    # check explicit class constraints
    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    # check roles
    value = dataDict.get('access')
    value = dataDict.get('constraint')
    if (value is None):
      raise ApiError("""%s.checkValid: constraint:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    value = dataDict.get('firstResonance')
    if (value is not None):
      if (not (value in self.resonances)):
        raise ApiError("""%s.checkValid: firstResonance:
         firstResonance constraint FirstResonance_must_be_in_resonances violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    values = dataDict.get('resonances')
    if (not (len(values) == 2)):
      raise ApiError("""%s.checkValid: resonances:
       locard, hicard: values must be of length == 2""" % self.qualifiedName
       + ": %s" % (self,)
      )

  delete = memops.api.Implementation.DataObject.delete

  findAllApplicationData = memops.api.Implementation.DataObject.findAllApplicationData

  findAllOrderedResonances = PairwiseConstraintItem.findAllOrderedResonances

  findAllResonances = PairwiseConstraintItem.findAllResonances

  findFirstApplicationData = memops.api.Implementation.DataObject.findFirstApplicationData

  findFirstOrderedResonance = PairwiseConstraintItem.findFirstOrderedResonance

  findFirstResonance = PairwiseConstraintItem.findFirstResonance
  
  def get(self, name):
    """
    GetAttr for ccp.nmr.NmrConstraint.JCouplingConstraintItem
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getAccess = memops.api.Implementation.DataObject.getAccess

  getApplicationData = memops.api.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.JCouplingConstraintItem
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (5 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.JCouplingConstraintItem'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (4 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.JCouplingConstraintItem'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-4]
      obj2 = obj1.__dict__.get('constraintLists').get(objKey)

      if (obj2 is not None):
        objKey = fullKey[-3]
        obj3 = obj2.__dict__.get('constraints').get(objKey)

        if (obj3 is not None):
          tempList = list()
          tempList.append(fullKey[-2])
          tempList.append(fullKey[-1])
          objKey = frozenset(tempList)
          obj4 = obj3.__dict__.get('items').get(objKey)
          result = obj4

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = memops.api.Implementation.MemopsObject.getByNavigation

  getClassName = memops.api.Implementation.ComplexDataType.getClassName
  
  def getConstraint(self):
    """
    Get for ccp.nmr.NmrConstraint.JCouplingConstraintItem.constraint
    """
    dataDict = self.__dict__
    result = dataDict.get('constraint')
    return result

  getExpandedKey = memops.api.Implementation.MemopsObject.getExpandedKey

  getFieldNames = memops.api.Implementation.ComplexDataType.getFieldNames

  getFirstResonance = PairwiseConstraintItem.getFirstResonance
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccp.nmr.NmrConstraint.JCouplingConstraintItem
    """
    dataDict = self.__dict__
    result = list()

    obj3 = dataDict.get('constraint')
    obj2 = obj3.__dict__.get('parentList')
    obj1 = obj2.__dict__.get('nmrConstraintStore')

    if (useGuid):
      result.append(obj1.__dict__.get('guid'))
    else:
      result.append(obj1.__dict__.get('serial'))

    result.append(obj2.__dict__.get('serial'))
    result.append(obj3.__dict__.get('serial'))
    for xx in dataDict.get('resonances'):
      result.append(xx)

    return result

  getInConstructor = memops.api.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = memops.api.Implementation.MemopsObject.getIsDeleted
  
  def getLocalKey(self):
    """
    GetLocalKey for ccp.nmr.NmrConstraint.JCouplingConstraintItem
    """
    dataDict = self.__dict__
    result = dataDict.get('resonances')
    if (result is not None):
      result = frozenset(result)

    return result

  getMetaclass = memops.api.Implementation.ComplexDataType.getMetaclass

  getOrderedResonances = PairwiseConstraintItem.getOrderedResonances

  getPackageName = memops.api.Implementation.ComplexDataType.getPackageName

  getPackageShortName = memops.api.Implementation.ComplexDataType.getPackageShortName
  
  def getParent(self):
    """
    Get for ccp.nmr.NmrConstraint.JCouplingConstraintItem.parent
    """
    dataDict = self.__dict__
    result = dataDict.get('constraint')
    return result

  getQualifiedName = memops.api.Implementation.ComplexDataType.getQualifiedName

  getResonances = PairwiseConstraintItem.getResonances

  getRoot = memops.api.Implementation.MemopsObject.getRoot

  getTopObject = memops.api.Implementation.DataObject.getTopObject

  removeApplicationData = memops.api.Implementation.DataObject.removeApplicationData

  removeOrderedResonance = PairwiseConstraintItem.removeOrderedResonance
  
  def set(self, name, value):
    """
    SetAttr for ccp.nmr.NmrConstraint.JCouplingConstraintItem
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setAccess = memops.api.Implementation.DataObject.setAccess

  setApplicationData = memops.api.Implementation.DataObject.setApplicationData

  setFirstResonance = PairwiseConstraintItem.setFirstResonance

  setOrderedResonances = PairwiseConstraintItem.setOrderedResonances

  setResonances = PairwiseConstraintItem.setResonances

  sortedResonances = PairwiseConstraintItem.sortedResonances

  toDetailedString = memops.api.Implementation.ComplexDataType.toDetailedString

  applicationData = memops.api.Implementation.DataObject.applicationData

  className = memops.api.Implementation.ComplexDataType.className

  fieldNames = memops.api.Implementation.ComplexDataType.fieldNames

  inConstructor = memops.api.Implementation.ComplexDataType.inConstructor

  isDeleted = memops.api.Implementation.MemopsObject.isDeleted

  metaclass = memops.api.Implementation.ComplexDataType.metaclass

  packageName = memops.api.Implementation.ComplexDataType.packageName

  packageShortName = memops.api.Implementation.ComplexDataType.packageShortName

  qualifiedName = memops.api.Implementation.ComplexDataType.qualifiedName

  access = memops.api.Implementation.DataObject.access
  
  constraint = property(getConstraint,  None, None,
  r"""parent link
  """)

  firstResonance = PairwiseConstraintItem.firstResonance

  orderedResonances = PairwiseConstraintItem.orderedResonances
  
  parent = property(getParent, None, None,
  r"""link to parent object - synonym for constraint
  """)

  resonances = PairwiseConstraintItem.resonances

  root = memops.api.Implementation.MemopsObject.root

  topObject = memops.api.Implementation.DataObject.topObject

###############################################################################
class DistanceConstraintItem(PairwiseConstraintItem):
  r"""Pair of Resonances involved in a distance restraint
  """
  #   from data model element ccp.nmr.NmrConstraint.DistanceConstraintItem revision 1.37.2.9
  _metaclass = metaPackage.getElement('DistanceConstraintItem')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('applicationData', 'className', 'fieldNames', 'inConstructor', 'isDeleted', 'metaclass', 'packageName', 'packageShortName', 'qualifiedName', 'access', 'constraint', 'firstResonance', 'orderedResonances', 'parent', 'resonances', 'root', 'topObject',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccp.nmr.NmrConstraint.DistanceConstraintItem
    """
    dataDict = self.__dict__
    dataDict['constraint'] = parent
    if (not isinstance(parent, DistanceConstraint)):
      raise ApiError("""%s.__init__:
       value is not of class ccp.nmr.NmrConstraint.DistanceConstraint""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:

      dataDict['applicationData'] = list()
      dataDict['access'] = None
      dataDict['firstResonance'] = None
      dataDict['resonances'] = set()

      dataDict['inConstructor'] = True
      try:
        
        for key, value in attrlinks.iteritems():
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        del dataDict['inConstructor']
      except:
        print "ERROR in ccp.nmr.NmrConstraint.DistanceConstraintItem.__init__"
        del dataDict['inConstructor']
        raise

      if (notIsReading):
        childrenDict = parent.__dict__.get('items')
        objKey = dataDict.get('resonances')
        if (objKey is not None):
          objKey = frozenset(objKey)

        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['resonances'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        print '''WARNING Error in clean-up of incorrectly created object. 
        Data may be left in an illegal state'''
        del dataDict['inConstructor']
      raise exc_info[0], exc_info[1], exc_info[2]

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccp.nmr.NmrConstraint.DistanceConstraintItem:
       
    determines cascading deletes to follow from delete of object.
       
    *Implementation function* - should be called only by API delete 
    function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
      dataDict.get('topObject').load()

    access = dataDict.get('access')
    if (access is not None):
      topObject = access.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccp.nmr.NmrConstraint.DistanceConstraintItem:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    access = dataDict.get('access')
    if ((access is not None and not (access in objsToBeDeleted))):
      dataObjects = access.__dict__.get('dataObjects')
      dataObjects.remove(self)

    for resonance in dataDict.get('resonances'):
      if (not (resonance in objsToBeDeleted)):
        pairwiseConstraintItems = resonance.__dict__.get('pairwiseConstraintItems')
        pairwiseConstraintItems.remove(self)

    constraint = dataDict.get('constraint')
    if (not (constraint in objsToBeDeleted)):
      objKey = dataDict.get('resonances')
      if (objKey is not None):
        objKey = frozenset(objKey)

      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = constraint.__dict__.get('items')
        if (self is dd.get(objKey)):
          del dd[objKey]

  addApplicationData = memops.api.Implementation.DataObject.addApplicationData

  addOrderedResonance = PairwiseConstraintItem.addOrderedResonance
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccp.nmr.NmrConstraint.DistanceConstraintItem
    """
    dataDict = self.__dict__
    self.checkValid(complete)
  
  def checkValid(self, complete=False):
    """
    CheckValid for ccp.nmr.NmrConstraint.DistanceConstraintItem
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('resonances')
      if (objKey is not None):
        objKey = frozenset(objKey)

      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('constraint')
        dd = value.__dict__.get('items')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'constraint' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from memops.api.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, memops.api.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('access')
      if (value is not None):
        from memops.api.AccessControl import AccessObject as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: access:
           value is not of class memops.AccessControl.AccessObject""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('dataObjects')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: access:
           non-reciprocal link DistanceConstraintItem from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      value = dataDict.get('constraint')
      if (not isinstance(value, DistanceConstraint)):
        raise ApiError("""%s.checkValid: constraint:
         value is not of class ccp.nmr.NmrConstraint.DistanceConstraint""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('firstResonance')
      if (value is not None):
        if (not isinstance(value, FixedResonance)):
          raise ApiError("""%s.checkValid: firstResonance:
           value is not of class ccp.nmr.NmrConstraint.FixedResonance""" % self.qualifiedName
           + ": %s" % (value,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: firstResonance:
           Link firstResonance between objects from separate partitions
           - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = self.getOrderedResonances()
      if (len(values) > 2):
        raise ApiError("""%s.checkValid: orderedResonances:
         hicard: values must be of length <= 2""" % self.qualifiedName
         + ": %s" % (self,)
        )

      for value in values:
        if (not isinstance(value, FixedResonance)):
          raise ApiError("""%s.checkValid: orderedResonances:
           value is not of class ccp.nmr.NmrConstraint.FixedResonance""" % self.qualifiedName
           + ": %s" % (value,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: orderedResonances:
           Link orderedResonances between objects from separate partitions
           - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = dataDict.get('resonances')
      for value in values:
        if (not isinstance(value, FixedResonance)):
          raise ApiError("""%s.checkValid: resonances:
           value is not of class ccp.nmr.NmrConstraint.FixedResonance""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('pairwiseConstraintItems')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: resonances:
           non-reciprocal link DistanceConstraintItem from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

    # check explicit class constraints
    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    # check roles
    value = dataDict.get('access')
    value = dataDict.get('constraint')
    if (value is None):
      raise ApiError("""%s.checkValid: constraint:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    value = dataDict.get('firstResonance')
    if (value is not None):
      if (not (value in self.resonances)):
        raise ApiError("""%s.checkValid: firstResonance:
         firstResonance constraint FirstResonance_must_be_in_resonances violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    values = dataDict.get('resonances')
    if (not (len(values) == 2)):
      raise ApiError("""%s.checkValid: resonances:
       locard, hicard: values must be of length == 2""" % self.qualifiedName
       + ": %s" % (self,)
      )

  delete = memops.api.Implementation.DataObject.delete

  findAllApplicationData = memops.api.Implementation.DataObject.findAllApplicationData

  findAllOrderedResonances = PairwiseConstraintItem.findAllOrderedResonances

  findAllResonances = PairwiseConstraintItem.findAllResonances

  findFirstApplicationData = memops.api.Implementation.DataObject.findFirstApplicationData

  findFirstOrderedResonance = PairwiseConstraintItem.findFirstOrderedResonance

  findFirstResonance = PairwiseConstraintItem.findFirstResonance
  
  def get(self, name):
    """
    GetAttr for ccp.nmr.NmrConstraint.DistanceConstraintItem
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getAccess = memops.api.Implementation.DataObject.getAccess

  getApplicationData = memops.api.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.DistanceConstraintItem
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (5 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.DistanceConstraintItem'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (4 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.DistanceConstraintItem'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-4]
      obj2 = obj1.__dict__.get('constraintLists').get(objKey)

      if (obj2 is not None):
        objKey = fullKey[-3]
        obj3 = obj2.__dict__.get('constraints').get(objKey)

        if (obj3 is not None):
          tempList = list()
          tempList.append(fullKey[-2])
          tempList.append(fullKey[-1])
          objKey = frozenset(tempList)
          obj4 = obj3.__dict__.get('items').get(objKey)
          result = obj4

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = memops.api.Implementation.MemopsObject.getByNavigation

  getClassName = memops.api.Implementation.ComplexDataType.getClassName
  
  def getConstraint(self):
    """
    Get for ccp.nmr.NmrConstraint.DistanceConstraintItem.constraint
    """
    dataDict = self.__dict__
    result = dataDict.get('constraint')
    return result

  getExpandedKey = memops.api.Implementation.MemopsObject.getExpandedKey

  getFieldNames = memops.api.Implementation.ComplexDataType.getFieldNames

  getFirstResonance = PairwiseConstraintItem.getFirstResonance
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccp.nmr.NmrConstraint.DistanceConstraintItem
    """
    dataDict = self.__dict__
    result = list()

    obj3 = dataDict.get('constraint')
    obj2 = obj3.__dict__.get('parentList')
    obj1 = obj2.__dict__.get('nmrConstraintStore')

    if (useGuid):
      result.append(obj1.__dict__.get('guid'))
    else:
      result.append(obj1.__dict__.get('serial'))

    result.append(obj2.__dict__.get('serial'))
    result.append(obj3.__dict__.get('serial'))
    for xx in dataDict.get('resonances'):
      result.append(xx)

    return result

  getInConstructor = memops.api.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = memops.api.Implementation.MemopsObject.getIsDeleted
  
  def getLocalKey(self):
    """
    GetLocalKey for ccp.nmr.NmrConstraint.DistanceConstraintItem
    """
    dataDict = self.__dict__
    result = dataDict.get('resonances')
    if (result is not None):
      result = frozenset(result)

    return result

  getMetaclass = memops.api.Implementation.ComplexDataType.getMetaclass

  getOrderedResonances = PairwiseConstraintItem.getOrderedResonances

  getPackageName = memops.api.Implementation.ComplexDataType.getPackageName

  getPackageShortName = memops.api.Implementation.ComplexDataType.getPackageShortName
  
  def getParent(self):
    """
    Get for ccp.nmr.NmrConstraint.DistanceConstraintItem.parent
    """
    dataDict = self.__dict__
    result = dataDict.get('constraint')
    return result

  getQualifiedName = memops.api.Implementation.ComplexDataType.getQualifiedName

  getResonances = PairwiseConstraintItem.getResonances

  getRoot = memops.api.Implementation.MemopsObject.getRoot

  getTopObject = memops.api.Implementation.DataObject.getTopObject

  removeApplicationData = memops.api.Implementation.DataObject.removeApplicationData

  removeOrderedResonance = PairwiseConstraintItem.removeOrderedResonance
  
  def set(self, name, value):
    """
    SetAttr for ccp.nmr.NmrConstraint.DistanceConstraintItem
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setAccess = memops.api.Implementation.DataObject.setAccess

  setApplicationData = memops.api.Implementation.DataObject.setApplicationData

  setFirstResonance = PairwiseConstraintItem.setFirstResonance

  setOrderedResonances = PairwiseConstraintItem.setOrderedResonances

  setResonances = PairwiseConstraintItem.setResonances

  sortedResonances = PairwiseConstraintItem.sortedResonances

  toDetailedString = memops.api.Implementation.ComplexDataType.toDetailedString

  applicationData = memops.api.Implementation.DataObject.applicationData

  className = memops.api.Implementation.ComplexDataType.className

  fieldNames = memops.api.Implementation.ComplexDataType.fieldNames

  inConstructor = memops.api.Implementation.ComplexDataType.inConstructor

  isDeleted = memops.api.Implementation.MemopsObject.isDeleted

  metaclass = memops.api.Implementation.ComplexDataType.metaclass

  packageName = memops.api.Implementation.ComplexDataType.packageName

  packageShortName = memops.api.Implementation.ComplexDataType.packageShortName

  qualifiedName = memops.api.Implementation.ComplexDataType.qualifiedName

  access = memops.api.Implementation.DataObject.access
  
  constraint = property(getConstraint,  None, None,
  r"""parent link
  """)

  firstResonance = PairwiseConstraintItem.firstResonance

  orderedResonances = PairwiseConstraintItem.orderedResonances
  
  parent = property(getParent, None, None,
  r"""link to parent object - synonym for constraint
  """)

  resonances = PairwiseConstraintItem.resonances

  root = memops.api.Implementation.MemopsObject.root

  topObject = memops.api.Implementation.DataObject.topObject

###############################################################################
class RdcConstraint(SingleConstraint):
  r"""Reduced dipolar coupling constraint. Ambiguous, may contain several 
RdcConstraintItems, each with a different assignment, describing 
alternative assignment possibilities.
  """
  #   from data model element ccp.nmr.NmrConstraint.RdcConstraint revision 1.36.2.9
  _metaclass = metaPackage.getElement('RdcConstraint')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('applicationData', 'className', 'details', 'error', 'fieldNames', 'inConstructor', 'isDeleted', 'lowerLimit', 'metaclass', 'origData', 'packageName', 'packageShortName', 'qualifiedName', 'serial', 'targetValue', 'upperLimit', 'vectorLength', 'weight', 'access', 'constraintGroups', 'items', 'method', 'nmrConstraintValidations', 'parent', 'parentList', 'peakContribs', 'peaks', 'root', 'topObject', 'violations',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccp.nmr.NmrConstraint.RdcConstraint
    """
    dataDict = self.__dict__
    dataDict['parentList'] = parent
    if (not isinstance(parent, RdcConstraintList)):
      raise ApiError("""%s.__init__:
       value is not of class ccp.nmr.NmrConstraint.RdcConstraintList""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:

      dataDict['applicationData'] = list()
      dataDict['details'] = None
      dataDict['error'] = None
      dataDict['lowerLimit'] = None
      dataDict['origData'] = None
      dataDict['serial'] = None
      dataDict['targetValue'] = None
      dataDict['upperLimit'] = None
      dataDict['vectorLength'] = None
      dataDict['weight'] = 1.0
      dataDict['access'] = None
      dataDict['constraintGroups'] = set()
      dataDict['items'] = {}
      dataDict['method'] = None
      dataDict['nmrConstraintValidations'] = set()
      dataDict['peakContribs'] = {}
      dataDict['violations'] = set()

      dataDict['inConstructor'] = True
      try:
        
        for key, value in attrlinks.iteritems():
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        del dataDict['inConstructor']
      except:
        print "ERROR in ccp.nmr.NmrConstraint.RdcConstraint.__init__"
        del dataDict['inConstructor']
        raise

      if (notOverride):
        if (dataDict.get('serial') is None):
          dataDict['inConstructor'] = True
          self.setSerial(-1)
          del dataDict['inConstructor']
        else:
          raise ApiError("""%s.__init__:
           Cannot pass in explicit serial if not reading""" % self.qualifiedName
           + ": %s:%s" % (parent, 'ccp.nmr.NmrConstraint.RdcConstraint')
          )

      if (notIsReading):
        childrenDict = parent.__dict__.get('constraints')
        objKey = dataDict.get('serial')
        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['serial'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        print '''WARNING Error in clean-up of incorrectly created object. 
        Data may be left in an illegal state'''
        del dataDict['inConstructor']
      raise exc_info[0], exc_info[1], exc_info[2]

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccp.nmr.NmrConstraint.RdcConstraint:
       determines 
    cascading deletes to follow from delete of object.
       *Implementation 
    function* - should be called only by API delete function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
      dataDict.get('topObject').load()

    access = dataDict.get('access')
    if (access is not None):
      topObject = access.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    items = dataDict.get('items').values()
    for item in items:
      if (not (item in objsToBeDeleted)):
        objsToBeDeleted.add(item)
        objsToBeChecked.append(item)

    method = dataDict.get('method')
    if (method is not None):
      topObject = method.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    nmrConstraintValidations = dataDict.get('nmrConstraintValidations')
    pass
    for nmrConstraintValidation in nmrConstraintValidations:
      topObject = nmrConstraintValidation.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    peakContribs = dataDict.get('peakContribs').values()
    for peakContrib in peakContribs:
      if (not (peakContrib in objsToBeDeleted)):
        objsToBeDeleted.add(peakContrib)
        objsToBeChecked.append(peakContrib)

    violations = dataDict.get('violations')
    for violation in violations:
      if (not (violation in objsToBeDeleted)):
        objsToBeDeleted.add(violation)
        objsToBeChecked.append(violation)

    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccp.nmr.NmrConstraint.RdcConstraint:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    access = dataDict.get('access')
    if ((access is not None and not (access in objsToBeDeleted))):
      dataObjects = access.__dict__.get('dataObjects')
      dataObjects.remove(self)

    for constraintGroup in dataDict.get('constraintGroups'):
      if (not (constraintGroup in objsToBeDeleted)):
        constraints = constraintGroup.__dict__.get('constraints')
        constraints.remove(self)

    method = dataDict.get('method')
    if ((method is not None and not (method in objsToBeDeleted))):
      constraints = method.__dict__.get('constraints')
      constraints.remove(self)

    for nmrConstraintValidation in dataDict.get('nmrConstraintValidations'):
      if (not (nmrConstraintValidation in objsToBeDeleted)):
        nmrConstraints = nmrConstraintValidation.__dict__.get('nmrConstraints')
        nmrConstraints.remove(self)

    parentList = dataDict.get('parentList')
    if (not (parentList in objsToBeDeleted)):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = parentList.__dict__.get('constraints')
        if (self is dd.get(objKey)):
          del dd[objKey]

  addApplicationData = memops.api.Implementation.DataObject.addApplicationData

  addConstraintGroup = AbstractConstraint.addConstraintGroup

  addNmrConstraintValidation = AbstractConstraint.addNmrConstraintValidation

  addPeak = AbstractConstraint.addPeak
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccp.nmr.NmrConstraint.RdcConstraint
    """
    dataDict = self.__dict__
    self.checkValid(complete)
    values = dataDict.get('items').values()
    for value in values:
      value.checkAllValid(complete)

    values = dataDict.get('peakContribs').values()
    for value in values:
      value.checkAllValid(complete)

  def checkValid(self, complete=False):
    """
    CheckValid for ccp.nmr.NmrConstraint.RdcConstraint
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('parentList')
        dd = value.__dict__.get('constraints')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'parentList' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from memops.api.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('details')
      if (value is not None):
        if (isinstance(value, memops.api.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: details:
           memops.Implementation.Text input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 254):
          raise ApiError("""%s.checkValid: details:
           memops.Implementation.Text maximum length is 254 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: details:
           memops.Implementation.Text: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('error')
      if (value is not None):
        if (isinstance(value, memops.api.Implementation.Float.PythonType)):
          pass
        elif ([x for x in memops.api.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = memops.api.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: error:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: error:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('lowerLimit')
      if (value is not None):
        if (isinstance(value, memops.api.Implementation.Float.PythonType)):
          pass
        elif ([x for x in memops.api.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = memops.api.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: lowerLimit:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: lowerLimit:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('origData')
      if (value is not None):
        if (isinstance(value, memops.api.Implementation.Float.PythonType)):
          pass
        elif ([x for x in memops.api.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = memops.api.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: origData:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: origData:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, memops.api.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('serial')
      if (value is None):
        raise ApiError("""%s.checkValid: serial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, memops.api.Implementation.Int.PythonType)):
        pass
      elif ([x for x in memops.api.Implementation.Int.compatibleTypes if isinstance(value, x)]):
        value = memops.api.Implementation.Int.create(value)
      else:
        raise ApiError("""%s.checkValid: serial:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('targetValue')
      if (value is not None):
        if (isinstance(value, memops.api.Implementation.Float.PythonType)):
          pass
        elif ([x for x in memops.api.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = memops.api.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: targetValue:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: targetValue:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('upperLimit')
      if (value is not None):
        if (isinstance(value, memops.api.Implementation.Float.PythonType)):
          pass
        elif ([x for x in memops.api.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = memops.api.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: upperLimit:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: upperLimit:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('vectorLength')
      if (value is not None):
        if (isinstance(value, memops.api.Implementation.Float.PythonType)):
          pass
        elif ([x for x in memops.api.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = memops.api.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: vectorLength:
           memops.Implementation.PositiveFloat input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value > 0)):
          raise ApiError("""%s.checkValid: vectorLength:
           PositiveFloat constraint float_value_gt_0 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: vectorLength:
           PositiveFloat constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('weight')
      if (isinstance(value, memops.api.Implementation.Float.PythonType)):
        pass
      elif ([x for x in memops.api.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = memops.api.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.checkValid: weight:
         memops.Implementation.NonNegativeFloat input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (0.0 <= value)):
        raise ApiError("""%s.checkValid: weight:
         NonNegativeFloat constraint float_value_ge_0 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.checkValid: weight:
         NonNegativeFloat constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('access')
      if (value is not None):
        from memops.api.AccessControl import AccessObject as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: access:
           value is not of class memops.AccessControl.AccessObject""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('dataObjects')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: access:
           non-reciprocal link RdcConstraint from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('constraintGroups')
      for value in values:
        if (not isinstance(value, ConstraintGroup)):
          raise ApiError("""%s.checkValid: constraintGroups:
           value is not of class ccp.nmr.NmrConstraint.ConstraintGroup""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('constraints')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: constraintGroups:
           non-reciprocal link RdcConstraint from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: constraintGroups:
           Link constraintGroups between objects from separate partitions
           - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = dataDict.get('items').values()
      for value in values:
        if (not isinstance(value, RdcConstraintItem)):
          raise ApiError("""%s.checkValid: items:
           value is not of class ccp.nmr.NmrConstraint.RdcConstraintItem""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('constraint')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: items:
           non-reciprocal link RdcConstraint from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      value = dataDict.get('method')
      if (value is not None):
        from ccp.api.general.Method import Method as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: method:
           value is not of class ccp.general.Method.Method""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('constraints')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: method:
           non-reciprocal link RdcConstraint from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('nmrConstraintValidations')
      for value in values:
        from ccp.api.molecule.Validation import NmrConstraintValidation as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: nmrConstraintValidations:
           value is not of class ccp.molecule.Validation.NmrConstraintValidation""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('nmrConstraints')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: nmrConstraintValidations:
           non-reciprocal link RdcConstraint from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        yy2 = yy1.__dict__.get('nmrConstraintStore')
        if (not (xx1 is yy2)):
          raise ApiError("""%s.checkValid: nmrConstraintValidations:
           Link nmrConstraintValidations between objects from separate partitions
           - ccp.molecule.Validation.ValidationStore.nmrConstraintStore not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      value = dataDict.get('parentList')
      if (not isinstance(value, RdcConstraintList)):
        raise ApiError("""%s.checkValid: parentList:
         value is not of class ccp.nmr.NmrConstraint.RdcConstraintList""" % self.qualifiedName
         + ": %s" % (value,)
        )

      values = dataDict.get('peakContribs').values()
      for value in values:
        if (not isinstance(value, ConstraintPeakContrib)):
          raise ApiError("""%s.checkValid: peakContribs:
           value is not of class ccp.nmr.NmrConstraint.ConstraintPeakContrib""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('constraint')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: peakContribs:
           non-reciprocal link RdcConstraint from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = self.getPeaks()
      for value in values:
        from ccp.api.nmr.Nmr import Peak as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: peaks:
           value is not of class ccp.nmr.Nmr.Peak""" % self.qualifiedName
           + ": %s" % (value,)
          )

        xx1 = dataDict.get('topObject')
        xx2 = xx1.__dict__.get('nmrProject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx2 is yy1)):
          raise ApiError("""%s.checkValid: peaks:
           Link peaks between objects from separate partitions
           - ccp.nmr.NmrConstraint.NmrConstraintStore.nmrProject not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = dataDict.get('violations')
      for value in values:
        if (not isinstance(value, Violation)):
          raise ApiError("""%s.checkValid: violations:
           value is not of class ccp.nmr.NmrConstraint.Violation""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('constraint')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: violations:
           non-reciprocal link RdcConstraint from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: violations:
           Link violations between objects from separate partitions
           - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    # check explicit class constraints
    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('details')
    value = dataDict.get('error')
    value = dataDict.get('lowerLimit')
    value = dataDict.get('origData')
    value = dataDict.get('targetValue')
    value = dataDict.get('upperLimit')
    value = dataDict.get('vectorLength')
    value = dataDict.get('weight')
    if (value is None):
      raise ApiError("""%s.checkValid: weight:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    # check roles
    value = dataDict.get('access')
    values = dataDict.get('constraintGroups')
    values = dataDict.get('items').values()
    value = dataDict.get('method')
    values = dataDict.get('nmrConstraintValidations')
    for value in values:
      ll= value.keywordDefinition.targetNames
      isValid = (not ll or self.qualifiedName in ll)
      if (not (isValid)):
        raise ApiError("""%s.checkValid: nmrConstraintValidations:
         nmrConstraintValidations constraint KeywordDefinition_fits_Constraint violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    value = dataDict.get('parentList')
    if (value is None):
      raise ApiError("""%s.checkValid: parentList:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    values = dataDict.get('peakContribs').values()
    values = dataDict.get('violations')

  delete = memops.api.Implementation.DataObject.delete

  findAllApplicationData = memops.api.Implementation.DataObject.findAllApplicationData

  findAllConstraintGroups = AbstractConstraint.findAllConstraintGroups
  
  def findAllItems(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.RdcConstraint.items
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('items').values()
      result = set(currentValues)

    else:
      currentValues = dataDict.get('items').values()
      result = set()
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('access', 'constraint', 'firstResonance',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result.add(v)

    return result

  findAllNmrConstraintValidations = AbstractConstraint.findAllNmrConstraintValidations

  findAllPeakContribs = AbstractConstraint.findAllPeakContribs

  findAllPeaks = AbstractConstraint.findAllPeaks

  findAllViolations = AbstractConstraint.findAllViolations

  findFirstApplicationData = memops.api.Implementation.DataObject.findFirstApplicationData

  findFirstConstraintGroup = AbstractConstraint.findFirstConstraintGroup
  
  def findFirstItem(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.RdcConstraint.items
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('items').values()
      if (currentValues):
        result = iter(currentValues).next()
      else:
        result = None

    else:
      objKey = conditions.get('resonances')
      if (objKey is not None):
        objKey = frozenset(objKey)

      if (objKey is not None):
        result = dataDict.get('items').get(objKey)

        if (result is None):
          return result

        elif (len(conditions) <= 1):
          return result

        else:
          currentValues = set()
          currentValues.add(result)

      else:
        currentValues = dataDict.get('items').values()

      result = None
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('access', 'constraint', 'firstResonance',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result = v; break

    return result

  findFirstNmrConstraintValidation = AbstractConstraint.findFirstNmrConstraintValidation

  findFirstPeak = AbstractConstraint.findFirstPeak

  findFirstPeakContrib = AbstractConstraint.findFirstPeakContrib

  findFirstViolation = AbstractConstraint.findFirstViolation
  
  def get(self, name):
    """
    GetAttr for ccp.nmr.NmrConstraint.RdcConstraint
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getAccess = memops.api.Implementation.DataObject.getAccess

  getApplicationData = memops.api.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.RdcConstraint
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (3 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.RdcConstraint'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (2 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.RdcConstraint'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-2]
      obj2 = obj1.__dict__.get('constraintLists').get(objKey)

      if (obj2 is not None):
        objKey = fullKey[-1]
        obj3 = obj2.__dict__.get('constraints').get(objKey)
        result = obj3

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = memops.api.Implementation.MemopsObject.getByNavigation

  getClassName = memops.api.Implementation.ComplexDataType.getClassName

  getConstraintGroups = AbstractConstraint.getConstraintGroups

  getDetails = AbstractConstraint.getDetails

  getError = SingleConstraint.getError

  getExpandedKey = memops.api.Implementation.MemopsObject.getExpandedKey

  getFieldNames = memops.api.Implementation.ComplexDataType.getFieldNames
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccp.nmr.NmrConstraint.RdcConstraint
    """
    dataDict = self.__dict__
    result = list()

    obj2 = dataDict.get('parentList')
    obj1 = obj2.__dict__.get('nmrConstraintStore')

    if (useGuid):
      result.append(obj1.__dict__.get('guid'))
    else:
      result.append(obj1.__dict__.get('serial'))

    result.append(obj2.__dict__.get('serial'))
    result.append(dataDict.get('serial'))

    return result

  getInConstructor = memops.api.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = memops.api.Implementation.MemopsObject.getIsDeleted
  
  def getItems(self):
    """
    Get for ccp.nmr.NmrConstraint.RdcConstraint.items
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('items').values()
    result = frozenset(tempVar)
    return result
  
  def getLocalKey(self):
    """
    GetLocalKey for ccp.nmr.NmrConstraint.RdcConstraint
    """
    dataDict = self.__dict__
    result = dataDict.get('serial')
    return result

  getLowerLimit = SingleConstraint.getLowerLimit

  getMetaclass = memops.api.Implementation.ComplexDataType.getMetaclass

  getMethod = AbstractConstraint.getMethod

  getNmrConstraintValidations = AbstractConstraint.getNmrConstraintValidations

  getOrigData = AbstractConstraint.getOrigData

  getPackageName = memops.api.Implementation.ComplexDataType.getPackageName

  getPackageShortName = memops.api.Implementation.ComplexDataType.getPackageShortName
  
  def getParent(self):
    """
    Get for ccp.nmr.NmrConstraint.RdcConstraint.parent
    """
    dataDict = self.__dict__
    result = dataDict.get('parentList')
    return result
  
  def getParentList(self):
    """
    Get for ccp.nmr.NmrConstraint.RdcConstraint.parentList
    """
    dataDict = self.__dict__
    result = dataDict.get('parentList')
    return result

  getPeakContribs = AbstractConstraint.getPeakContribs

  getPeaks = AbstractConstraint.getPeaks

  getQualifiedName = memops.api.Implementation.ComplexDataType.getQualifiedName

  getRoot = memops.api.Implementation.MemopsObject.getRoot

  getSerial = AbstractConstraint.getSerial

  getTargetValue = SingleConstraint.getTargetValue

  getTopObject = memops.api.Implementation.DataObject.getTopObject

  getUpperLimit = SingleConstraint.getUpperLimit
  
  def getVectorLength(self):
    """
    Get for ccp.nmr.NmrConstraint.RdcConstraint.vectorLength
    """
    dataDict = self.__dict__
    result = dataDict.get('vectorLength')
    return result

  getViolations = AbstractConstraint.getViolations

  getWeight = AbstractConstraint.getWeight

  newConstraintPeakContrib = AbstractConstraint.newConstraintPeakContrib
  
  def newRdcConstraintItem(self, **attrlinks):
    """
    Factory function to create ccp.nmr.NmrConstraint.RdcConstraintItem
    """
    return RdcConstraintItem(self, **attrlinks)

  removeApplicationData = memops.api.Implementation.DataObject.removeApplicationData

  removeConstraintGroup = AbstractConstraint.removeConstraintGroup

  removeNmrConstraintValidation = AbstractConstraint.removeNmrConstraintValidation

  removePeak = AbstractConstraint.removePeak
  
  def set(self, name, value):
    """
    SetAttr for ccp.nmr.NmrConstraint.RdcConstraint
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setAccess = memops.api.Implementation.DataObject.setAccess

  setApplicationData = memops.api.Implementation.DataObject.setApplicationData

  setConstraintGroups = AbstractConstraint.setConstraintGroups

  setDetails = AbstractConstraint.setDetails

  setError = SingleConstraint.setError

  setLowerLimit = SingleConstraint.setLowerLimit

  setMethod = AbstractConstraint.setMethod

  setNmrConstraintValidations = AbstractConstraint.setNmrConstraintValidations

  setOrigData = AbstractConstraint.setOrigData

  setPeaks = AbstractConstraint.setPeaks

  setSerial = AbstractConstraint.setSerial

  setTargetValue = SingleConstraint.setTargetValue

  setUpperLimit = SingleConstraint.setUpperLimit
  
  def setVectorLength(self, value):
    """
    Set for ccp.nmr.NmrConstraint.RdcConstraint.vectorLength
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, memops.api.Implementation.Float.PythonType)):
        pass
      elif ([x for x in memops.api.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = memops.api.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.setVectorLength:
         memops.Implementation.PositiveFloat input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value > 0)):
        raise ApiError("""%s.setVectorLength:
         PositiveFloat constraint float_value_gt_0 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.setVectorLength:
         PositiveFloat constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('vectorLength')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setVectorLength:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setVectorLength:
       called on deleted object""" % self.qualifiedName
      )

    if (value == currentValue):
      return

    if (notOverride):
      pass

    dataDict['vectorLength'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setVectorLength')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  setViolations = AbstractConstraint.setViolations

  setWeight = AbstractConstraint.setWeight

  sortedConstraintGroups = AbstractConstraint.sortedConstraintGroups
  
  def sortedItems(self):
    """
    Sorted for ccp.nmr.NmrConstraint.RdcConstraint.items
    """
    dataDict = self.__dict__
    sortdd = dataDict.get('items')
    
    ll = sortdd.keys()
    ll.sort()
    result = [sortdd[x] for x in ll]
    return result

  sortedNmrConstraintValidations = AbstractConstraint.sortedNmrConstraintValidations

  sortedPeakContribs = AbstractConstraint.sortedPeakContribs

  sortedPeaks = AbstractConstraint.sortedPeaks

  sortedViolations = AbstractConstraint.sortedViolations

  toDetailedString = memops.api.Implementation.ComplexDataType.toDetailedString

  applicationData = memops.api.Implementation.DataObject.applicationData

  className = memops.api.Implementation.ComplexDataType.className

  details = AbstractConstraint.details

  error = SingleConstraint.error

  fieldNames = memops.api.Implementation.ComplexDataType.fieldNames

  inConstructor = memops.api.Implementation.ComplexDataType.inConstructor

  isDeleted = memops.api.Implementation.MemopsObject.isDeleted

  lowerLimit = SingleConstraint.lowerLimit

  metaclass = memops.api.Implementation.ComplexDataType.metaclass

  origData = AbstractConstraint.origData

  packageName = memops.api.Implementation.ComplexDataType.packageName

  packageShortName = memops.api.Implementation.ComplexDataType.packageShortName

  qualifiedName = memops.api.Implementation.ComplexDataType.qualifiedName

  serial = AbstractConstraint.serial

  targetValue = SingleConstraint.targetValue

  upperLimit = SingleConstraint.upperLimit
  
  vectorLength = property(getVectorLength, setVectorLength, None,
  r"""Length of vector betwen coupled atoms - in Angstrom
  """)

  weight = AbstractConstraint.weight

  access = memops.api.Implementation.DataObject.access

  constraintGroups = AbstractConstraint.constraintGroups
  
  items = property(getItems,  None, None,
  r"""child link to class RdcConstraintItem
  """)

  method = AbstractConstraint.method

  nmrConstraintValidations = AbstractConstraint.nmrConstraintValidations
  
  parent = property(getParent, None, None,
  r"""link to parent object - synonym for parentList
  """)
  
  parentList = property(getParentList,  None, None,
  r"""parent link
  """)

  peakContribs = AbstractConstraint.peakContribs

  peaks = AbstractConstraint.peaks

  root = memops.api.Implementation.MemopsObject.root

  topObject = memops.api.Implementation.DataObject.topObject

  violations = AbstractConstraint.violations

###############################################################################
class ChemShiftConstraint(SingleConstraint):
  r"""Chemical shift constraint (shift value that must be reproduced by the 
structure).
  """
  #   from data model element ccp.nmr.NmrConstraint.ChemShiftConstraint revision 1.37.2.9
  _metaclass = metaPackage.getElement('ChemShiftConstraint')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('applicationData', 'className', 'details', 'error', 'fieldNames', 'inConstructor', 'isDeleted', 'lowerLimit', 'metaclass', 'origData', 'packageName', 'packageShortName', 'qualifiedName', 'serial', 'targetValue', 'upperLimit', 'weight', 'access', 'constraintGroups', 'method', 'nmrConstraintValidations', 'parent', 'parentList', 'peakContribs', 'peaks', 'resonance', 'root', 'topObject', 'violations',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccp.nmr.NmrConstraint.ChemShiftConstraint
    """
    dataDict = self.__dict__
    dataDict['parentList'] = parent
    if (not isinstance(parent, ChemShiftConstraintList)):
      raise ApiError("""%s.__init__:
       value is not of class ccp.nmr.NmrConstraint.ChemShiftConstraintList""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:

      dataDict['applicationData'] = list()
      dataDict['details'] = None
      dataDict['error'] = None
      dataDict['lowerLimit'] = None
      dataDict['origData'] = None
      dataDict['serial'] = None
      dataDict['targetValue'] = None
      dataDict['upperLimit'] = None
      dataDict['weight'] = 1.0
      dataDict['access'] = None
      dataDict['constraintGroups'] = set()
      dataDict['method'] = None
      dataDict['nmrConstraintValidations'] = set()
      dataDict['peakContribs'] = {}
      dataDict['resonance'] = None
      dataDict['violations'] = set()

      dataDict['inConstructor'] = True
      try:
        
        for key, value in attrlinks.iteritems():
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        del dataDict['inConstructor']
      except:
        print "ERROR in ccp.nmr.NmrConstraint.ChemShiftConstraint.__init__"
        del dataDict['inConstructor']
        raise

      if (notOverride):
        if (dataDict.get('serial') is None):
          dataDict['inConstructor'] = True
          self.setSerial(-1)
          del dataDict['inConstructor']
        else:
          raise ApiError("""%s.__init__:
           Cannot pass in explicit serial if not reading""" % self.qualifiedName
           + ": %s:%s" % (parent, 'ccp.nmr.NmrConstraint.ChemShiftConstraint')
          )

      if (notIsReading):
        childrenDict = parent.__dict__.get('constraints')
        objKey = dataDict.get('serial')
        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['serial'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        print '''WARNING Error in clean-up of incorrectly created object. 
        Data may be left in an illegal state'''
        del dataDict['inConstructor']
      raise exc_info[0], exc_info[1], exc_info[2]

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccp.nmr.NmrConstraint.ChemShiftConstraint:
       determines 
    cascading deletes to follow from delete of object.
       *Implementation 
    function* - should be called only by API delete function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
      dataDict.get('topObject').load()

    access = dataDict.get('access')
    if (access is not None):
      topObject = access.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    method = dataDict.get('method')
    if (method is not None):
      topObject = method.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    nmrConstraintValidations = dataDict.get('nmrConstraintValidations')
    pass
    for nmrConstraintValidation in nmrConstraintValidations:
      topObject = nmrConstraintValidation.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    peakContribs = dataDict.get('peakContribs').values()
    for peakContrib in peakContribs:
      if (not (peakContrib in objsToBeDeleted)):
        objsToBeDeleted.add(peakContrib)
        objsToBeChecked.append(peakContrib)

    violations = dataDict.get('violations')
    for violation in violations:
      if (not (violation in objsToBeDeleted)):
        objsToBeDeleted.add(violation)
        objsToBeChecked.append(violation)

    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccp.nmr.NmrConstraint.ChemShiftConstraint:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    access = dataDict.get('access')
    if ((access is not None and not (access in objsToBeDeleted))):
      dataObjects = access.__dict__.get('dataObjects')
      dataObjects.remove(self)

    for constraintGroup in dataDict.get('constraintGroups'):
      if (not (constraintGroup in objsToBeDeleted)):
        constraints = constraintGroup.__dict__.get('constraints')
        constraints.remove(self)

    method = dataDict.get('method')
    if ((method is not None and not (method in objsToBeDeleted))):
      constraints = method.__dict__.get('constraints')
      constraints.remove(self)

    for nmrConstraintValidation in dataDict.get('nmrConstraintValidations'):
      if (not (nmrConstraintValidation in objsToBeDeleted)):
        nmrConstraints = nmrConstraintValidation.__dict__.get('nmrConstraints')
        nmrConstraints.remove(self)

    resonance = dataDict.get('resonance')
    if ((resonance is not None and not (resonance in objsToBeDeleted))):
      chemShiftConstraints = resonance.__dict__.get('chemShiftConstraints')
      chemShiftConstraints.remove(self)

    parentList = dataDict.get('parentList')
    if (not (parentList in objsToBeDeleted)):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = parentList.__dict__.get('constraints')
        if (self is dd.get(objKey)):
          del dd[objKey]

  addApplicationData = memops.api.Implementation.DataObject.addApplicationData

  addConstraintGroup = AbstractConstraint.addConstraintGroup

  addNmrConstraintValidation = AbstractConstraint.addNmrConstraintValidation

  addPeak = AbstractConstraint.addPeak
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccp.nmr.NmrConstraint.ChemShiftConstraint
    """
    dataDict = self.__dict__
    self.checkValid(complete)
    values = dataDict.get('peakContribs').values()
    for value in values:
      value.checkAllValid(complete)

  def checkValid(self, complete=False):
    """
    CheckValid for ccp.nmr.NmrConstraint.ChemShiftConstraint
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('parentList')
        dd = value.__dict__.get('constraints')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'parentList' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from memops.api.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('details')
      if (value is not None):
        if (isinstance(value, memops.api.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: details:
           memops.Implementation.Text input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 254):
          raise ApiError("""%s.checkValid: details:
           memops.Implementation.Text maximum length is 254 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: details:
           memops.Implementation.Text: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('error')
      if (value is not None):
        if (isinstance(value, memops.api.Implementation.Float.PythonType)):
          pass
        elif ([x for x in memops.api.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = memops.api.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: error:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: error:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('lowerLimit')
      if (value is not None):
        if (isinstance(value, memops.api.Implementation.Float.PythonType)):
          pass
        elif ([x for x in memops.api.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = memops.api.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: lowerLimit:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: lowerLimit:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('origData')
      if (value is not None):
        if (isinstance(value, memops.api.Implementation.Float.PythonType)):
          pass
        elif ([x for x in memops.api.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = memops.api.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: origData:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: origData:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, memops.api.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('serial')
      if (value is None):
        raise ApiError("""%s.checkValid: serial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, memops.api.Implementation.Int.PythonType)):
        pass
      elif ([x for x in memops.api.Implementation.Int.compatibleTypes if isinstance(value, x)]):
        value = memops.api.Implementation.Int.create(value)
      else:
        raise ApiError("""%s.checkValid: serial:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('targetValue')
      if (value is not None):
        if (isinstance(value, memops.api.Implementation.Float.PythonType)):
          pass
        elif ([x for x in memops.api.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = memops.api.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: targetValue:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: targetValue:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('upperLimit')
      if (value is not None):
        if (isinstance(value, memops.api.Implementation.Float.PythonType)):
          pass
        elif ([x for x in memops.api.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = memops.api.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: upperLimit:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: upperLimit:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('weight')
      if (isinstance(value, memops.api.Implementation.Float.PythonType)):
        pass
      elif ([x for x in memops.api.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = memops.api.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.checkValid: weight:
         memops.Implementation.NonNegativeFloat input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (0.0 <= value)):
        raise ApiError("""%s.checkValid: weight:
         NonNegativeFloat constraint float_value_ge_0 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.checkValid: weight:
         NonNegativeFloat constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('access')
      if (value is not None):
        from memops.api.AccessControl import AccessObject as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: access:
           value is not of class memops.AccessControl.AccessObject""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('dataObjects')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: access:
           non-reciprocal link ChemShiftConstraint from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('constraintGroups')
      for value in values:
        if (not isinstance(value, ConstraintGroup)):
          raise ApiError("""%s.checkValid: constraintGroups:
           value is not of class ccp.nmr.NmrConstraint.ConstraintGroup""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('constraints')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: constraintGroups:
           non-reciprocal link ChemShiftConstraint from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: constraintGroups:
           Link constraintGroups between objects from separate partitions
           - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      value = dataDict.get('method')
      if (value is not None):
        from ccp.api.general.Method import Method as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: method:
           value is not of class ccp.general.Method.Method""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('constraints')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: method:
           non-reciprocal link ChemShiftConstraint from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('nmrConstraintValidations')
      for value in values:
        from ccp.api.molecule.Validation import NmrConstraintValidation as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: nmrConstraintValidations:
           value is not of class ccp.molecule.Validation.NmrConstraintValidation""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('nmrConstraints')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: nmrConstraintValidations:
           non-reciprocal link ChemShiftConstraint from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        yy2 = yy1.__dict__.get('nmrConstraintStore')
        if (not (xx1 is yy2)):
          raise ApiError("""%s.checkValid: nmrConstraintValidations:
           Link nmrConstraintValidations between objects from separate partitions
           - ccp.molecule.Validation.ValidationStore.nmrConstraintStore not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      value = dataDict.get('parentList')
      if (not isinstance(value, ChemShiftConstraintList)):
        raise ApiError("""%s.checkValid: parentList:
         value is not of class ccp.nmr.NmrConstraint.ChemShiftConstraintList""" % self.qualifiedName
         + ": %s" % (value,)
        )

      values = dataDict.get('peakContribs').values()
      for value in values:
        if (not isinstance(value, ConstraintPeakContrib)):
          raise ApiError("""%s.checkValid: peakContribs:
           value is not of class ccp.nmr.NmrConstraint.ConstraintPeakContrib""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('constraint')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: peakContribs:
           non-reciprocal link ChemShiftConstraint from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = self.getPeaks()
      for value in values:
        from ccp.api.nmr.Nmr import Peak as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: peaks:
           value is not of class ccp.nmr.Nmr.Peak""" % self.qualifiedName
           + ": %s" % (value,)
          )

        xx1 = dataDict.get('topObject')
        xx2 = xx1.__dict__.get('nmrProject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx2 is yy1)):
          raise ApiError("""%s.checkValid: peaks:
           Link peaks between objects from separate partitions
           - ccp.nmr.NmrConstraint.NmrConstraintStore.nmrProject not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      value = dataDict.get('resonance')
      if (not isinstance(value, FixedResonance)):
        raise ApiError("""%s.checkValid: resonance:
         value is not of class ccp.nmr.NmrConstraint.FixedResonance""" % self.qualifiedName
         + ": %s" % (value,)
        )

      oldSelves = value.__dict__.get('chemShiftConstraints')
      if (not (self in oldSelves)):
        raise ApiError("""%s.checkValid: resonance:
         non-reciprocal link ChemShiftConstraint from object""" % self.qualifiedName
         + ": %s" % (self,)
        )

      values = dataDict.get('violations')
      for value in values:
        if (not isinstance(value, Violation)):
          raise ApiError("""%s.checkValid: violations:
           value is not of class ccp.nmr.NmrConstraint.Violation""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('constraint')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: violations:
           non-reciprocal link ChemShiftConstraint from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: violations:
           Link violations between objects from separate partitions
           - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    # check explicit class constraints
    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('details')
    value = dataDict.get('error')
    value = dataDict.get('lowerLimit')
    value = dataDict.get('origData')
    value = dataDict.get('targetValue')
    value = dataDict.get('upperLimit')
    value = dataDict.get('weight')
    if (value is None):
      raise ApiError("""%s.checkValid: weight:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    # check roles
    value = dataDict.get('access')
    values = dataDict.get('constraintGroups')
    value = dataDict.get('method')
    values = dataDict.get('nmrConstraintValidations')
    for value in values:
      ll= value.keywordDefinition.targetNames
      isValid = (not ll or self.qualifiedName in ll)
      if (not (isValid)):
        raise ApiError("""%s.checkValid: nmrConstraintValidations:
         nmrConstraintValidations constraint KeywordDefinition_fits_Constraint violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    value = dataDict.get('parentList')
    if (value is None):
      raise ApiError("""%s.checkValid: parentList:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    values = dataDict.get('peakContribs').values()
    value = dataDict.get('resonance')
    if (value is None):
      raise ApiError("""%s.checkValid: resonance:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    if (not (value.isotopeCode == self.parentList.isotopeCode)):
      raise ApiError("""%s.checkValid: resonance:
       resonance constraint value_isotopeCode_eq_self_parentList_isotopeCode violated by value""" % self.qualifiedName
       + ": %s" % (value,)
      )

    values = dataDict.get('violations')

  delete = memops.api.Implementation.DataObject.delete

  findAllApplicationData = memops.api.Implementation.DataObject.findAllApplicationData

  findAllConstraintGroups = AbstractConstraint.findAllConstraintGroups

  findAllNmrConstraintValidations = AbstractConstraint.findAllNmrConstraintValidations

  findAllPeakContribs = AbstractConstraint.findAllPeakContribs

  findAllPeaks = AbstractConstraint.findAllPeaks

  findAllViolations = AbstractConstraint.findAllViolations

  findFirstApplicationData = memops.api.Implementation.DataObject.findFirstApplicationData

  findFirstConstraintGroup = AbstractConstraint.findFirstConstraintGroup

  findFirstNmrConstraintValidation = AbstractConstraint.findFirstNmrConstraintValidation

  findFirstPeak = AbstractConstraint.findFirstPeak

  findFirstPeakContrib = AbstractConstraint.findFirstPeakContrib

  findFirstViolation = AbstractConstraint.findFirstViolation
  
  def get(self, name):
    """
    GetAttr for ccp.nmr.NmrConstraint.ChemShiftConstraint
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getAccess = memops.api.Implementation.DataObject.getAccess

  getApplicationData = memops.api.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.ChemShiftConstraint
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (3 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.ChemShiftConstraint'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (2 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.ChemShiftConstraint'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-2]
      obj2 = obj1.__dict__.get('constraintLists').get(objKey)

      if (obj2 is not None):
        objKey = fullKey[-1]
        obj3 = obj2.__dict__.get('constraints').get(objKey)
        result = obj3

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = memops.api.Implementation.MemopsObject.getByNavigation

  getClassName = memops.api.Implementation.ComplexDataType.getClassName

  getConstraintGroups = AbstractConstraint.getConstraintGroups

  getDetails = AbstractConstraint.getDetails

  getError = SingleConstraint.getError

  getExpandedKey = memops.api.Implementation.MemopsObject.getExpandedKey

  getFieldNames = memops.api.Implementation.ComplexDataType.getFieldNames
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccp.nmr.NmrConstraint.ChemShiftConstraint
    """
    dataDict = self.__dict__
    result = list()

    obj2 = dataDict.get('parentList')
    obj1 = obj2.__dict__.get('nmrConstraintStore')

    if (useGuid):
      result.append(obj1.__dict__.get('guid'))
    else:
      result.append(obj1.__dict__.get('serial'))

    result.append(obj2.__dict__.get('serial'))
    result.append(dataDict.get('serial'))

    return result

  getInConstructor = memops.api.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = memops.api.Implementation.MemopsObject.getIsDeleted
  
  def getLocalKey(self):
    """
    GetLocalKey for ccp.nmr.NmrConstraint.ChemShiftConstraint
    """
    dataDict = self.__dict__
    result = dataDict.get('serial')
    return result

  getLowerLimit = SingleConstraint.getLowerLimit

  getMetaclass = memops.api.Implementation.ComplexDataType.getMetaclass

  getMethod = AbstractConstraint.getMethod

  getNmrConstraintValidations = AbstractConstraint.getNmrConstraintValidations

  getOrigData = AbstractConstraint.getOrigData

  getPackageName = memops.api.Implementation.ComplexDataType.getPackageName

  getPackageShortName = memops.api.Implementation.ComplexDataType.getPackageShortName
  
  def getParent(self):
    """
    Get for ccp.nmr.NmrConstraint.ChemShiftConstraint.parent
    """
    dataDict = self.__dict__
    result = dataDict.get('parentList')
    return result
  
  def getParentList(self):
    """
    Get for ccp.nmr.NmrConstraint.ChemShiftConstraint.parentList
    """
    dataDict = self.__dict__
    result = dataDict.get('parentList')
    return result

  getPeakContribs = AbstractConstraint.getPeakContribs

  getPeaks = AbstractConstraint.getPeaks

  getQualifiedName = memops.api.Implementation.ComplexDataType.getQualifiedName
  
  def getResonance(self):
    """
    Get for ccp.nmr.NmrConstraint.ChemShiftConstraint.resonance
    """
    dataDict = self.__dict__
    result = dataDict.get('resonance')
    return result

  getRoot = memops.api.Implementation.MemopsObject.getRoot

  getSerial = AbstractConstraint.getSerial

  getTargetValue = SingleConstraint.getTargetValue

  getTopObject = memops.api.Implementation.DataObject.getTopObject

  getUpperLimit = SingleConstraint.getUpperLimit

  getViolations = AbstractConstraint.getViolations

  getWeight = AbstractConstraint.getWeight

  newConstraintPeakContrib = AbstractConstraint.newConstraintPeakContrib

  removeApplicationData = memops.api.Implementation.DataObject.removeApplicationData

  removeConstraintGroup = AbstractConstraint.removeConstraintGroup

  removeNmrConstraintValidation = AbstractConstraint.removeNmrConstraintValidation

  removePeak = AbstractConstraint.removePeak
  
  def set(self, name, value):
    """
    SetAttr for ccp.nmr.NmrConstraint.ChemShiftConstraint
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setAccess = memops.api.Implementation.DataObject.setAccess

  setApplicationData = memops.api.Implementation.DataObject.setApplicationData

  setConstraintGroups = AbstractConstraint.setConstraintGroups

  setDetails = AbstractConstraint.setDetails

  setError = SingleConstraint.setError

  setLowerLimit = SingleConstraint.setLowerLimit

  setMethod = AbstractConstraint.setMethod

  setNmrConstraintValidations = AbstractConstraint.setNmrConstraintValidations

  setOrigData = AbstractConstraint.setOrigData

  setPeaks = AbstractConstraint.setPeaks
  
  def setResonance(self, value):
    """
    Set for ccp.nmr.NmrConstraint.ChemShiftConstraint.resonance
    """
    dataDict = self.__dict__
    if (not isinstance(value, FixedResonance)):
      raise ApiError("""%s.setResonance:
       value is not of class ccp.nmr.NmrConstraint.FixedResonance""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('resonance')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setResonance:
       called on deleted object""" % self.qualifiedName
      )

    if (value is not None):
      if (value.__dict__.get('isDeleted')):
        raise ApiError("""%s.setResonance:
         called with deleted value""" % self.qualifiedName
        )

    if (value == currentValue):
      return

    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setResonance:
         cannot set resonance, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is None):
        raise ApiError("""%s.setResonance:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      xx1 = dataDict.get('topObject')
      yy1 = value.__dict__.get('topObject')
      if (not (xx1 is yy1)):
        raise ApiError("""%s.setResonance:
         Link resonance between objects from separate partitions
         - memops.Implementation.TopObject does not match""" % self.qualifiedName
         + ": %s:%s" % (self, value)
        )

      if (notInConstructor):
        if (value is not None):
          if (not (value.isotopeCode == self.parentList.isotopeCode)):
            raise ApiError("""%s.setResonance:
             resonance constraint value_isotopeCode_eq_self_parentList_isotopeCode violated by value""" % self.qualifiedName
             + ": %s" % (value,)
            )

    if (currentValue is not None):
      if (notIsReading):
        oldSelves = currentValue.__dict__.get('chemShiftConstraints')
        oldSelves.remove(self)
      else:
        raise ApiError("""%s.setResonance:
         Read link 'resonance' incompatible with pre-existing link""" % self.qualifiedName
         + ": %s" % (self,)
        )

    if (value is not None):
      newSelves = value.__dict__.get('chemShiftConstraints')
      newSelves.add(self)

    dataDict['resonance'] = value

    # doNotifies

  setSerial = AbstractConstraint.setSerial

  setTargetValue = SingleConstraint.setTargetValue

  setUpperLimit = SingleConstraint.setUpperLimit

  setViolations = AbstractConstraint.setViolations

  setWeight = AbstractConstraint.setWeight

  sortedConstraintGroups = AbstractConstraint.sortedConstraintGroups

  sortedNmrConstraintValidations = AbstractConstraint.sortedNmrConstraintValidations

  sortedPeakContribs = AbstractConstraint.sortedPeakContribs

  sortedPeaks = AbstractConstraint.sortedPeaks

  sortedViolations = AbstractConstraint.sortedViolations

  toDetailedString = memops.api.Implementation.ComplexDataType.toDetailedString

  applicationData = memops.api.Implementation.DataObject.applicationData

  className = memops.api.Implementation.ComplexDataType.className

  details = AbstractConstraint.details

  error = SingleConstraint.error

  fieldNames = memops.api.Implementation.ComplexDataType.fieldNames

  inConstructor = memops.api.Implementation.ComplexDataType.inConstructor

  isDeleted = memops.api.Implementation.MemopsObject.isDeleted

  lowerLimit = SingleConstraint.lowerLimit

  metaclass = memops.api.Implementation.ComplexDataType.metaclass

  origData = AbstractConstraint.origData

  packageName = memops.api.Implementation.ComplexDataType.packageName

  packageShortName = memops.api.Implementation.ComplexDataType.packageShortName

  qualifiedName = memops.api.Implementation.ComplexDataType.qualifiedName

  serial = AbstractConstraint.serial

  targetValue = SingleConstraint.targetValue

  upperLimit = SingleConstraint.upperLimit

  weight = AbstractConstraint.weight

  access = memops.api.Implementation.DataObject.access

  constraintGroups = AbstractConstraint.constraintGroups

  method = AbstractConstraint.method

  nmrConstraintValidations = AbstractConstraint.nmrConstraintValidations
  
  parent = property(getParent, None, None,
  r"""link to parent object - synonym for parentList
  """)
  
  parentList = property(getParentList,  None, None,
  r"""parent link
  """)

  peakContribs = AbstractConstraint.peakContribs

  peaks = AbstractConstraint.peaks
  
  resonance = property(getResonance, setResonance, None,
  r"""FixedResonance holding Chemical shift constraint.
  """)

  root = memops.api.Implementation.MemopsObject.root

  topObject = memops.api.Implementation.DataObject.topObject

  violations = AbstractConstraint.violations

###############################################################################
class JCouplingConstraint(SingleConstraint):
  r"""J coupling constraint. Ambiguous, may contain several 
JCouplingConstraintItems, each with a different assignment, describing 
alternative assignment possibilities.
  """
  #   from data model element ccp.nmr.NmrConstraint.JCouplingConstraint revision 1.36.2.9
  _metaclass = metaPackage.getElement('JCouplingConstraint')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('applicationData', 'className', 'details', 'error', 'fieldNames', 'inConstructor', 'isDeleted', 'lowerLimit', 'metaclass', 'origData', 'packageName', 'packageShortName', 'qualifiedName', 'serial', 'targetValue', 'upperLimit', 'weight', 'access', 'constraintGroups', 'items', 'method', 'nmrConstraintValidations', 'parent', 'parentList', 'peakContribs', 'peaks', 'root', 'topObject', 'violations',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccp.nmr.NmrConstraint.JCouplingConstraint
    """
    dataDict = self.__dict__
    dataDict['parentList'] = parent
    if (not isinstance(parent, JCouplingConstraintList)):
      raise ApiError("""%s.__init__:
       value is not of class ccp.nmr.NmrConstraint.JCouplingConstraintList""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:

      dataDict['applicationData'] = list()
      dataDict['details'] = None
      dataDict['error'] = None
      dataDict['lowerLimit'] = None
      dataDict['origData'] = None
      dataDict['serial'] = None
      dataDict['targetValue'] = None
      dataDict['upperLimit'] = None
      dataDict['weight'] = 1.0
      dataDict['access'] = None
      dataDict['constraintGroups'] = set()
      dataDict['items'] = {}
      dataDict['method'] = None
      dataDict['nmrConstraintValidations'] = set()
      dataDict['peakContribs'] = {}
      dataDict['violations'] = set()

      dataDict['inConstructor'] = True
      try:
        
        for key, value in attrlinks.iteritems():
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        del dataDict['inConstructor']
      except:
        print "ERROR in ccp.nmr.NmrConstraint.JCouplingConstraint.__init__"
        del dataDict['inConstructor']
        raise

      if (notOverride):
        if (dataDict.get('serial') is None):
          dataDict['inConstructor'] = True
          self.setSerial(-1)
          del dataDict['inConstructor']
        else:
          raise ApiError("""%s.__init__:
           Cannot pass in explicit serial if not reading""" % self.qualifiedName
           + ": %s:%s" % (parent, 'ccp.nmr.NmrConstraint.JCouplingConstraint')
          )

      if (notIsReading):
        childrenDict = parent.__dict__.get('constraints')
        objKey = dataDict.get('serial')
        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['serial'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        print '''WARNING Error in clean-up of incorrectly created object. 
        Data may be left in an illegal state'''
        del dataDict['inConstructor']
      raise exc_info[0], exc_info[1], exc_info[2]

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccp.nmr.NmrConstraint.JCouplingConstraint:
       determines 
    cascading deletes to follow from delete of object.
       *Implementation 
    function* - should be called only by API delete function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
      dataDict.get('topObject').load()

    access = dataDict.get('access')
    if (access is not None):
      topObject = access.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    items = dataDict.get('items').values()
    for item in items:
      if (not (item in objsToBeDeleted)):
        objsToBeDeleted.add(item)
        objsToBeChecked.append(item)

    method = dataDict.get('method')
    if (method is not None):
      topObject = method.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    nmrConstraintValidations = dataDict.get('nmrConstraintValidations')
    pass
    for nmrConstraintValidation in nmrConstraintValidations:
      topObject = nmrConstraintValidation.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    peakContribs = dataDict.get('peakContribs').values()
    for peakContrib in peakContribs:
      if (not (peakContrib in objsToBeDeleted)):
        objsToBeDeleted.add(peakContrib)
        objsToBeChecked.append(peakContrib)

    violations = dataDict.get('violations')
    for violation in violations:
      if (not (violation in objsToBeDeleted)):
        objsToBeDeleted.add(violation)
        objsToBeChecked.append(violation)

    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccp.nmr.NmrConstraint.JCouplingConstraint:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    access = dataDict.get('access')
    if ((access is not None and not (access in objsToBeDeleted))):
      dataObjects = access.__dict__.get('dataObjects')
      dataObjects.remove(self)

    for constraintGroup in dataDict.get('constraintGroups'):
      if (not (constraintGroup in objsToBeDeleted)):
        constraints = constraintGroup.__dict__.get('constraints')
        constraints.remove(self)

    method = dataDict.get('method')
    if ((method is not None and not (method in objsToBeDeleted))):
      constraints = method.__dict__.get('constraints')
      constraints.remove(self)

    for nmrConstraintValidation in dataDict.get('nmrConstraintValidations'):
      if (not (nmrConstraintValidation in objsToBeDeleted)):
        nmrConstraints = nmrConstraintValidation.__dict__.get('nmrConstraints')
        nmrConstraints.remove(self)

    parentList = dataDict.get('parentList')
    if (not (parentList in objsToBeDeleted)):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = parentList.__dict__.get('constraints')
        if (self is dd.get(objKey)):
          del dd[objKey]

  addApplicationData = memops.api.Implementation.DataObject.addApplicationData

  addConstraintGroup = AbstractConstraint.addConstraintGroup

  addNmrConstraintValidation = AbstractConstraint.addNmrConstraintValidation

  addPeak = AbstractConstraint.addPeak
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccp.nmr.NmrConstraint.JCouplingConstraint
    """
    dataDict = self.__dict__
    self.checkValid(complete)
    values = dataDict.get('items').values()
    for value in values:
      value.checkAllValid(complete)

    values = dataDict.get('peakContribs').values()
    for value in values:
      value.checkAllValid(complete)

  def checkValid(self, complete=False):
    """
    CheckValid for ccp.nmr.NmrConstraint.JCouplingConstraint
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('parentList')
        dd = value.__dict__.get('constraints')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'parentList' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from memops.api.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('details')
      if (value is not None):
        if (isinstance(value, memops.api.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: details:
           memops.Implementation.Text input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 254):
          raise ApiError("""%s.checkValid: details:
           memops.Implementation.Text maximum length is 254 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: details:
           memops.Implementation.Text: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('error')
      if (value is not None):
        if (isinstance(value, memops.api.Implementation.Float.PythonType)):
          pass
        elif ([x for x in memops.api.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = memops.api.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: error:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: error:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('lowerLimit')
      if (value is not None):
        if (isinstance(value, memops.api.Implementation.Float.PythonType)):
          pass
        elif ([x for x in memops.api.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = memops.api.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: lowerLimit:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: lowerLimit:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('origData')
      if (value is not None):
        if (isinstance(value, memops.api.Implementation.Float.PythonType)):
          pass
        elif ([x for x in memops.api.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = memops.api.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: origData:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: origData:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, memops.api.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('serial')
      if (value is None):
        raise ApiError("""%s.checkValid: serial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, memops.api.Implementation.Int.PythonType)):
        pass
      elif ([x for x in memops.api.Implementation.Int.compatibleTypes if isinstance(value, x)]):
        value = memops.api.Implementation.Int.create(value)
      else:
        raise ApiError("""%s.checkValid: serial:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('targetValue')
      if (value is not None):
        if (isinstance(value, memops.api.Implementation.Float.PythonType)):
          pass
        elif ([x for x in memops.api.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = memops.api.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: targetValue:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: targetValue:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('upperLimit')
      if (value is not None):
        if (isinstance(value, memops.api.Implementation.Float.PythonType)):
          pass
        elif ([x for x in memops.api.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = memops.api.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: upperLimit:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: upperLimit:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('weight')
      if (isinstance(value, memops.api.Implementation.Float.PythonType)):
        pass
      elif ([x for x in memops.api.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = memops.api.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.checkValid: weight:
         memops.Implementation.NonNegativeFloat input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (0.0 <= value)):
        raise ApiError("""%s.checkValid: weight:
         NonNegativeFloat constraint float_value_ge_0 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.checkValid: weight:
         NonNegativeFloat constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('access')
      if (value is not None):
        from memops.api.AccessControl import AccessObject as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: access:
           value is not of class memops.AccessControl.AccessObject""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('dataObjects')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: access:
           non-reciprocal link JCouplingConstraint from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('constraintGroups')
      for value in values:
        if (not isinstance(value, ConstraintGroup)):
          raise ApiError("""%s.checkValid: constraintGroups:
           value is not of class ccp.nmr.NmrConstraint.ConstraintGroup""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('constraints')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: constraintGroups:
           non-reciprocal link JCouplingConstraint from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: constraintGroups:
           Link constraintGroups between objects from separate partitions
           - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = dataDict.get('items').values()
      for value in values:
        if (not isinstance(value, JCouplingConstraintItem)):
          raise ApiError("""%s.checkValid: items:
           value is not of class ccp.nmr.NmrConstraint.JCouplingConstraintItem""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('constraint')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: items:
           non-reciprocal link JCouplingConstraint from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      value = dataDict.get('method')
      if (value is not None):
        from ccp.api.general.Method import Method as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: method:
           value is not of class ccp.general.Method.Method""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('constraints')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: method:
           non-reciprocal link JCouplingConstraint from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('nmrConstraintValidations')
      for value in values:
        from ccp.api.molecule.Validation import NmrConstraintValidation as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: nmrConstraintValidations:
           value is not of class ccp.molecule.Validation.NmrConstraintValidation""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('nmrConstraints')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: nmrConstraintValidations:
           non-reciprocal link JCouplingConstraint from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        yy2 = yy1.__dict__.get('nmrConstraintStore')
        if (not (xx1 is yy2)):
          raise ApiError("""%s.checkValid: nmrConstraintValidations:
           Link nmrConstraintValidations between objects from separate partitions
           - ccp.molecule.Validation.ValidationStore.nmrConstraintStore not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      value = dataDict.get('parentList')
      if (not isinstance(value, JCouplingConstraintList)):
        raise ApiError("""%s.checkValid: parentList:
         value is not of class ccp.nmr.NmrConstraint.JCouplingConstraintList""" % self.qualifiedName
         + ": %s" % (value,)
        )

      values = dataDict.get('peakContribs').values()
      for value in values:
        if (not isinstance(value, ConstraintPeakContrib)):
          raise ApiError("""%s.checkValid: peakContribs:
           value is not of class ccp.nmr.NmrConstraint.ConstraintPeakContrib""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('constraint')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: peakContribs:
           non-reciprocal link JCouplingConstraint from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = self.getPeaks()
      for value in values:
        from ccp.api.nmr.Nmr import Peak as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: peaks:
           value is not of class ccp.nmr.Nmr.Peak""" % self.qualifiedName
           + ": %s" % (value,)
          )

        xx1 = dataDict.get('topObject')
        xx2 = xx1.__dict__.get('nmrProject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx2 is yy1)):
          raise ApiError("""%s.checkValid: peaks:
           Link peaks between objects from separate partitions
           - ccp.nmr.NmrConstraint.NmrConstraintStore.nmrProject not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = dataDict.get('violations')
      for value in values:
        if (not isinstance(value, Violation)):
          raise ApiError("""%s.checkValid: violations:
           value is not of class ccp.nmr.NmrConstraint.Violation""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('constraint')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: violations:
           non-reciprocal link JCouplingConstraint from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: violations:
           Link violations between objects from separate partitions
           - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    # check explicit class constraints
    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('details')
    value = dataDict.get('error')
    value = dataDict.get('lowerLimit')
    value = dataDict.get('origData')
    value = dataDict.get('targetValue')
    value = dataDict.get('upperLimit')
    value = dataDict.get('weight')
    if (value is None):
      raise ApiError("""%s.checkValid: weight:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    # check roles
    value = dataDict.get('access')
    values = dataDict.get('constraintGroups')
    values = dataDict.get('items').values()
    value = dataDict.get('method')
    values = dataDict.get('nmrConstraintValidations')
    for value in values:
      ll= value.keywordDefinition.targetNames
      isValid = (not ll or self.qualifiedName in ll)
      if (not (isValid)):
        raise ApiError("""%s.checkValid: nmrConstraintValidations:
         nmrConstraintValidations constraint KeywordDefinition_fits_Constraint violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    value = dataDict.get('parentList')
    if (value is None):
      raise ApiError("""%s.checkValid: parentList:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    values = dataDict.get('peakContribs').values()
    values = dataDict.get('violations')

  delete = memops.api.Implementation.DataObject.delete

  findAllApplicationData = memops.api.Implementation.DataObject.findAllApplicationData

  findAllConstraintGroups = AbstractConstraint.findAllConstraintGroups
  
  def findAllItems(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.JCouplingConstraint.items
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('items').values()
      result = set(currentValues)

    else:
      currentValues = dataDict.get('items').values()
      result = set()
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('access', 'constraint', 'firstResonance',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result.add(v)

    return result

  findAllNmrConstraintValidations = AbstractConstraint.findAllNmrConstraintValidations

  findAllPeakContribs = AbstractConstraint.findAllPeakContribs

  findAllPeaks = AbstractConstraint.findAllPeaks

  findAllViolations = AbstractConstraint.findAllViolations

  findFirstApplicationData = memops.api.Implementation.DataObject.findFirstApplicationData

  findFirstConstraintGroup = AbstractConstraint.findFirstConstraintGroup
  
  def findFirstItem(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.JCouplingConstraint.items
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('items').values()
      if (currentValues):
        result = iter(currentValues).next()
      else:
        result = None

    else:
      objKey = conditions.get('resonances')
      if (objKey is not None):
        objKey = frozenset(objKey)

      if (objKey is not None):
        result = dataDict.get('items').get(objKey)

        if (result is None):
          return result

        elif (len(conditions) <= 1):
          return result

        else:
          currentValues = set()
          currentValues.add(result)

      else:
        currentValues = dataDict.get('items').values()

      result = None
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('access', 'constraint', 'firstResonance',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result = v; break

    return result

  findFirstNmrConstraintValidation = AbstractConstraint.findFirstNmrConstraintValidation

  findFirstPeak = AbstractConstraint.findFirstPeak

  findFirstPeakContrib = AbstractConstraint.findFirstPeakContrib

  findFirstViolation = AbstractConstraint.findFirstViolation
  
  def get(self, name):
    """
    GetAttr for ccp.nmr.NmrConstraint.JCouplingConstraint
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getAccess = memops.api.Implementation.DataObject.getAccess

  getApplicationData = memops.api.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.JCouplingConstraint
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (3 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.JCouplingConstraint'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (2 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.JCouplingConstraint'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-2]
      obj2 = obj1.__dict__.get('constraintLists').get(objKey)

      if (obj2 is not None):
        objKey = fullKey[-1]
        obj3 = obj2.__dict__.get('constraints').get(objKey)
        result = obj3

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = memops.api.Implementation.MemopsObject.getByNavigation

  getClassName = memops.api.Implementation.ComplexDataType.getClassName

  getConstraintGroups = AbstractConstraint.getConstraintGroups

  getDetails = AbstractConstraint.getDetails

  getError = SingleConstraint.getError

  getExpandedKey = memops.api.Implementation.MemopsObject.getExpandedKey

  getFieldNames = memops.api.Implementation.ComplexDataType.getFieldNames
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccp.nmr.NmrConstraint.JCouplingConstraint
    """
    dataDict = self.__dict__
    result = list()

    obj2 = dataDict.get('parentList')
    obj1 = obj2.__dict__.get('nmrConstraintStore')

    if (useGuid):
      result.append(obj1.__dict__.get('guid'))
    else:
      result.append(obj1.__dict__.get('serial'))

    result.append(obj2.__dict__.get('serial'))
    result.append(dataDict.get('serial'))

    return result

  getInConstructor = memops.api.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = memops.api.Implementation.MemopsObject.getIsDeleted
  
  def getItems(self):
    """
    Get for ccp.nmr.NmrConstraint.JCouplingConstraint.items
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('items').values()
    result = frozenset(tempVar)
    return result
  
  def getLocalKey(self):
    """
    GetLocalKey for ccp.nmr.NmrConstraint.JCouplingConstraint
    """
    dataDict = self.__dict__
    result = dataDict.get('serial')
    return result

  getLowerLimit = SingleConstraint.getLowerLimit

  getMetaclass = memops.api.Implementation.ComplexDataType.getMetaclass

  getMethod = AbstractConstraint.getMethod

  getNmrConstraintValidations = AbstractConstraint.getNmrConstraintValidations

  getOrigData = AbstractConstraint.getOrigData

  getPackageName = memops.api.Implementation.ComplexDataType.getPackageName

  getPackageShortName = memops.api.Implementation.ComplexDataType.getPackageShortName
  
  def getParent(self):
    """
    Get for ccp.nmr.NmrConstraint.JCouplingConstraint.parent
    """
    dataDict = self.__dict__
    result = dataDict.get('parentList')
    return result
  
  def getParentList(self):
    """
    Get for ccp.nmr.NmrConstraint.JCouplingConstraint.parentList
    """
    dataDict = self.__dict__
    result = dataDict.get('parentList')
    return result

  getPeakContribs = AbstractConstraint.getPeakContribs

  getPeaks = AbstractConstraint.getPeaks

  getQualifiedName = memops.api.Implementation.ComplexDataType.getQualifiedName

  getRoot = memops.api.Implementation.MemopsObject.getRoot

  getSerial = AbstractConstraint.getSerial

  getTargetValue = SingleConstraint.getTargetValue

  getTopObject = memops.api.Implementation.DataObject.getTopObject

  getUpperLimit = SingleConstraint.getUpperLimit

  getViolations = AbstractConstraint.getViolations

  getWeight = AbstractConstraint.getWeight

  newConstraintPeakContrib = AbstractConstraint.newConstraintPeakContrib
  
  def newJCouplingConstraintItem(self, **attrlinks):
    """
    Factory function to create ccp.nmr.NmrConstraint.JCouplingConstraintItem
    """
    return JCouplingConstraintItem(self, **attrlinks)

  removeApplicationData = memops.api.Implementation.DataObject.removeApplicationData

  removeConstraintGroup = AbstractConstraint.removeConstraintGroup

  removeNmrConstraintValidation = AbstractConstraint.removeNmrConstraintValidation

  removePeak = AbstractConstraint.removePeak
  
  def set(self, name, value):
    """
    SetAttr for ccp.nmr.NmrConstraint.JCouplingConstraint
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setAccess = memops.api.Implementation.DataObject.setAccess

  setApplicationData = memops.api.Implementation.DataObject.setApplicationData

  setConstraintGroups = AbstractConstraint.setConstraintGroups

  setDetails = AbstractConstraint.setDetails

  setError = SingleConstraint.setError

  setLowerLimit = SingleConstraint.setLowerLimit

  setMethod = AbstractConstraint.setMethod

  setNmrConstraintValidations = AbstractConstraint.setNmrConstraintValidations

  setOrigData = AbstractConstraint.setOrigData

  setPeaks = AbstractConstraint.setPeaks

  setSerial = AbstractConstraint.setSerial

  setTargetValue = SingleConstraint.setTargetValue

  setUpperLimit = SingleConstraint.setUpperLimit

  setViolations = AbstractConstraint.setViolations

  setWeight = AbstractConstraint.setWeight

  sortedConstraintGroups = AbstractConstraint.sortedConstraintGroups
  
  def sortedItems(self):
    """
    Sorted for ccp.nmr.NmrConstraint.JCouplingConstraint.items
    """
    dataDict = self.__dict__
    sortdd = dataDict.get('items')
    
    ll = sortdd.keys()
    ll.sort()
    result = [sortdd[x] for x in ll]
    return result

  sortedNmrConstraintValidations = AbstractConstraint.sortedNmrConstraintValidations

  sortedPeakContribs = AbstractConstraint.sortedPeakContribs

  sortedPeaks = AbstractConstraint.sortedPeaks

  sortedViolations = AbstractConstraint.sortedViolations

  toDetailedString = memops.api.Implementation.ComplexDataType.toDetailedString

  applicationData = memops.api.Implementation.DataObject.applicationData

  className = memops.api.Implementation.ComplexDataType.className

  details = AbstractConstraint.details

  error = SingleConstraint.error

  fieldNames = memops.api.Implementation.ComplexDataType.fieldNames

  inConstructor = memops.api.Implementation.ComplexDataType.inConstructor

  isDeleted = memops.api.Implementation.MemopsObject.isDeleted

  lowerLimit = SingleConstraint.lowerLimit

  metaclass = memops.api.Implementation.ComplexDataType.metaclass

  origData = AbstractConstraint.origData

  packageName = memops.api.Implementation.ComplexDataType.packageName

  packageShortName = memops.api.Implementation.ComplexDataType.packageShortName

  qualifiedName = memops.api.Implementation.ComplexDataType.qualifiedName

  serial = AbstractConstraint.serial

  targetValue = SingleConstraint.targetValue

  upperLimit = SingleConstraint.upperLimit

  weight = AbstractConstraint.weight

  access = memops.api.Implementation.DataObject.access

  constraintGroups = AbstractConstraint.constraintGroups
  
  items = property(getItems,  None, None,
  r"""child link to class JCouplingConstraintItem
  """)

  method = AbstractConstraint.method

  nmrConstraintValidations = AbstractConstraint.nmrConstraintValidations
  
  parent = property(getParent, None, None,
  r"""link to parent object - synonym for parentList
  """)
  
  parentList = property(getParentList,  None, None,
  r"""parent link
  """)

  peakContribs = AbstractConstraint.peakContribs

  peaks = AbstractConstraint.peaks

  root = memops.api.Implementation.MemopsObject.root

  topObject = memops.api.Implementation.DataObject.topObject

  violations = AbstractConstraint.violations

###############################################################################
class DistanceConstraint(SingleConstraint):
  r"""Distance Constraint. Ambiguous, may contain several 
HBondConstraintItems, each with a different assignment, describing 
alternative assignment possibilities.
  """
  #   from data model element ccp.nmr.NmrConstraint.DistanceConstraint revision 1.36.2.9
  _metaclass = metaPackage.getElement('DistanceConstraint')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('applicationData', 'backCalcVolume', 'className', 'details', 'error', 'fieldNames', 'inConstructor', 'isDeleted', 'lowerLimit', 'metaclass', 'origData', 'packageName', 'packageShortName', 'qualifiedName', 'serial', 'targetValue', 'upperLimit', 'weight', 'access', 'constraintGroups', 'items', 'method', 'nmrConstraintValidations', 'parent', 'parentList', 'peakContribs', 'peaks', 'root', 'topObject', 'violations',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccp.nmr.NmrConstraint.DistanceConstraint
    """
    dataDict = self.__dict__
    dataDict['parentList'] = parent
    if (not isinstance(parent, DistanceConstraintList)):
      raise ApiError("""%s.__init__:
       value is not of class ccp.nmr.NmrConstraint.DistanceConstraintList""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:

      dataDict['applicationData'] = list()
      dataDict['backCalcVolume'] = None
      dataDict['details'] = None
      dataDict['error'] = None
      dataDict['lowerLimit'] = None
      dataDict['origData'] = None
      dataDict['serial'] = None
      dataDict['targetValue'] = None
      dataDict['upperLimit'] = None
      dataDict['weight'] = 1.0
      dataDict['access'] = None
      dataDict['constraintGroups'] = set()
      dataDict['items'] = {}
      dataDict['method'] = None
      dataDict['nmrConstraintValidations'] = set()
      dataDict['peakContribs'] = {}
      dataDict['violations'] = set()

      dataDict['inConstructor'] = True
      try:
        
        for key, value in attrlinks.iteritems():
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        del dataDict['inConstructor']
      except:
        print "ERROR in ccp.nmr.NmrConstraint.DistanceConstraint.__init__"
        del dataDict['inConstructor']
        raise

      if (notOverride):
        if (dataDict.get('serial') is None):
          dataDict['inConstructor'] = True
          self.setSerial(-1)
          del dataDict['inConstructor']
        else:
          raise ApiError("""%s.__init__:
           Cannot pass in explicit serial if not reading""" % self.qualifiedName
           + ": %s:%s" % (parent, 'ccp.nmr.NmrConstraint.DistanceConstraint')
          )

      if (notIsReading):
        childrenDict = parent.__dict__.get('constraints')
        objKey = dataDict.get('serial')
        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['serial'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        print '''WARNING Error in clean-up of incorrectly created object. 
        Data may be left in an illegal state'''
        del dataDict['inConstructor']
      raise exc_info[0], exc_info[1], exc_info[2]

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccp.nmr.NmrConstraint.DistanceConstraint:
       determines 
    cascading deletes to follow from delete of object.
       *Implementation 
    function* - should be called only by API delete function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
      dataDict.get('topObject').load()

    access = dataDict.get('access')
    if (access is not None):
      topObject = access.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    items = dataDict.get('items').values()
    for item in items:
      if (not (item in objsToBeDeleted)):
        objsToBeDeleted.add(item)
        objsToBeChecked.append(item)

    method = dataDict.get('method')
    if (method is not None):
      topObject = method.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    nmrConstraintValidations = dataDict.get('nmrConstraintValidations')
    pass
    for nmrConstraintValidation in nmrConstraintValidations:
      topObject = nmrConstraintValidation.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    peakContribs = dataDict.get('peakContribs').values()
    for peakContrib in peakContribs:
      if (not (peakContrib in objsToBeDeleted)):
        objsToBeDeleted.add(peakContrib)
        objsToBeChecked.append(peakContrib)

    violations = dataDict.get('violations')
    for violation in violations:
      if (not (violation in objsToBeDeleted)):
        objsToBeDeleted.add(violation)
        objsToBeChecked.append(violation)

    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccp.nmr.NmrConstraint.DistanceConstraint:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    access = dataDict.get('access')
    if ((access is not None and not (access in objsToBeDeleted))):
      dataObjects = access.__dict__.get('dataObjects')
      dataObjects.remove(self)

    for constraintGroup in dataDict.get('constraintGroups'):
      if (not (constraintGroup in objsToBeDeleted)):
        constraints = constraintGroup.__dict__.get('constraints')
        constraints.remove(self)

    method = dataDict.get('method')
    if ((method is not None and not (method in objsToBeDeleted))):
      constraints = method.__dict__.get('constraints')
      constraints.remove(self)

    for nmrConstraintValidation in dataDict.get('nmrConstraintValidations'):
      if (not (nmrConstraintValidation in objsToBeDeleted)):
        nmrConstraints = nmrConstraintValidation.__dict__.get('nmrConstraints')
        nmrConstraints.remove(self)

    parentList = dataDict.get('parentList')
    if (not (parentList in objsToBeDeleted)):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = parentList.__dict__.get('constraints')
        if (self is dd.get(objKey)):
          del dd[objKey]

  addApplicationData = memops.api.Implementation.DataObject.addApplicationData

  addConstraintGroup = AbstractConstraint.addConstraintGroup

  addNmrConstraintValidation = AbstractConstraint.addNmrConstraintValidation

  addPeak = AbstractConstraint.addPeak
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccp.nmr.NmrConstraint.DistanceConstraint
    """
    dataDict = self.__dict__
    self.checkValid(complete)
    values = dataDict.get('items').values()
    for value in values:
      value.checkAllValid(complete)

    values = dataDict.get('peakContribs').values()
    for value in values:
      value.checkAllValid(complete)

  def checkValid(self, complete=False):
    """
    CheckValid for ccp.nmr.NmrConstraint.DistanceConstraint
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('parentList')
        dd = value.__dict__.get('constraints')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'parentList' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from memops.api.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('backCalcVolume')
      if (value is not None):
        if (isinstance(value, memops.api.Implementation.Float.PythonType)):
          pass
        elif ([x for x in memops.api.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = memops.api.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: backCalcVolume:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: backCalcVolume:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('details')
      if (value is not None):
        if (isinstance(value, memops.api.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: details:
           memops.Implementation.Text input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 254):
          raise ApiError("""%s.checkValid: details:
           memops.Implementation.Text maximum length is 254 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: details:
           memops.Implementation.Text: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('error')
      if (value is not None):
        if (isinstance(value, memops.api.Implementation.Float.PythonType)):
          pass
        elif ([x for x in memops.api.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = memops.api.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: error:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: error:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('lowerLimit')
      if (value is not None):
        if (isinstance(value, memops.api.Implementation.Float.PythonType)):
          pass
        elif ([x for x in memops.api.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = memops.api.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: lowerLimit:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: lowerLimit:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('origData')
      if (value is not None):
        if (isinstance(value, memops.api.Implementation.Float.PythonType)):
          pass
        elif ([x for x in memops.api.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = memops.api.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: origData:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: origData:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, memops.api.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('serial')
      if (value is None):
        raise ApiError("""%s.checkValid: serial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, memops.api.Implementation.Int.PythonType)):
        pass
      elif ([x for x in memops.api.Implementation.Int.compatibleTypes if isinstance(value, x)]):
        value = memops.api.Implementation.Int.create(value)
      else:
        raise ApiError("""%s.checkValid: serial:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('targetValue')
      if (value is not None):
        if (isinstance(value, memops.api.Implementation.Float.PythonType)):
          pass
        elif ([x for x in memops.api.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = memops.api.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: targetValue:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: targetValue:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('upperLimit')
      if (value is not None):
        if (isinstance(value, memops.api.Implementation.Float.PythonType)):
          pass
        elif ([x for x in memops.api.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = memops.api.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: upperLimit:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: upperLimit:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('weight')
      if (isinstance(value, memops.api.Implementation.Float.PythonType)):
        pass
      elif ([x for x in memops.api.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = memops.api.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.checkValid: weight:
         memops.Implementation.NonNegativeFloat input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (0.0 <= value)):
        raise ApiError("""%s.checkValid: weight:
         NonNegativeFloat constraint float_value_ge_0 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.checkValid: weight:
         NonNegativeFloat constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('access')
      if (value is not None):
        from memops.api.AccessControl import AccessObject as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: access:
           value is not of class memops.AccessControl.AccessObject""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('dataObjects')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: access:
           non-reciprocal link DistanceConstraint from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('constraintGroups')
      for value in values:
        if (not isinstance(value, ConstraintGroup)):
          raise ApiError("""%s.checkValid: constraintGroups:
           value is not of class ccp.nmr.NmrConstraint.ConstraintGroup""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('constraints')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: constraintGroups:
           non-reciprocal link DistanceConstraint from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: constraintGroups:
           Link constraintGroups between objects from separate partitions
           - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = dataDict.get('items').values()
      for value in values:
        if (not isinstance(value, DistanceConstraintItem)):
          raise ApiError("""%s.checkValid: items:
           value is not of class ccp.nmr.NmrConstraint.DistanceConstraintItem""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('constraint')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: items:
           non-reciprocal link DistanceConstraint from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      value = dataDict.get('method')
      if (value is not None):
        from ccp.api.general.Method import Method as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: method:
           value is not of class ccp.general.Method.Method""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('constraints')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: method:
           non-reciprocal link DistanceConstraint from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('nmrConstraintValidations')
      for value in values:
        from ccp.api.molecule.Validation import NmrConstraintValidation as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: nmrConstraintValidations:
           value is not of class ccp.molecule.Validation.NmrConstraintValidation""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('nmrConstraints')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: nmrConstraintValidations:
           non-reciprocal link DistanceConstraint from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        yy2 = yy1.__dict__.get('nmrConstraintStore')
        if (not (xx1 is yy2)):
          raise ApiError("""%s.checkValid: nmrConstraintValidations:
           Link nmrConstraintValidations between objects from separate partitions
           - ccp.molecule.Validation.ValidationStore.nmrConstraintStore not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      value = dataDict.get('parentList')
      if (not isinstance(value, DistanceConstraintList)):
        raise ApiError("""%s.checkValid: parentList:
         value is not of class ccp.nmr.NmrConstraint.DistanceConstraintList""" % self.qualifiedName
         + ": %s" % (value,)
        )

      values = dataDict.get('peakContribs').values()
      for value in values:
        if (not isinstance(value, ConstraintPeakContrib)):
          raise ApiError("""%s.checkValid: peakContribs:
           value is not of class ccp.nmr.NmrConstraint.ConstraintPeakContrib""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('constraint')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: peakContribs:
           non-reciprocal link DistanceConstraint from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = self.getPeaks()
      for value in values:
        from ccp.api.nmr.Nmr import Peak as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: peaks:
           value is not of class ccp.nmr.Nmr.Peak""" % self.qualifiedName
           + ": %s" % (value,)
          )

        xx1 = dataDict.get('topObject')
        xx2 = xx1.__dict__.get('nmrProject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx2 is yy1)):
          raise ApiError("""%s.checkValid: peaks:
           Link peaks between objects from separate partitions
           - ccp.nmr.NmrConstraint.NmrConstraintStore.nmrProject not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = dataDict.get('violations')
      for value in values:
        if (not isinstance(value, Violation)):
          raise ApiError("""%s.checkValid: violations:
           value is not of class ccp.nmr.NmrConstraint.Violation""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('constraint')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: violations:
           non-reciprocal link DistanceConstraint from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: violations:
           Link violations between objects from separate partitions
           - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    # check explicit class constraints
    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('backCalcVolume')
    value = dataDict.get('details')
    value = dataDict.get('error')
    value = dataDict.get('lowerLimit')
    value = dataDict.get('origData')
    value = dataDict.get('targetValue')
    value = dataDict.get('upperLimit')
    value = dataDict.get('weight')
    if (value is None):
      raise ApiError("""%s.checkValid: weight:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    # check roles
    value = dataDict.get('access')
    values = dataDict.get('constraintGroups')
    values = dataDict.get('items').values()
    value = dataDict.get('method')
    values = dataDict.get('nmrConstraintValidations')
    for value in values:
      ll= value.keywordDefinition.targetNames
      isValid = (not ll or self.qualifiedName in ll)
      if (not (isValid)):
        raise ApiError("""%s.checkValid: nmrConstraintValidations:
         nmrConstraintValidations constraint KeywordDefinition_fits_Constraint violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    value = dataDict.get('parentList')
    if (value is None):
      raise ApiError("""%s.checkValid: parentList:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    values = dataDict.get('peakContribs').values()
    values = dataDict.get('violations')

  delete = memops.api.Implementation.DataObject.delete

  findAllApplicationData = memops.api.Implementation.DataObject.findAllApplicationData

  findAllConstraintGroups = AbstractConstraint.findAllConstraintGroups
  
  def findAllItems(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.DistanceConstraint.items
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('items').values()
      result = set(currentValues)

    else:
      currentValues = dataDict.get('items').values()
      result = set()
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('access', 'constraint', 'firstResonance',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result.add(v)

    return result

  findAllNmrConstraintValidations = AbstractConstraint.findAllNmrConstraintValidations

  findAllPeakContribs = AbstractConstraint.findAllPeakContribs

  findAllPeaks = AbstractConstraint.findAllPeaks

  findAllViolations = AbstractConstraint.findAllViolations

  findFirstApplicationData = memops.api.Implementation.DataObject.findFirstApplicationData

  findFirstConstraintGroup = AbstractConstraint.findFirstConstraintGroup
  
  def findFirstItem(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.DistanceConstraint.items
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('items').values()
      if (currentValues):
        result = iter(currentValues).next()
      else:
        result = None

    else:
      objKey = conditions.get('resonances')
      if (objKey is not None):
        objKey = frozenset(objKey)

      if (objKey is not None):
        result = dataDict.get('items').get(objKey)

        if (result is None):
          return result

        elif (len(conditions) <= 1):
          return result

        else:
          currentValues = set()
          currentValues.add(result)

      else:
        currentValues = dataDict.get('items').values()

      result = None
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('access', 'constraint', 'firstResonance',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result = v; break

    return result

  findFirstNmrConstraintValidation = AbstractConstraint.findFirstNmrConstraintValidation

  findFirstPeak = AbstractConstraint.findFirstPeak

  findFirstPeakContrib = AbstractConstraint.findFirstPeakContrib

  findFirstViolation = AbstractConstraint.findFirstViolation
  
  def get(self, name):
    """
    GetAttr for ccp.nmr.NmrConstraint.DistanceConstraint
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getAccess = memops.api.Implementation.DataObject.getAccess

  getApplicationData = memops.api.Implementation.DataObject.getApplicationData
  
  def getBackCalcVolume(self):
    """
    Get for ccp.nmr.NmrConstraint.DistanceConstraint.backCalcVolume
    """
    dataDict = self.__dict__
    result = dataDict.get('backCalcVolume')
    return result
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.DistanceConstraint
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (3 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.DistanceConstraint'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (2 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.DistanceConstraint'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-2]
      obj2 = obj1.__dict__.get('constraintLists').get(objKey)

      if (obj2 is not None):
        objKey = fullKey[-1]
        obj3 = obj2.__dict__.get('constraints').get(objKey)
        result = obj3

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = memops.api.Implementation.MemopsObject.getByNavigation

  getClassName = memops.api.Implementation.ComplexDataType.getClassName

  getConstraintGroups = AbstractConstraint.getConstraintGroups

  getDetails = AbstractConstraint.getDetails

  getError = SingleConstraint.getError

  getExpandedKey = memops.api.Implementation.MemopsObject.getExpandedKey

  getFieldNames = memops.api.Implementation.ComplexDataType.getFieldNames
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccp.nmr.NmrConstraint.DistanceConstraint
    """
    dataDict = self.__dict__
    result = list()

    obj2 = dataDict.get('parentList')
    obj1 = obj2.__dict__.get('nmrConstraintStore')

    if (useGuid):
      result.append(obj1.__dict__.get('guid'))
    else:
      result.append(obj1.__dict__.get('serial'))

    result.append(obj2.__dict__.get('serial'))
    result.append(dataDict.get('serial'))

    return result

  getInConstructor = memops.api.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = memops.api.Implementation.MemopsObject.getIsDeleted
  
  def getItems(self):
    """
    Get for ccp.nmr.NmrConstraint.DistanceConstraint.items
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('items').values()
    result = frozenset(tempVar)
    return result
  
  def getLocalKey(self):
    """
    GetLocalKey for ccp.nmr.NmrConstraint.DistanceConstraint
    """
    dataDict = self.__dict__
    result = dataDict.get('serial')
    return result

  getLowerLimit = SingleConstraint.getLowerLimit

  getMetaclass = memops.api.Implementation.ComplexDataType.getMetaclass

  getMethod = AbstractConstraint.getMethod

  getNmrConstraintValidations = AbstractConstraint.getNmrConstraintValidations

  getOrigData = AbstractConstraint.getOrigData

  getPackageName = memops.api.Implementation.ComplexDataType.getPackageName

  getPackageShortName = memops.api.Implementation.ComplexDataType.getPackageShortName
  
  def getParent(self):
    """
    Get for ccp.nmr.NmrConstraint.DistanceConstraint.parent
    """
    dataDict = self.__dict__
    result = dataDict.get('parentList')
    return result
  
  def getParentList(self):
    """
    Get for ccp.nmr.NmrConstraint.DistanceConstraint.parentList
    """
    dataDict = self.__dict__
    result = dataDict.get('parentList')
    return result

  getPeakContribs = AbstractConstraint.getPeakContribs

  getPeaks = AbstractConstraint.getPeaks

  getQualifiedName = memops.api.Implementation.ComplexDataType.getQualifiedName

  getRoot = memops.api.Implementation.MemopsObject.getRoot

  getSerial = AbstractConstraint.getSerial

  getTargetValue = SingleConstraint.getTargetValue

  getTopObject = memops.api.Implementation.DataObject.getTopObject

  getUpperLimit = SingleConstraint.getUpperLimit

  getViolations = AbstractConstraint.getViolations

  getWeight = AbstractConstraint.getWeight

  newConstraintPeakContrib = AbstractConstraint.newConstraintPeakContrib
  
  def newDistanceConstraintItem(self, **attrlinks):
    """
    Factory function to create ccp.nmr.NmrConstraint.DistanceConstraintItem
    """
    return DistanceConstraintItem(self, **attrlinks)

  removeApplicationData = memops.api.Implementation.DataObject.removeApplicationData

  removeConstraintGroup = AbstractConstraint.removeConstraintGroup

  removeNmrConstraintValidation = AbstractConstraint.removeNmrConstraintValidation

  removePeak = AbstractConstraint.removePeak
  
  def set(self, name, value):
    """
    SetAttr for ccp.nmr.NmrConstraint.DistanceConstraint
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setAccess = memops.api.Implementation.DataObject.setAccess

  setApplicationData = memops.api.Implementation.DataObject.setApplicationData
  
  def setBackCalcVolume(self, value):
    """
    Set for ccp.nmr.NmrConstraint.DistanceConstraint.backCalcVolume
    """
    dataDict = self.__dict__
    if (value is not None):
      if (isinstance(value, memops.api.Implementation.Float.PythonType)):
        pass
      elif ([x for x in memops.api.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = memops.api.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.setBackCalcVolume:
         memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.setBackCalcVolume:
         Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('backCalcVolume')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (notIsReading):
      if (notInConstructor):
        if (not (topObject.__dict__.get('isModifiable'))):
          raise ApiError("""%s.setBackCalcVolume:
           Storage not modifiable""" % self.qualifiedName
           + ": %s" % (topObject,)
          )

    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setBackCalcVolume:
       called on deleted object""" % self.qualifiedName
      )

    if (value == currentValue):
      return

    if (notOverride):
      pass

    dataDict['backCalcVolume'] = value
    if (notIsReading):
      if (notInConstructor):
        topObject.__dict__['isModified'] = True

    # doNotifies

    if ((notInConstructor and notOverride)):
      
      _notifies = self.__class__._notifies
      
      ll1 = _notifies['']
      for notify in ll1:
        notify(self)
      
      ll = _notifies.get('setBackCalcVolume')
      if ll:
        for notify in ll:
          if notify not in ll1:
            notify(self)

  setConstraintGroups = AbstractConstraint.setConstraintGroups

  setDetails = AbstractConstraint.setDetails

  setError = SingleConstraint.setError

  setLowerLimit = SingleConstraint.setLowerLimit

  setMethod = AbstractConstraint.setMethod

  setNmrConstraintValidations = AbstractConstraint.setNmrConstraintValidations

  setOrigData = AbstractConstraint.setOrigData

  setPeaks = AbstractConstraint.setPeaks

  setSerial = AbstractConstraint.setSerial

  setTargetValue = SingleConstraint.setTargetValue

  setUpperLimit = SingleConstraint.setUpperLimit

  setViolations = AbstractConstraint.setViolations

  setWeight = AbstractConstraint.setWeight

  sortedConstraintGroups = AbstractConstraint.sortedConstraintGroups
  
  def sortedItems(self):
    """
    Sorted for ccp.nmr.NmrConstraint.DistanceConstraint.items
    """
    dataDict = self.__dict__
    sortdd = dataDict.get('items')
    
    ll = sortdd.keys()
    ll.sort()
    result = [sortdd[x] for x in ll]
    return result

  sortedNmrConstraintValidations = AbstractConstraint.sortedNmrConstraintValidations

  sortedPeakContribs = AbstractConstraint.sortedPeakContribs

  sortedPeaks = AbstractConstraint.sortedPeaks

  sortedViolations = AbstractConstraint.sortedViolations

  toDetailedString = memops.api.Implementation.ComplexDataType.toDetailedString

  applicationData = memops.api.Implementation.DataObject.applicationData
  
  backCalcVolume = property(getBackCalcVolume, setBackCalcVolume, None,
  r"""Backcalculated volume.
  """)

  className = memops.api.Implementation.ComplexDataType.className

  details = AbstractConstraint.details

  error = SingleConstraint.error

  fieldNames = memops.api.Implementation.ComplexDataType.fieldNames

  inConstructor = memops.api.Implementation.ComplexDataType.inConstructor

  isDeleted = memops.api.Implementation.MemopsObject.isDeleted

  lowerLimit = SingleConstraint.lowerLimit

  metaclass = memops.api.Implementation.ComplexDataType.metaclass

  origData = AbstractConstraint.origData

  packageName = memops.api.Implementation.ComplexDataType.packageName

  packageShortName = memops.api.Implementation.ComplexDataType.packageShortName

  qualifiedName = memops.api.Implementation.ComplexDataType.qualifiedName

  serial = AbstractConstraint.serial

  targetValue = SingleConstraint.targetValue

  upperLimit = SingleConstraint.upperLimit

  weight = AbstractConstraint.weight

  access = memops.api.Implementation.DataObject.access

  constraintGroups = AbstractConstraint.constraintGroups
  
  items = property(getItems,  None, None,
  r"""child link to class DistanceConstraintItem
  """)

  method = AbstractConstraint.method

  nmrConstraintValidations = AbstractConstraint.nmrConstraintValidations
  
  parent = property(getParent, None, None,
  r"""link to parent object - synonym for parentList
  """)
  
  parentList = property(getParentList,  None, None,
  r"""parent link
  """)

  peakContribs = AbstractConstraint.peakContribs

  peaks = AbstractConstraint.peaks

  root = memops.api.Implementation.MemopsObject.root

  topObject = memops.api.Implementation.DataObject.topObject

  violations = AbstractConstraint.violations

###############################################################################
class HBondConstraint(SingleConstraint):
  r"""Constraint (distance constraint) describing a hydrogen bond.  Ambiguous, 
may contain several HBondConstraintItems, each with a different 
assignment, describing alternative assignment possibilities.
  """
  #   from data model element ccp.nmr.NmrConstraint.HBondConstraint revision 1.36.2.9
  _metaclass = metaPackage.getElement('HBondConstraint')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('applicationData', 'className', 'details', 'error', 'fieldNames', 'inConstructor', 'isDeleted', 'lowerLimit', 'metaclass', 'origData', 'packageName', 'packageShortName', 'qualifiedName', 'serial', 'targetValue', 'upperLimit', 'weight', 'access', 'constraintGroups', 'items', 'method', 'nmrConstraintValidations', 'parent', 'parentList', 'peakContribs', 'peaks', 'root', 'topObject', 'violations',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccp.nmr.NmrConstraint.HBondConstraint
    """
    dataDict = self.__dict__
    dataDict['parentList'] = parent
    if (not isinstance(parent, HBondConstraintList)):
      raise ApiError("""%s.__init__:
       value is not of class ccp.nmr.NmrConstraint.HBondConstraintList""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:

      dataDict['applicationData'] = list()
      dataDict['details'] = None
      dataDict['error'] = None
      dataDict['lowerLimit'] = None
      dataDict['origData'] = None
      dataDict['serial'] = None
      dataDict['targetValue'] = None
      dataDict['upperLimit'] = None
      dataDict['weight'] = 1.0
      dataDict['access'] = None
      dataDict['constraintGroups'] = set()
      dataDict['items'] = {}
      dataDict['method'] = None
      dataDict['nmrConstraintValidations'] = set()
      dataDict['peakContribs'] = {}
      dataDict['violations'] = set()

      dataDict['inConstructor'] = True
      try:
        
        for key, value in attrlinks.iteritems():
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        del dataDict['inConstructor']
      except:
        print "ERROR in ccp.nmr.NmrConstraint.HBondConstraint.__init__"
        del dataDict['inConstructor']
        raise

      if (notOverride):
        if (dataDict.get('serial') is None):
          dataDict['inConstructor'] = True
          self.setSerial(-1)
          del dataDict['inConstructor']
        else:
          raise ApiError("""%s.__init__:
           Cannot pass in explicit serial if not reading""" % self.qualifiedName
           + ": %s:%s" % (parent, 'ccp.nmr.NmrConstraint.HBondConstraint')
          )

      if (notIsReading):
        childrenDict = parent.__dict__.get('constraints')
        objKey = dataDict.get('serial')
        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['serial'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        print '''WARNING Error in clean-up of incorrectly created object. 
        Data may be left in an illegal state'''
        del dataDict['inConstructor']
      raise exc_info[0], exc_info[1], exc_info[2]

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccp.nmr.NmrConstraint.HBondConstraint:
       determines 
    cascading deletes to follow from delete of object.
       *Implementation 
    function* - should be called only by API delete function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
      dataDict.get('topObject').load()

    access = dataDict.get('access')
    if (access is not None):
      topObject = access.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    items = dataDict.get('items').values()
    for item in items:
      if (not (item in objsToBeDeleted)):
        objsToBeDeleted.add(item)
        objsToBeChecked.append(item)

    method = dataDict.get('method')
    if (method is not None):
      topObject = method.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    nmrConstraintValidations = dataDict.get('nmrConstraintValidations')
    pass
    for nmrConstraintValidation in nmrConstraintValidations:
      topObject = nmrConstraintValidation.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    peakContribs = dataDict.get('peakContribs').values()
    for peakContrib in peakContribs:
      if (not (peakContrib in objsToBeDeleted)):
        objsToBeDeleted.add(peakContrib)
        objsToBeChecked.append(peakContrib)

    violations = dataDict.get('violations')
    for violation in violations:
      if (not (violation in objsToBeDeleted)):
        objsToBeDeleted.add(violation)
        objsToBeChecked.append(violation)

    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccp.nmr.NmrConstraint.HBondConstraint:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    access = dataDict.get('access')
    if ((access is not None and not (access in objsToBeDeleted))):
      dataObjects = access.__dict__.get('dataObjects')
      dataObjects.remove(self)

    for constraintGroup in dataDict.get('constraintGroups'):
      if (not (constraintGroup in objsToBeDeleted)):
        constraints = constraintGroup.__dict__.get('constraints')
        constraints.remove(self)

    method = dataDict.get('method')
    if ((method is not None and not (method in objsToBeDeleted))):
      constraints = method.__dict__.get('constraints')
      constraints.remove(self)

    for nmrConstraintValidation in dataDict.get('nmrConstraintValidations'):
      if (not (nmrConstraintValidation in objsToBeDeleted)):
        nmrConstraints = nmrConstraintValidation.__dict__.get('nmrConstraints')
        nmrConstraints.remove(self)

    parentList = dataDict.get('parentList')
    if (not (parentList in objsToBeDeleted)):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = parentList.__dict__.get('constraints')
        if (self is dd.get(objKey)):
          del dd[objKey]

  addApplicationData = memops.api.Implementation.DataObject.addApplicationData

  addConstraintGroup = AbstractConstraint.addConstraintGroup

  addNmrConstraintValidation = AbstractConstraint.addNmrConstraintValidation

  addPeak = AbstractConstraint.addPeak
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccp.nmr.NmrConstraint.HBondConstraint
    """
    dataDict = self.__dict__
    self.checkValid(complete)
    values = dataDict.get('items').values()
    for value in values:
      value.checkAllValid(complete)

    values = dataDict.get('peakContribs').values()
    for value in values:
      value.checkAllValid(complete)

  def checkValid(self, complete=False):
    """
    CheckValid for ccp.nmr.NmrConstraint.HBondConstraint
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('parentList')
        dd = value.__dict__.get('constraints')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'parentList' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from memops.api.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('details')
      if (value is not None):
        if (isinstance(value, memops.api.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: details:
           memops.Implementation.Text input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 254):
          raise ApiError("""%s.checkValid: details:
           memops.Implementation.Text maximum length is 254 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: details:
           memops.Implementation.Text: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('error')
      if (value is not None):
        if (isinstance(value, memops.api.Implementation.Float.PythonType)):
          pass
        elif ([x for x in memops.api.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = memops.api.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: error:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: error:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('lowerLimit')
      if (value is not None):
        if (isinstance(value, memops.api.Implementation.Float.PythonType)):
          pass
        elif ([x for x in memops.api.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = memops.api.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: lowerLimit:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: lowerLimit:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('origData')
      if (value is not None):
        if (isinstance(value, memops.api.Implementation.Float.PythonType)):
          pass
        elif ([x for x in memops.api.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = memops.api.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: origData:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: origData:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, memops.api.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('serial')
      if (value is None):
        raise ApiError("""%s.checkValid: serial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, memops.api.Implementation.Int.PythonType)):
        pass
      elif ([x for x in memops.api.Implementation.Int.compatibleTypes if isinstance(value, x)]):
        value = memops.api.Implementation.Int.create(value)
      else:
        raise ApiError("""%s.checkValid: serial:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('targetValue')
      if (value is not None):
        if (isinstance(value, memops.api.Implementation.Float.PythonType)):
          pass
        elif ([x for x in memops.api.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = memops.api.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: targetValue:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: targetValue:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('upperLimit')
      if (value is not None):
        if (isinstance(value, memops.api.Implementation.Float.PythonType)):
          pass
        elif ([x for x in memops.api.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = memops.api.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: upperLimit:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: upperLimit:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('weight')
      if (isinstance(value, memops.api.Implementation.Float.PythonType)):
        pass
      elif ([x for x in memops.api.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = memops.api.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.checkValid: weight:
         memops.Implementation.NonNegativeFloat input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (0.0 <= value)):
        raise ApiError("""%s.checkValid: weight:
         NonNegativeFloat constraint float_value_ge_0 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.checkValid: weight:
         NonNegativeFloat constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('access')
      if (value is not None):
        from memops.api.AccessControl import AccessObject as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: access:
           value is not of class memops.AccessControl.AccessObject""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('dataObjects')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: access:
           non-reciprocal link HBondConstraint from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('constraintGroups')
      for value in values:
        if (not isinstance(value, ConstraintGroup)):
          raise ApiError("""%s.checkValid: constraintGroups:
           value is not of class ccp.nmr.NmrConstraint.ConstraintGroup""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('constraints')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: constraintGroups:
           non-reciprocal link HBondConstraint from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: constraintGroups:
           Link constraintGroups between objects from separate partitions
           - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = dataDict.get('items').values()
      for value in values:
        if (not isinstance(value, HBondConstraintItem)):
          raise ApiError("""%s.checkValid: items:
           value is not of class ccp.nmr.NmrConstraint.HBondConstraintItem""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('constraint')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: items:
           non-reciprocal link HBondConstraint from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      value = dataDict.get('method')
      if (value is not None):
        from ccp.api.general.Method import Method as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: method:
           value is not of class ccp.general.Method.Method""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('constraints')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: method:
           non-reciprocal link HBondConstraint from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('nmrConstraintValidations')
      for value in values:
        from ccp.api.molecule.Validation import NmrConstraintValidation as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: nmrConstraintValidations:
           value is not of class ccp.molecule.Validation.NmrConstraintValidation""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('nmrConstraints')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: nmrConstraintValidations:
           non-reciprocal link HBondConstraint from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        yy2 = yy1.__dict__.get('nmrConstraintStore')
        if (not (xx1 is yy2)):
          raise ApiError("""%s.checkValid: nmrConstraintValidations:
           Link nmrConstraintValidations between objects from separate partitions
           - ccp.molecule.Validation.ValidationStore.nmrConstraintStore not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      value = dataDict.get('parentList')
      if (not isinstance(value, HBondConstraintList)):
        raise ApiError("""%s.checkValid: parentList:
         value is not of class ccp.nmr.NmrConstraint.HBondConstraintList""" % self.qualifiedName
         + ": %s" % (value,)
        )

      values = dataDict.get('peakContribs').values()
      for value in values:
        if (not isinstance(value, ConstraintPeakContrib)):
          raise ApiError("""%s.checkValid: peakContribs:
           value is not of class ccp.nmr.NmrConstraint.ConstraintPeakContrib""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('constraint')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: peakContribs:
           non-reciprocal link HBondConstraint from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = self.getPeaks()
      for value in values:
        from ccp.api.nmr.Nmr import Peak as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: peaks:
           value is not of class ccp.nmr.Nmr.Peak""" % self.qualifiedName
           + ": %s" % (value,)
          )

        xx1 = dataDict.get('topObject')
        xx2 = xx1.__dict__.get('nmrProject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx2 is yy1)):
          raise ApiError("""%s.checkValid: peaks:
           Link peaks between objects from separate partitions
           - ccp.nmr.NmrConstraint.NmrConstraintStore.nmrProject not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      values = dataDict.get('violations')
      for value in values:
        if (not isinstance(value, Violation)):
          raise ApiError("""%s.checkValid: violations:
           value is not of class ccp.nmr.NmrConstraint.Violation""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('constraint')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: violations:
           non-reciprocal link HBondConstraint from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: violations:
           Link violations between objects from separate partitions
           - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    # check explicit class constraints
    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('details')
    value = dataDict.get('error')
    value = dataDict.get('lowerLimit')
    value = dataDict.get('origData')
    value = dataDict.get('targetValue')
    value = dataDict.get('upperLimit')
    value = dataDict.get('weight')
    if (value is None):
      raise ApiError("""%s.checkValid: weight:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    # check roles
    value = dataDict.get('access')
    values = dataDict.get('constraintGroups')
    values = dataDict.get('items').values()
    value = dataDict.get('method')
    values = dataDict.get('nmrConstraintValidations')
    for value in values:
      ll= value.keywordDefinition.targetNames
      isValid = (not ll or self.qualifiedName in ll)
      if (not (isValid)):
        raise ApiError("""%s.checkValid: nmrConstraintValidations:
         nmrConstraintValidations constraint KeywordDefinition_fits_Constraint violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    value = dataDict.get('parentList')
    if (value is None):
      raise ApiError("""%s.checkValid: parentList:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    values = dataDict.get('peakContribs').values()
    values = dataDict.get('violations')

  delete = memops.api.Implementation.DataObject.delete

  findAllApplicationData = memops.api.Implementation.DataObject.findAllApplicationData

  findAllConstraintGroups = AbstractConstraint.findAllConstraintGroups
  
  def findAllItems(self, **conditions):
    """
    FindAll for ccp.nmr.NmrConstraint.HBondConstraint.items
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('items').values()
      result = set(currentValues)

    else:
      currentValues = dataDict.get('items').values()
      result = set()
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('access', 'constraint', 'firstResonance',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result.add(v)

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result.add(v)

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result.add(v)

    return result

  findAllNmrConstraintValidations = AbstractConstraint.findAllNmrConstraintValidations

  findAllPeakContribs = AbstractConstraint.findAllPeakContribs

  findAllPeaks = AbstractConstraint.findAllPeaks

  findAllViolations = AbstractConstraint.findAllViolations

  findFirstApplicationData = memops.api.Implementation.DataObject.findFirstApplicationData

  findFirstConstraintGroup = AbstractConstraint.findFirstConstraintGroup
  
  def findFirstItem(self, **conditions):
    """
    FindFirst for ccp.nmr.NmrConstraint.HBondConstraint.items
    """
    dataDict = self.__dict__
    nConditions = len(conditions)
    if (nConditions == 0):
      currentValues = dataDict.get('items').values()
      if (currentValues):
        result = iter(currentValues).next()
      else:
        result = None

    else:
      objKey = conditions.get('resonances')
      if (objKey is not None):
        objKey = frozenset(objKey)

      if (objKey is not None):
        result = dataDict.get('items').get(objKey)

        if (result is None):
          return result

        elif (len(conditions) <= 1):
          return result

        else:
          currentValues = set()
          currentValues.add(result)

      else:
        currentValues = dataDict.get('items').values()

      result = None
      
      items = conditions.items()
      if ((nConditions == 1)):
        (key, condition) = items[0]
        directAttrs = frozenset(('access', 'constraint', 'firstResonance',))
        if (key in directAttrs):
          for v in currentValues:
            if (condition == v.__dict__.get(key)):
              result = v; break

        else:
          
          if isinstance(condition, list):
            condition = tuple(condition)
          elif isinstance(condition, set):
            condition = frozenset(condition)
          
          for v in currentValues:
            if (hasattr(v, key) and getattr(v, key) == condition):
              result = v; break

      else:
        
        for ii in range(nConditions):
          (key, condition) = items[ii]
          if isinstance(condition, list):
            items[ii] = (key, tuple(condition))
          elif isinstance(condition, set):
            items[ii] = (key, frozenset(condition))
        
        for v in currentValues:
        
          for (key, condition) in items:
            if (not hasattr(v, key)):
              break
            elif (getattr(v, key) != condition):
              break
          else:
            result = v; break

    return result

  findFirstNmrConstraintValidation = AbstractConstraint.findFirstNmrConstraintValidation

  findFirstPeak = AbstractConstraint.findFirstPeak

  findFirstPeakContrib = AbstractConstraint.findFirstPeakContrib

  findFirstViolation = AbstractConstraint.findFirstViolation
  
  def get(self, name):
    """
    GetAttr for ccp.nmr.NmrConstraint.HBondConstraint
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getAccess = memops.api.Implementation.DataObject.getAccess

  getApplicationData = memops.api.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.HBondConstraint
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (3 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.HBondConstraint'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (2 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.HBondConstraint'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-2]
      obj2 = obj1.__dict__.get('constraintLists').get(objKey)

      if (obj2 is not None):
        objKey = fullKey[-1]
        obj3 = obj2.__dict__.get('constraints').get(objKey)
        result = obj3

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = memops.api.Implementation.MemopsObject.getByNavigation

  getClassName = memops.api.Implementation.ComplexDataType.getClassName

  getConstraintGroups = AbstractConstraint.getConstraintGroups

  getDetails = AbstractConstraint.getDetails

  getError = SingleConstraint.getError

  getExpandedKey = memops.api.Implementation.MemopsObject.getExpandedKey

  getFieldNames = memops.api.Implementation.ComplexDataType.getFieldNames
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccp.nmr.NmrConstraint.HBondConstraint
    """
    dataDict = self.__dict__
    result = list()

    obj2 = dataDict.get('parentList')
    obj1 = obj2.__dict__.get('nmrConstraintStore')

    if (useGuid):
      result.append(obj1.__dict__.get('guid'))
    else:
      result.append(obj1.__dict__.get('serial'))

    result.append(obj2.__dict__.get('serial'))
    result.append(dataDict.get('serial'))

    return result

  getInConstructor = memops.api.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = memops.api.Implementation.MemopsObject.getIsDeleted
  
  def getItems(self):
    """
    Get for ccp.nmr.NmrConstraint.HBondConstraint.items
    """
    dataDict = self.__dict__
    tempVar = dataDict.get('items').values()
    result = frozenset(tempVar)
    return result
  
  def getLocalKey(self):
    """
    GetLocalKey for ccp.nmr.NmrConstraint.HBondConstraint
    """
    dataDict = self.__dict__
    result = dataDict.get('serial')
    return result

  getLowerLimit = SingleConstraint.getLowerLimit

  getMetaclass = memops.api.Implementation.ComplexDataType.getMetaclass

  getMethod = AbstractConstraint.getMethod

  getNmrConstraintValidations = AbstractConstraint.getNmrConstraintValidations

  getOrigData = AbstractConstraint.getOrigData

  getPackageName = memops.api.Implementation.ComplexDataType.getPackageName

  getPackageShortName = memops.api.Implementation.ComplexDataType.getPackageShortName
  
  def getParent(self):
    """
    Get for ccp.nmr.NmrConstraint.HBondConstraint.parent
    """
    dataDict = self.__dict__
    result = dataDict.get('parentList')
    return result
  
  def getParentList(self):
    """
    Get for ccp.nmr.NmrConstraint.HBondConstraint.parentList
    """
    dataDict = self.__dict__
    result = dataDict.get('parentList')
    return result

  getPeakContribs = AbstractConstraint.getPeakContribs

  getPeaks = AbstractConstraint.getPeaks

  getQualifiedName = memops.api.Implementation.ComplexDataType.getQualifiedName

  getRoot = memops.api.Implementation.MemopsObject.getRoot

  getSerial = AbstractConstraint.getSerial

  getTargetValue = SingleConstraint.getTargetValue

  getTopObject = memops.api.Implementation.DataObject.getTopObject

  getUpperLimit = SingleConstraint.getUpperLimit

  getViolations = AbstractConstraint.getViolations

  getWeight = AbstractConstraint.getWeight

  newConstraintPeakContrib = AbstractConstraint.newConstraintPeakContrib
  
  def newHBondConstraintItem(self, **attrlinks):
    """
    Factory function to create ccp.nmr.NmrConstraint.HBondConstraintItem
    """
    return HBondConstraintItem(self, **attrlinks)

  removeApplicationData = memops.api.Implementation.DataObject.removeApplicationData

  removeConstraintGroup = AbstractConstraint.removeConstraintGroup

  removeNmrConstraintValidation = AbstractConstraint.removeNmrConstraintValidation

  removePeak = AbstractConstraint.removePeak
  
  def set(self, name, value):
    """
    SetAttr for ccp.nmr.NmrConstraint.HBondConstraint
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setAccess = memops.api.Implementation.DataObject.setAccess

  setApplicationData = memops.api.Implementation.DataObject.setApplicationData

  setConstraintGroups = AbstractConstraint.setConstraintGroups

  setDetails = AbstractConstraint.setDetails

  setError = SingleConstraint.setError

  setLowerLimit = SingleConstraint.setLowerLimit

  setMethod = AbstractConstraint.setMethod

  setNmrConstraintValidations = AbstractConstraint.setNmrConstraintValidations

  setOrigData = AbstractConstraint.setOrigData

  setPeaks = AbstractConstraint.setPeaks

  setSerial = AbstractConstraint.setSerial

  setTargetValue = SingleConstraint.setTargetValue

  setUpperLimit = SingleConstraint.setUpperLimit

  setViolations = AbstractConstraint.setViolations

  setWeight = AbstractConstraint.setWeight

  sortedConstraintGroups = AbstractConstraint.sortedConstraintGroups
  
  def sortedItems(self):
    """
    Sorted for ccp.nmr.NmrConstraint.HBondConstraint.items
    """
    dataDict = self.__dict__
    sortdd = dataDict.get('items')
    
    ll = sortdd.keys()
    ll.sort()
    result = [sortdd[x] for x in ll]
    return result

  sortedNmrConstraintValidations = AbstractConstraint.sortedNmrConstraintValidations

  sortedPeakContribs = AbstractConstraint.sortedPeakContribs

  sortedPeaks = AbstractConstraint.sortedPeaks

  sortedViolations = AbstractConstraint.sortedViolations

  toDetailedString = memops.api.Implementation.ComplexDataType.toDetailedString

  applicationData = memops.api.Implementation.DataObject.applicationData

  className = memops.api.Implementation.ComplexDataType.className

  details = AbstractConstraint.details

  error = SingleConstraint.error

  fieldNames = memops.api.Implementation.ComplexDataType.fieldNames

  inConstructor = memops.api.Implementation.ComplexDataType.inConstructor

  isDeleted = memops.api.Implementation.MemopsObject.isDeleted

  lowerLimit = SingleConstraint.lowerLimit

  metaclass = memops.api.Implementation.ComplexDataType.metaclass

  origData = AbstractConstraint.origData

  packageName = memops.api.Implementation.ComplexDataType.packageName

  packageShortName = memops.api.Implementation.ComplexDataType.packageShortName

  qualifiedName = memops.api.Implementation.ComplexDataType.qualifiedName

  serial = AbstractConstraint.serial

  targetValue = SingleConstraint.targetValue

  upperLimit = SingleConstraint.upperLimit

  weight = AbstractConstraint.weight

  access = memops.api.Implementation.DataObject.access

  constraintGroups = AbstractConstraint.constraintGroups
  
  items = property(getItems,  None, None,
  r"""child link to class HBondConstraintItem
  """)

  method = AbstractConstraint.method

  nmrConstraintValidations = AbstractConstraint.nmrConstraintValidations
  
  parent = property(getParent, None, None,
  r"""link to parent object - synonym for parentList
  """)
  
  parentList = property(getParentList,  None, None,
  r"""parent link
  """)

  peakContribs = AbstractConstraint.peakContribs

  peaks = AbstractConstraint.peaks

  root = memops.api.Implementation.MemopsObject.root

  topObject = memops.api.Implementation.DataObject.topObject

  violations = AbstractConstraint.violations

###############################################################################
class CsaConstraint(SingleConstraint):
  r"""Chemical shift anisotropy constraint (anisotropy value that must be 
reproduced by the structure).
  """
  #   from data model element ccp.nmr.NmrConstraint.CsaConstraint revision 1.1.2.9
  _metaclass = metaPackage.getElement('CsaConstraint')
  _packageName = 'ccp.nmr.NmrConstraint'
  _packageShortName = 'NMRC'
  _fieldNames = ('applicationData', 'className', 'details', 'error', 'fieldNames', 'inConstructor', 'isDeleted', 'lowerLimit', 'metaclass', 'origData', 'packageName', 'packageShortName', 'qualifiedName', 'serial', 'targetValue', 'upperLimit', 'weight', 'access', 'constraintGroups', 'method', 'nmrConstraintValidations', 'parent', 'parentList', 'peakContribs', 'peaks', 'resonance', 'root', 'topObject', 'violations',)
  
  _notifies = {'':[]}
  
  def __init__(self, parent, **attrlinks):
    """
    Constructor for ccp.nmr.NmrConstraint.CsaConstraint
    """
    dataDict = self.__dict__
    dataDict['parentList'] = parent
    if (not isinstance(parent, CsaConstraintList)):
      raise ApiError("""%s.__init__:
       value is not of class ccp.nmr.NmrConstraint.CsaConstraintList""" % self.qualifiedName
       + ": %s" % (parent,)
      )

    if (parent.__dict__.get('isDeleted')):
      raise ApiError("""%s.__init__:
       called with deleted parent""" % self.qualifiedName
      )

    topObject = parent.__dict__.get('topObject')
    dataDict['topObject'] = topObject

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)

    if (notIsReading):
      if (not (topObject.__dict__.get('isModifiable'))):
        raise ApiError("""%s.__init__:
         Storage not modifiable""" % self.qualifiedName
         + ": %s" % (topObject,)
        )

    try:

      dataDict['applicationData'] = list()
      dataDict['details'] = None
      dataDict['error'] = None
      dataDict['lowerLimit'] = None
      dataDict['origData'] = None
      dataDict['serial'] = None
      dataDict['targetValue'] = None
      dataDict['upperLimit'] = None
      dataDict['weight'] = 1.0
      dataDict['access'] = None
      dataDict['constraintGroups'] = set()
      dataDict['method'] = None
      dataDict['nmrConstraintValidations'] = set()
      dataDict['peakContribs'] = {}
      dataDict['resonance'] = None
      dataDict['violations'] = set()

      dataDict['inConstructor'] = True
      try:
        
        for key, value in attrlinks.iteritems():
          try:
            func = getattr(self.__class__, key).fset
          except:
            raise ApiError("%s: error setting %s - not a modeled attribute"
                           % (self, key))
          if func is None:
            raise ApiError("%s: error setting %s - not a settable attribute"
                           % (self, key))
          else:
            func(self, value)
        del dataDict['inConstructor']
      except:
        print "ERROR in ccp.nmr.NmrConstraint.CsaConstraint.__init__"
        del dataDict['inConstructor']
        raise

      if (notOverride):
        if (dataDict.get('serial') is None):
          dataDict['inConstructor'] = True
          self.setSerial(-1)
          del dataDict['inConstructor']
        else:
          raise ApiError("""%s.__init__:
           Cannot pass in explicit serial if not reading""" % self.qualifiedName
           + ": %s:%s" % (parent, 'ccp.nmr.NmrConstraint.CsaConstraint')
          )

      if (notIsReading):
        childrenDict = parent.__dict__.get('constraints')
        objKey = dataDict.get('serial')
        if (objKey is None):
          raise ApiError("""%s.__init__:
           Key attribute or link not set (from ['serial'])""" % self.qualifiedName
           + ": %s" % (self,)
          )
        else:
          if (childrenDict.get(objKey) is None):
            childrenDict[objKey] = self
          else:
            raise ApiError("""%s.__init__:
             Could not create, pre-existing object had same key""" % self.qualifiedName
             + ": %s" % (self,)
            )

      if (notOverride):
        self.checkValid()

      if (notIsReading):
        topObject.__dict__['isModified'] = True

    except:
      import sys
      exc_info = sys.exc_info()
      try:
        dataDict['inConstructor'] = True
        self.delete()
        del dataDict['inConstructor']
      except:
        print '''WARNING Error in clean-up of incorrectly created object. 
        Data may be left in an illegal state'''
        del dataDict['inConstructor']
      raise exc_info[0], exc_info[1], exc_info[2]

    # doNotifies

    if (notOverride):
      
      ll = self.__class__._notifies.get('__init__')
      if ll:
        for notify in ll:
          notify(self)

  def _checkDelete(self, objsToBeDeleted, objsToBeChecked, linkCounter, topObjectsToCheck):
    """
    checkDelete for ccp.nmr.NmrConstraint.CsaConstraint:
       determines 
    cascading deletes to follow from delete of object.
       *Implementation 
    function* - should be called only by API delete function.
    """
    dataDict = self.__dict__
    objsToBeDeleted.add(self)
    if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
      dataDict.get('topObject').load()

    access = dataDict.get('access')
    if (access is not None):
      topObject = access.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    method = dataDict.get('method')
    if (method is not None):
      topObject = method.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    nmrConstraintValidations = dataDict.get('nmrConstraintValidations')
    pass
    for nmrConstraintValidation in nmrConstraintValidations:
      topObject = nmrConstraintValidation.__dict__.get('topObject')
      topObjectsToCheck.add(topObject)

    peakContribs = dataDict.get('peakContribs').values()
    for peakContrib in peakContribs:
      if (not (peakContrib in objsToBeDeleted)):
        objsToBeDeleted.add(peakContrib)
        objsToBeChecked.append(peakContrib)

    violations = dataDict.get('violations')
    for violation in violations:
      if (not (violation in objsToBeDeleted)):
        objsToBeDeleted.add(violation)
        objsToBeChecked.append(violation)

    topObject = dataDict.get('topObject')
    topObjectsToCheck.add(topObject)
  
  def _singleDelete(self, objsToBeDeleted):
    """
    singleDelete for ccp.nmr.NmrConstraint.CsaConstraint:   deletes
    objects
    *Implementation function* - will CORRUPT DATA if called outside 
    the API delete function.
    """
    dataDict = self.__dict__
    dataDict['isDeleted'] = True
    access = dataDict.get('access')
    if ((access is not None and not (access in objsToBeDeleted))):
      dataObjects = access.__dict__.get('dataObjects')
      dataObjects.remove(self)

    for constraintGroup in dataDict.get('constraintGroups'):
      if (not (constraintGroup in objsToBeDeleted)):
        constraints = constraintGroup.__dict__.get('constraints')
        constraints.remove(self)

    method = dataDict.get('method')
    if ((method is not None and not (method in objsToBeDeleted))):
      constraints = method.__dict__.get('constraints')
      constraints.remove(self)

    for nmrConstraintValidation in dataDict.get('nmrConstraintValidations'):
      if (not (nmrConstraintValidation in objsToBeDeleted)):
        nmrConstraints = nmrConstraintValidation.__dict__.get('nmrConstraints')
        nmrConstraints.remove(self)

    resonance = dataDict.get('resonance')
    if ((resonance is not None and not (resonance in objsToBeDeleted))):
      csaConstraints = resonance.__dict__.get('csaConstraints')
      csaConstraints.remove(self)

    parentList = dataDict.get('parentList')
    if (not (parentList in objsToBeDeleted)):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s._singleDelete:
         Key could not be calculated for object to be deleted""" % self.qualifiedName
        )
      else:
        dd = parentList.__dict__.get('constraints')
        if (self is dd.get(objKey)):
          del dd[objKey]

  addApplicationData = memops.api.Implementation.DataObject.addApplicationData

  addConstraintGroup = AbstractConstraint.addConstraintGroup

  addNmrConstraintValidation = AbstractConstraint.addNmrConstraintValidation

  addPeak = AbstractConstraint.addPeak
  
  def checkAllValid(self, complete=False):
    """
    CheckAllValid for ccp.nmr.NmrConstraint.CsaConstraint
    """
    dataDict = self.__dict__
    self.checkValid(complete)
    values = dataDict.get('peakContribs').values()
    for value in values:
      value.checkAllValid(complete)

  def checkValid(self, complete=False):
    """
    CheckValid for ccp.nmr.NmrConstraint.CsaConstraint
    """
    dataDict = self.__dict__
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.checkValid:
       called on deleted object""" % self.qualifiedName
      )

    if (complete):
      objKey = dataDict.get('serial')
      if (objKey is None):
        raise ApiError("""%s.checkValid:
         Key could not be calculated for object""" % self.qualifiedName
         + ": %s" % (self,)
        )
      else:
        value = dataDict.get('parentList')
        dd = value.__dict__.get('constraints')
        if (not (self is dd.get(objKey))):
          raise ApiError("""%s.checkValid:
           non-reciprocal parent link 'parentList' from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      # check attributes
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      values = dataDict.get('applicationData')
      for value in values:
        from memops.api.Implementation import ApplicationData as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: applicationData:
           value is not of class memops.Implementation.ApplicationData""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('details')
      if (value is not None):
        if (isinstance(value, memops.api.Implementation.String.PythonType)):
          pass
        else:
          raise ApiError("""%s.checkValid: details:
           memops.Implementation.Text input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        _lenValue = len(value)
        if (_lenValue > 254):
          raise ApiError("""%s.checkValid: details:
           memops.Implementation.Text maximum length is 254 violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (_lenValue < 1):
          raise ApiError("""%s.checkValid: details:
           memops.Implementation.Text: Empty string not allowed""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('error')
      if (value is not None):
        if (isinstance(value, memops.api.Implementation.Float.PythonType)):
          pass
        elif ([x for x in memops.api.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = memops.api.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: error:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: error:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('lowerLimit')
      if (value is not None):
        if (isinstance(value, memops.api.Implementation.Float.PythonType)):
          pass
        elif ([x for x in memops.api.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = memops.api.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: lowerLimit:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: lowerLimit:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('origData')
      if (value is not None):
        if (isinstance(value, memops.api.Implementation.Float.PythonType)):
          pass
        elif ([x for x in memops.api.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = memops.api.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: origData:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: origData:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = self.getQualifiedName()
      if (value is None):
        raise ApiError("""%s.checkValid: qualifiedName:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, memops.api.Implementation.String.PythonType)):
        pass
      else:
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      _lenValue = len(value)
      if (_lenValue > 80):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line maximum length is 80 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (_lenValue < 1):
        raise ApiError("""%s.checkValid: qualifiedName:
         memops.Implementation.Line: Empty string not allowed""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (len(value.splitlines()) <= 1)):
        raise ApiError("""%s.checkValid: qualifiedName:
         Line constraint contains_no_linebreak violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('serial')
      if (value is None):
        raise ApiError("""%s.checkValid: serial:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (isinstance(value, memops.api.Implementation.Int.PythonType)):
        pass
      elif ([x for x in memops.api.Implementation.Int.compatibleTypes if isinstance(value, x)]):
        value = memops.api.Implementation.Int.create(value)
      else:
        raise ApiError("""%s.checkValid: serial:
         memops.Implementation.Int input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      value = dataDict.get('targetValue')
      if (value is not None):
        if (isinstance(value, memops.api.Implementation.Float.PythonType)):
          pass
        elif ([x for x in memops.api.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = memops.api.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: targetValue:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: targetValue:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('upperLimit')
      if (value is not None):
        if (isinstance(value, memops.api.Implementation.Float.PythonType)):
          pass
        elif ([x for x in memops.api.Implementation.Float.compatibleTypes if isinstance(value, x)]):
          value = memops.api.Implementation.Float.create(value)
        else:
          raise ApiError("""%s.checkValid: upperLimit:
           memops.Implementation.Float input is not of a valid type""" % self.qualifiedName
           + ": %s" % (value,)
          )

        if (not (value - value == 0.0)):
          raise ApiError("""%s.checkValid: upperLimit:
           Float constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
           + ": %s" % (value,)
          )

      value = dataDict.get('weight')
      if (isinstance(value, memops.api.Implementation.Float.PythonType)):
        pass
      elif ([x for x in memops.api.Implementation.Float.compatibleTypes if isinstance(value, x)]):
        value = memops.api.Implementation.Float.create(value)
      else:
        raise ApiError("""%s.checkValid: weight:
         memops.Implementation.NonNegativeFloat input is not of a valid type""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (0.0 <= value)):
        raise ApiError("""%s.checkValid: weight:
         NonNegativeFloat constraint float_value_ge_0 violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      if (not (value - value == 0.0)):
        raise ApiError("""%s.checkValid: weight:
         NonNegativeFloat constraint value_is_not_NaN_or_Infinity violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

      # check roles
      if (not ((dataDict.get('topObject').__dict__.get('isLoaded') or dataDict.get('topObject').__dict__.get('isReading')))):
        dataDict.get('topObject').load()

      value = dataDict.get('access')
      if (value is not None):
        from memops.api.AccessControl import AccessObject as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: access:
           value is not of class memops.AccessControl.AccessObject""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('dataObjects')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: access:
           non-reciprocal link CsaConstraint from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('constraintGroups')
      for value in values:
        if (not isinstance(value, ConstraintGroup)):
          raise ApiError("""%s.checkValid: constraintGroups:
           value is not of class ccp.nmr.NmrConstraint.ConstraintGroup""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('constraints')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: constraintGroups:
           non-reciprocal link CsaConstraint from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: constraintGroups:
           Link constraintGroups between objects from separate partitions
           - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      value = dataDict.get('method')
      if (value is not None):
        from ccp.api.general.Method import Method as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: method:
           value is not of class ccp.general.Method.Method""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('constraints')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: method:
           non-reciprocal link CsaConstraint from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = dataDict.get('nmrConstraintValidations')
      for value in values:
        from ccp.api.molecule.Validation import NmrConstraintValidation as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: nmrConstraintValidations:
           value is not of class ccp.molecule.Validation.NmrConstraintValidation""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelves = value.__dict__.get('nmrConstraints')
        if (not (self in oldSelves)):
          raise ApiError("""%s.checkValid: nmrConstraintValidations:
           non-reciprocal link CsaConstraint from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        yy2 = yy1.__dict__.get('nmrConstraintStore')
        if (not (xx1 is yy2)):
          raise ApiError("""%s.checkValid: nmrConstraintValidations:
           Link nmrConstraintValidations between objects from separate partitions
           - ccp.molecule.Validation.ValidationStore.nmrConstraintStore not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      value = dataDict.get('parentList')
      if (not isinstance(value, CsaConstraintList)):
        raise ApiError("""%s.checkValid: parentList:
         value is not of class ccp.nmr.NmrConstraint.CsaConstraintList""" % self.qualifiedName
         + ": %s" % (value,)
        )

      values = dataDict.get('peakContribs').values()
      for value in values:
        if (not isinstance(value, ConstraintPeakContrib)):
          raise ApiError("""%s.checkValid: peakContribs:
           value is not of class ccp.nmr.NmrConstraint.ConstraintPeakContrib""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('constraint')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: peakContribs:
           non-reciprocal link CsaConstraint from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

      values = self.getPeaks()
      for value in values:
        from ccp.api.nmr.Nmr import Peak as importedType
        if (not isinstance(value, importedType)):
          raise ApiError("""%s.checkValid: peaks:
           value is not of class ccp.nmr.Nmr.Peak""" % self.qualifiedName
           + ": %s" % (value,)
          )

        xx1 = dataDict.get('topObject')
        xx2 = xx1.__dict__.get('nmrProject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx2 is yy1)):
          raise ApiError("""%s.checkValid: peaks:
           Link peaks between objects from separate partitions
           - ccp.nmr.NmrConstraint.NmrConstraintStore.nmrProject not set correctly""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

      value = dataDict.get('resonance')
      if (not isinstance(value, FixedResonance)):
        raise ApiError("""%s.checkValid: resonance:
         value is not of class ccp.nmr.NmrConstraint.FixedResonance""" % self.qualifiedName
         + ": %s" % (value,)
        )

      oldSelves = value.__dict__.get('csaConstraints')
      if (not (self in oldSelves)):
        raise ApiError("""%s.checkValid: resonance:
         non-reciprocal link CsaConstraint from object""" % self.qualifiedName
         + ": %s" % (self,)
        )

      values = dataDict.get('violations')
      for value in values:
        if (not isinstance(value, Violation)):
          raise ApiError("""%s.checkValid: violations:
           value is not of class ccp.nmr.NmrConstraint.Violation""" % self.qualifiedName
           + ": %s" % (value,)
          )

        oldSelf = value.__dict__.get('constraint')
        if (not (oldSelf is self)):
          raise ApiError("""%s.checkValid: violations:
           non-reciprocal link CsaConstraint from object""" % self.qualifiedName
           + ": %s" % (self,)
          )

        xx1 = dataDict.get('topObject')
        yy1 = value.__dict__.get('topObject')
        if (not (xx1 is yy1)):
          raise ApiError("""%s.checkValid: violations:
           Link violations between objects from separate partitions
           - memops.Implementation.TopObject does not match""" % self.qualifiedName
           + ": %s:%s" % (self, value)
          )

    # check explicit class constraints
    # check attributes
    values = dataDict.get('applicationData')
    for value in values:
      value.checkAllValid(complete)

    value = dataDict.get('details')
    value = dataDict.get('error')
    value = dataDict.get('lowerLimit')
    value = dataDict.get('origData')
    value = dataDict.get('targetValue')
    value = dataDict.get('upperLimit')
    value = dataDict.get('weight')
    if (value is None):
      raise ApiError("""%s.checkValid: weight:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    # check roles
    value = dataDict.get('access')
    values = dataDict.get('constraintGroups')
    value = dataDict.get('method')
    values = dataDict.get('nmrConstraintValidations')
    for value in values:
      ll= value.keywordDefinition.targetNames
      isValid = (not ll or self.qualifiedName in ll)
      if (not (isValid)):
        raise ApiError("""%s.checkValid: nmrConstraintValidations:
         nmrConstraintValidations constraint KeywordDefinition_fits_Constraint violated by value""" % self.qualifiedName
         + ": %s" % (value,)
        )

    value = dataDict.get('parentList')
    if (value is None):
      raise ApiError("""%s.checkValid: parentList:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    values = dataDict.get('peakContribs').values()
    value = dataDict.get('resonance')
    if (value is None):
      raise ApiError("""%s.checkValid: resonance:
       value cannot be None""" % self.qualifiedName
       + ": %s" % (self,)
      )

    values = dataDict.get('violations')

  delete = memops.api.Implementation.DataObject.delete

  findAllApplicationData = memops.api.Implementation.DataObject.findAllApplicationData

  findAllConstraintGroups = AbstractConstraint.findAllConstraintGroups

  findAllNmrConstraintValidations = AbstractConstraint.findAllNmrConstraintValidations

  findAllPeakContribs = AbstractConstraint.findAllPeakContribs

  findAllPeaks = AbstractConstraint.findAllPeaks

  findAllViolations = AbstractConstraint.findAllViolations

  findFirstApplicationData = memops.api.Implementation.DataObject.findFirstApplicationData

  findFirstConstraintGroup = AbstractConstraint.findFirstConstraintGroup

  findFirstNmrConstraintValidation = AbstractConstraint.findFirstNmrConstraintValidation

  findFirstPeak = AbstractConstraint.findFirstPeak

  findFirstPeakContrib = AbstractConstraint.findFirstPeakContrib

  findFirstViolation = AbstractConstraint.findFirstViolation
  
  def get(self, name):
    """
    GetAttr for ccp.nmr.NmrConstraint.CsaConstraint
    """
    dataDict = self.__dict__
    return getattr(self, name)

  getAccess = memops.api.Implementation.DataObject.getAccess

  getApplicationData = memops.api.Implementation.DataObject.getApplicationData
  
  def getByKey(startObj, fullKey):
    """
    GetByKey for ccp.nmr.NmrConstraint.CsaConstraint
    """

    result = None
    if (startObj.__class__.__name__ == 'MemopsRoot'):
      if (3 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.CsaConstraint'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj0 = startObj
      objKey = fullKey[0]
      obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)
      if (obj1 is None):
        obj0.refreshTopObjects('ccp.nmr.NmrConstraint')
        obj1 = obj0.__dict__.get('nmrConstraintStores').get(objKey)

    else:
      if (2 != len(fullKey)):
        raise ApiError("""'ccp.nmr.NmrConstraint.CsaConstraint'.getByKey:
         getByKey called with fullKey of wrong length. Parameters:"""
         + ": %s:%s" % (startObj, fullKey)
        )

      obj1 = startObj

    if (obj1 is not None):
      if (not (obj1.__dict__.get('isLoaded'))):
        obj1.load()

      objKey = fullKey[-2]
      obj2 = obj1.__dict__.get('constraintLists').get(objKey)

      if (obj2 is not None):
        objKey = fullKey[-1]
        obj3 = obj2.__dict__.get('constraints').get(objKey)
        result = obj3

    return result

  getByKey = staticmethod(getByKey)

  getByNavigation = memops.api.Implementation.MemopsObject.getByNavigation

  getClassName = memops.api.Implementation.ComplexDataType.getClassName

  getConstraintGroups = AbstractConstraint.getConstraintGroups

  getDetails = AbstractConstraint.getDetails

  getError = SingleConstraint.getError

  getExpandedKey = memops.api.Implementation.MemopsObject.getExpandedKey

  getFieldNames = memops.api.Implementation.ComplexDataType.getFieldNames
  
  def getFullKey(self, useGuid=False):
    """
    GetFullKey for ccp.nmr.NmrConstraint.CsaConstraint
    """
    dataDict = self.__dict__
    result = list()

    obj2 = dataDict.get('parentList')
    obj1 = obj2.__dict__.get('nmrConstraintStore')

    if (useGuid):
      result.append(obj1.__dict__.get('guid'))
    else:
      result.append(obj1.__dict__.get('serial'))

    result.append(obj2.__dict__.get('serial'))
    result.append(dataDict.get('serial'))

    return result

  getInConstructor = memops.api.Implementation.ComplexDataType.getInConstructor

  getIsDeleted = memops.api.Implementation.MemopsObject.getIsDeleted
  
  def getLocalKey(self):
    """
    GetLocalKey for ccp.nmr.NmrConstraint.CsaConstraint
    """
    dataDict = self.__dict__
    result = dataDict.get('serial')
    return result

  getLowerLimit = SingleConstraint.getLowerLimit

  getMetaclass = memops.api.Implementation.ComplexDataType.getMetaclass

  getMethod = AbstractConstraint.getMethod

  getNmrConstraintValidations = AbstractConstraint.getNmrConstraintValidations

  getOrigData = AbstractConstraint.getOrigData

  getPackageName = memops.api.Implementation.ComplexDataType.getPackageName

  getPackageShortName = memops.api.Implementation.ComplexDataType.getPackageShortName
  
  def getParent(self):
    """
    Get for ccp.nmr.NmrConstraint.CsaConstraint.parent
    """
    dataDict = self.__dict__
    result = dataDict.get('parentList')
    return result
  
  def getParentList(self):
    """
    Get for ccp.nmr.NmrConstraint.CsaConstraint.parentList
    """
    dataDict = self.__dict__
    result = dataDict.get('parentList')
    return result

  getPeakContribs = AbstractConstraint.getPeakContribs

  getPeaks = AbstractConstraint.getPeaks

  getQualifiedName = memops.api.Implementation.ComplexDataType.getQualifiedName
  
  def getResonance(self):
    """
    Get for ccp.nmr.NmrConstraint.CsaConstraint.resonance
    """
    dataDict = self.__dict__
    result = dataDict.get('resonance')
    return result

  getRoot = memops.api.Implementation.MemopsObject.getRoot

  getSerial = AbstractConstraint.getSerial

  getTargetValue = SingleConstraint.getTargetValue

  getTopObject = memops.api.Implementation.DataObject.getTopObject

  getUpperLimit = SingleConstraint.getUpperLimit

  getViolations = AbstractConstraint.getViolations

  getWeight = AbstractConstraint.getWeight

  newConstraintPeakContrib = AbstractConstraint.newConstraintPeakContrib

  removeApplicationData = memops.api.Implementation.DataObject.removeApplicationData

  removeConstraintGroup = AbstractConstraint.removeConstraintGroup

  removeNmrConstraintValidation = AbstractConstraint.removeNmrConstraintValidation

  removePeak = AbstractConstraint.removePeak
  
  def set(self, name, value):
    """
    SetAttr for ccp.nmr.NmrConstraint.CsaConstraint
    """
    dataDict = self.__dict__
    setattr(self, name, value)

  setAccess = memops.api.Implementation.DataObject.setAccess

  setApplicationData = memops.api.Implementation.DataObject.setApplicationData

  setConstraintGroups = AbstractConstraint.setConstraintGroups

  setDetails = AbstractConstraint.setDetails

  setError = SingleConstraint.setError

  setLowerLimit = SingleConstraint.setLowerLimit

  setMethod = AbstractConstraint.setMethod

  setNmrConstraintValidations = AbstractConstraint.setNmrConstraintValidations

  setOrigData = AbstractConstraint.setOrigData

  setPeaks = AbstractConstraint.setPeaks
  
  def setResonance(self, value):
    """
    Set for ccp.nmr.NmrConstraint.CsaConstraint.resonance
    """
    dataDict = self.__dict__
    if (not isinstance(value, FixedResonance)):
      raise ApiError("""%s.setResonance:
       value is not of class ccp.nmr.NmrConstraint.FixedResonance""" % self.qualifiedName
       + ": %s" % (value,)
      )

    topObject = dataDict.get('topObject')
    currentValue = dataDict.get('resonance')
    notInConstructor = not (dataDict.get('inConstructor'))

    root = topObject.__dict__.get('memopsRoot')
    notOverride = not (root.__dict__.get('override'))
    notIsReading = not (topObject.__dict__.get('isReading'))
    notOverride = (notOverride and notIsReading)
    if (dataDict.get('isDeleted')):
      raise ApiError("""%s.setResonance:
       called on deleted object""" % self.qualifiedName
      )

    if (value is not None):
      if (value.__dict__.get('isDeleted')):
        raise ApiError("""%s.setResonance:
         called with deleted value""" % self.qualifiedName
        )

    if (value == currentValue):
      return

    if (notOverride):
      if (notInConstructor):
        raise ApiError("""%s.setResonance:
         cannot set resonance, frozen""" % self.qualifiedName
         + ": %s" % (self,)
        )

      if (value is None):
        raise ApiError("""%s.setResonance:
         value cannot be None""" % self.qualifiedName
         + ": %s" % (self,)
        )

      xx1 = dataDict.get('topObject')
      yy1 = value.__dict__.get('topObject')
      if (not (xx1 is yy1)):
        raise ApiError("""%s.setResonance:
         Link resonance between objects from separate partitions
         - memops.Implementation.TopObject does not match""" % self.qualifiedName
         + ": %s:%s" % (self, value)
        )

    if (currentValue is not None):
      if (notIsReading):
        oldSelves = currentValue.__dict__.get('csaConstraints')
        oldSelves.remove(self)
      else:
        raise ApiError("""%s.setResonance:
         Read link 'resonance' incompatible with pre-existing link""" % self.qualifiedName
         + ": %s" % (self,)
        )

    if (value is not None):
      newSelves = value.__dict__.get('csaConstraints')
      newSelves.add(self)

    dataDict['resonance'] = value

    # doNotifies

  setSerial = AbstractConstraint.setSerial

  setTargetValue = SingleConstraint.setTargetValue

  setUpperLimit = SingleConstraint.setUpperLimit

  setViolations = AbstractConstraint.setViolations

  setWeight = AbstractConstraint.setWeight

  sortedConstraintGroups = AbstractConstraint.sortedConstraintGroups

  sortedNmrConstraintValidations = AbstractConstraint.sortedNmrConstraintValidations

  sortedPeakContribs = AbstractConstraint.sortedPeakContribs

  sortedPeaks = AbstractConstraint.sortedPeaks

  sortedViolations = AbstractConstraint.sortedViolations

  toDetailedString = memops.api.Implementation.ComplexDataType.toDetailedString

  applicationData = memops.api.Implementation.DataObject.applicationData

  className = memops.api.Implementation.ComplexDataType.className

  details = AbstractConstraint.details

  error = SingleConstraint.error

  fieldNames = memops.api.Implementation.ComplexDataType.fieldNames

  inConstructor = memops.api.Implementation.ComplexDataType.inConstructor

  isDeleted = memops.api.Implementation.MemopsObject.isDeleted

  lowerLimit = SingleConstraint.lowerLimit

  metaclass = memops.api.Implementation.ComplexDataType.metaclass

  origData = AbstractConstraint.origData

  packageName = memops.api.Implementation.ComplexDataType.packageName

  packageShortName = memops.api.Implementation.ComplexDataType.packageShortName

  qualifiedName = memops.api.Implementation.ComplexDataType.qualifiedName

  serial = AbstractConstraint.serial

  targetValue = SingleConstraint.targetValue

  upperLimit = SingleConstraint.upperLimit

  weight = AbstractConstraint.weight

  access = memops.api.Implementation.DataObject.access

  constraintGroups = AbstractConstraint.constraintGroups

  method = AbstractConstraint.method

  nmrConstraintValidations = AbstractConstraint.nmrConstraintValidations
  
  parent = property(getParent, None, None,
  r"""link to parent object - synonym for parentList
  """)
  
  parentList = property(getParentList,  None, None,
  r"""parent link
  """)

  peakContribs = AbstractConstraint.peakContribs

  peaks = AbstractConstraint.peaks
  
  resonance = property(getResonance, setResonance, None,
  r"""FixedResonance holding Chemical shift anisotropy constraint.
  """)

  root = memops.api.Implementation.MemopsObject.root

  topObject = memops.api.Implementation.DataObject.topObject

  violations = AbstractConstraint.violations
