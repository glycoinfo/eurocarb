<?xml version='1.0'?>
<!--
#######################################################################

CCPN Data Model version 2.0.b2

Autogenerated by XmlModelIo revision 1.14.2.4 on ?
  from data model element ccp.molecule.ChemComp.LinkEnd revision ?

#######################################################################
======================COPYRIGHT/LICENSE START==========================

LinkEnd.xml: xmlmodel model for CCPN data model, MetaClass ccp.molecule.ChemComp.LinkEnd

Copyright (C) 2007  (CCPN Project)

=======================================================================

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.
 
A copy of this license can be found in ../../../../../license/LGPL.license
 
This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
Lesser General Public License for more details.
 
You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA


======================COPYRIGHT/LICENSE END============================

for further information, please contact :

- CCPN website (http://www.ccpn.ac.uk/)

- email: ccpn@bioc.cam.ac.uk

=======================================================================

If you are using this software for academic purposes, we suggest
quoting the following references:

===========================REFERENCE START=============================
Rasmus H. Fogh, Wayne Boucher, Wim F. Vranken, Anne
Pajon, Tim J. Stevens, T.N. Bhat, John Westbrook, John M.C. Ionides and
Ernest D. Laue (2005). A framework for scientific data modeling and automated
software development. Bioinformatics 21, 1678-1684.


This file was generated with the Memops software generation framework,
and contains original contributions embedded in the framework

===========================REFERENCE END===============================
-->

<MetaClass name="LinkEnd"
 guid="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:52_00030"
 container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:51_00046"
 isAbstract="false" isImplicit="false" isLeaf="false" isRoot="false"
 isSingleton="false" partitionsChildren="false" visibility="public_vis">
  <documentation>Describes one end of link to other ChemComp. 
linkAtoms[0] and chemAtoms[0] must be included in the same set of chemCompVars. linkAtoms[1] and chemAtoms[1] must be included in the same set of ChemCompVars as linkAtoms[0] or in a subset of it.

There are constraints on the linkEnd, linkEnd.linkCode, ChemCompVar and ChemCompVar.linking (see ChemCompVar documentation). To satisfy the constraints the LinkEnd must be created after the ChemCompVars are created and linked to the correct AbstractChemAtoms.</documentation>
  <keyNames>
    <item>linkCode</item>
  </keyNames>
  <supertypes>
    <item>www.ccpn.ac.uk_Fogh_2006-09-14-16:28:57_00005</item>
  </supertypes>
  <taggedValues>
    <item tag="repositoryId">$Id: LinkEnd.xml,v 1.47.2.9 2009/03/11 17:20:01 rhfogh Exp $</item>
    <item tag="repositoryTag">$Name: release_2_0_8_3 $</item>
  </taggedValues>

  <!-- Start constraints for <MetaClass: ccp.molecule.ChemComp.LinkEnd>: -->
  <MetaConstraint name="both_link_atoms_in_same_chemCompVars"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:52_00033"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:52_00030"
   isImplicit="false">
    <codeStubs>
      <item tag="java">// NB the boundLinkAtom defines which ChemCompVars have the link; therefore the test is not symmetrical.
ccp.api.molecule.ChemComp.LinkAtom x = getRemoteLinkAtom();
ccp.api.molecule.ChemComp.LinkAtom y = getBoundLinkAtom();
isValid = true;

if (x != null) {
  java.util.Collection xChemCompVars = x.getChemCompVars();
  for (ccp.api.molecule.ChemComp.ChemCompVar z: y.getChemCompVars()) {
    if (!xChemCompVars.contains(z)) {
      isValid = false;
      break;
    }
  }
}
</item>
      <item tag="python"># NB the boundLinkAtom defines which ChemCompVars have the link; therefore the test is not symmetrical.
x = self.remoteLinkAtom
y = self.boundLinkAtom
if x is None:
  isValid = True
else:
  isValid = not [z for z in y.chemCompVars if z not in x.chemCompVars]
</item>
    </codeStubs>
  </MetaConstraint>
  <MetaConstraint name="chemAtoms_in_same_chemCompVars_as_linkAtoms"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:52_00034"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:52_00030"
   isImplicit="false">
    <codeStubs>
      <item tag="java">// NB the boundLinkAtom defines which ChemCompVars have the link; therefore the test is not symmetrical.
isValid = true;

ccp.api.molecule.ChemComp.AbstractChemAtom y = getBoundLinkAtom();
ccp.api.molecule.ChemComp.AbstractChemAtom z = getBoundChemAtom();
ccp.api.molecule.ChemComp.AbstractChemAtom w = getRemoteChemAtom();

java.util.Set zChemCompVars = z.getChemCompVars();

for (ccp.api.molecule.ChemComp.ChemCompVar ccv: y.getChemCompVars()) {
  if (!zChemCompVars.contains(ccv)) {
    isValid = false;
    break;
  }
}

if (w != null) {
  java.util.Set wChemCompVars = w.getChemCompVars();
  for (ccp.api.molecule.ChemComp.ChemCompVar ccv: y.getChemCompVars()) {
    if (!wChemCompVars.contains(ccv)) {
      isValid = false;
      break;
    }
  }
}
</item>
      <item tag="python">ll1 = self.boundLinkAtom.chemCompVars
isValid = True
ll = [self.boundChemAtom]
x = self.remoteChemAtom
if x is not None:
  ll.append(x)
for ca in ll:
  if [x for x in ll1 if x not in ca.chemCompVars]:
    isValid = False
</item>
    </codeStubs>
  </MetaConstraint>
  <MetaConstraint name="linear_polymer_linkcodes_must_fit_chemCompVars"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:52_00035"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:52_00030"
   isImplicit="false">
    <codeStubs>
      <item tag="java">java.lang.String linkCode = getLinkCode();
isValid = true;
if ("prev".equals(linkCode) || "next".equals(linkCode)) {
  ccp.api.molecule.ChemComp.ChemComp chemComp = getChemComp();
  java.util.Set l1 = null;
   if ("next".equals(linkCode))
    l1 = chemComp.findAllChemCompVars("linking", "start");
  else if ("prev".equals(linkCode))
    l1 = chemComp.findAllChemCompVars("linking", "end");

  java.util.Set ll = chemComp.findAllChemCompVars("linking", "middle");
  ll.addAll(l1);

  java.util.Set ccv = getChemCompVars();
  if (!ll.equals(ccv))
    isValid = false;
}
</item>
      <item tag="python">linkCode = self.linkCode
isValid = True
if linkCode in ('next','prev'):
  chemComp = self.chemComp
  if linkCode == 'next':
    l1 = chemComp.findAllChemCompVars(linking='start')
  elif linkCode == 'prev':
    l1 = chemComp.findAllChemCompVars(linking='end')
  ll = chemComp.findAllChemCompVars(linking='middle')
  ll.update(l1)
  if self.chemCompVars != ll:
    isValid = False
</item>
    </codeStubs>
  </MetaConstraint>
  <MetaConstraint name="linkCode_conforms_to_boundChemAtom_name"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:52_00036"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:52_00030"
   isImplicit="false">
    <codeStubs>
      <item tag="java"> java.lang.String value = getLinkCode();
if ("next".equals(value) || "prev".equals(value) || value==null) {
  isValid = true;
} else {
  java.lang.String atname = getBoundChemAtom().getName();
  isValid = false;
  if (value.equals(atname)) {
    isValid = true;
  } else if (value.startsWith(atname)) {
    int n = value.length();
    if ("_".equals(value.substring(n-2, n-1)) &amp;&amp; ("123456789".indexOf(value.substring(n-1)) != -1))
      isValid = true;
  }
}
</item>
      <item tag="python">value = self.linkCode
if value in ('prev', 'next', None):
  isValid = True
else:

  atname = self.boundChemAtom.name

  if value == atname:
    isValid = True

  elif value.startswith(atname) and  value[-2] == '_' and value[-1] in '123456789':
    isValid = True 

  else:
    isValid = False
</item>
    </codeStubs>
  </MetaConstraint>
  <MetaConstraint name="selected_atoms_must_define_torsion"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:52_00032"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:52_00030"
   isImplicit="false">
    <codeStubs>
      <item tag="java">isValid = false;
ccp.api.molecule.ChemComp.AbstractChemAtom x = getRemoteChemAtom();
ccp.api.molecule.ChemComp.AbstractChemAtom y = getBoundChemAtom();
ccp.api.molecule.ChemComp.AbstractChemAtom z = getBoundLinkAtom();
ccp.api.molecule.ChemComp.AbstractChemAtom w = getRemoteLinkAtom();
if (x == null || w == null)
{
  isValid = true;
} else {
  ccp.api.molecule.ChemComp.ChemComp chemComp = getChemComp();
  java.util.List&lt;ccp.api.molecule.ChemComp.AbstractChemAtom&gt; ll = new java.util.ArrayList&lt;ccp.api.molecule.ChemComp.AbstractChemAtom&gt;();
  ll.add(x);
  ll.add(y);
  ll.add(z);
  ll.add(w);
  ccp.api.molecule.ChemComp.ChemTorsion tors = chemComp.findFirstChemTorsion("chemAtoms", ll);
  if (tors != null) {
    isValid = true;
  } else {
    java.util.Collections.reverse(ll);
    tors =  chemComp.findFirstChemTorsion("chemAtoms", ll);
    if (tors != null)
      isValid = true;
  }
}
</item>
      <item tag="python">x = self.remoteChemAtom
y = self.boundChemAtom
z = self.boundLinkAtom
w = self.remoteLinkAtom
if x is None or w is None:
  isValid = True
else:
  isValid = (self.chemComp.findFirstChemTorsion(chemAtoms=(x, y, z, w)) or self.chemComp.findFirstChemTorsion(chemAtoms=(w, z, y, x)) ) and True
</item>
    </codeStubs>
  </MetaConstraint>
  <MetaConstraint name="selected_atoms_must_form_outofchemComp_bond"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:52_00031"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:52_00030"
   isImplicit="false">
    <codeStubs>
      <item tag="java">isValid = false;
ccp.api.molecule.ChemComp.AbstractChemAtom boundAtom = getBoundChemAtom();
ccp.api.molecule.ChemComp.AbstractChemAtom linkAtom = getBoundLinkAtom();
ccp.api.molecule.ChemComp.ChemComp chemComp = getChemComp();
java.util.List&lt;ccp.api.molecule.ChemComp.AbstractChemAtom&gt; ll = new java.util.ArrayList&lt;ccp.api.molecule.ChemComp.AbstractChemAtom&gt;();
ll.add(boundAtom);
ll.add(linkAtom);
ccp.api.molecule.ChemComp.ChemBond bond = chemComp.findFirstChemBond("chemAtoms", ll);
if (bond != null) {
  isValid = true;
} else {
  java.util.Collections.reverse(ll);
  bond =  chemComp.findFirstChemBond("chemAtoms", ll);
  if (bond != null)
    isValid = true;
}
</item>
      <item tag="python">ll = (self.boundChemAtom, self.boundLinkAtom)
isValid = (self.chemComp.findFirstChemBond(chemAtoms=ll) or self.chemComp.findFirstChemBond(chemAtoms=(ll[1], ll[0])) ) and True
</item>
    </codeStubs>
  </MetaConstraint>
  <!-- End constraints for <MetaClass: ccp.molecule.ChemComp.LinkEnd>: -->


  <MetaRole name="boundChemAtom"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:25_00011"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:52_00030"
   baseName="boundChemAtom" changeability="frozen" hicard="1" isAbstract="false"
   isAutomatic="false" isDerived="false" isImplementation="false"
   isImplicit="false" isOrdered="false" isUnique="true" locard="1"
   noDeleteIfSet="false" partitionsChildren="false" scope="instance_level"
   visibility="public_vis">
    <documentation>One of the AbstractChemAtoms making up the Link. The direct bond is betweeen boundChemAtom (within this ChemComp) and boundLinkAtom (outside this ChemComp). The optional remoteChemAtom (within this ChemComp) and remoteLinkAtom (outside this ChemComp) arebound to the their respective boundAtoms. If defined they serve to define angles and torsions that involve the out-of-ChemComp bond.</documentation>
    <otherRole>www.ccpn.ac.uk_Fogh_2006-08-16-18:23:25_00010</otherRole>
    <valueType>www.ccpn.ac.uk_Fogh_2006-08-16-14:22:52_00037</valueType>
  </MetaRole>

  <MetaRole name="boundLinkAtom"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:25_00013"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:52_00030"
   baseName="boundLinkAtom" changeability="frozen" hicard="1" isAbstract="false"
   isAutomatic="false" isDerived="false" isImplementation="false"
   isImplicit="false" isOrdered="false" isUnique="true" locard="1"
   noDeleteIfSet="false" partitionsChildren="false" scope="instance_level"
   visibility="public_vis">
    <documentation>One of the AbstractChemAtoms making up the Link. The direct bond is betweeen boundChemAtom (within this ChemComp) and boundLinkAtom (outside this ChemComp). The optional remoteChemAtom (within this ChemComp) and remoteLinkAtom (outside this ChemComp) arebound to the their respective boundAtoms. If defined they serve to define angles and torsions that involve the out-of-ChemComp bond.</documentation>
    <otherRole>www.ccpn.ac.uk_Fogh_2006-08-16-18:23:25_00012</otherRole>
    <valueType>www.ccpn.ac.uk_Fogh_2006-08-16-14:22:52_00038</valueType>
  </MetaRole>

  <MetaRole name="chemComp"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:21_00004"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:52_00030"
   aggregation="composite" baseName="chemComp" changeability="frozen" hicard="1"
   hierarchy="parent" isAbstract="false" isAutomatic="false" isDerived="false"
   isImplementation="false" isImplicit="false" isOrdered="false" isUnique="true"
   locard="1" noDeleteIfSet="false" partitionsChildren="false"
   scope="instance_level" visibility="public_vis">
    <otherRole>www.ccpn.ac.uk_Fogh_2006-08-16-18:23:21_00005</otherRole>
    <valueType>www.ccpn.ac.uk_Fogh_2006-08-16-14:22:51_00047</valueType>
  </MetaRole>

  <MetaRole name="chemCompVars"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:25_00017"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:52_00030"
   baseName="chemCompVar" changeability="frozen" hicard="-1" isAbstract="false"
   isAutomatic="false" isDerived="true" isImplementation="false"
   isImplicit="false" isOrdered="false" isUnique="true" locard="0"
   noDeleteIfSet="false" partitionsChildren="false" scope="instance_level"
   visibility="public_vis">
    <documentation>ChemCompVars that hold LinkEnd</documentation>
    <otherRole>www.ccpn.ac.uk_Fogh_2006-08-16-18:23:25_00016</otherRole>
    <valueType>www.ccpn.ac.uk_Fogh_2006-08-16-14:22:52_00005</valueType>
  </MetaRole>

  <MetaOperation name="getChemCompVars"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:25_00025"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:52_00030"
   isAbstract="false" isImplicit="false" isQuery="true" opType="get"
   scope="instance_level" visibility="public_vis">
    <documentation>getter for derived link chemCompVars</documentation>
    <target>www.ccpn.ac.uk_Fogh_2006-08-16-18:23:25_00017</target>
    <codeStubs>
      <item tag="java">result = getBoundLinkAtom().getChemCompVars();</item>
      <item tag="python">result = self.boundLinkAtom.chemCompVars</item>
    </codeStubs>
  </MetaOperation>

  <MetaAttribute name="linkCode"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:25_00024"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:52_00030"
   baseName="linkCode" changeability="frozen" hicard="1" isAbstract="false"
   isAutomatic="false" isDerived="false" isImplementation="false"
   isImplicit="false" isOrdered="false" isUnique="true" locard="1"
   scope="instance_level" visibility="public_vis">
    <documentation>code ('name') for link. The following naming convention is used:
The linkCode is the same as the name of the boundChemAtom. E.g. a cysteine disulfide link will have linkCode 'SG'. The first exception is the case where there is more than one link starting at the same atom - here the linkCodes are the name of the first linkAtom followed by '_1', '_2'. E.g. an atom CX with three links starting from it will have linkEnds with linkCodes CX_1, CX_2, CX_3. If two different atom subtypes both have a link, the linkCodes are of the same form - there are no fixed rules for how to apportion the various suffixes. Another exception is the 'prev' and 'next' that form the backbone of linear polymers.</documentation>
    <valueType>www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00037</valueType>
  </MetaAttribute>

  <MetaRole name="remoteChemAtom"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:25_00019"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:52_00030"
   baseName="remoteChemAtom" changeability="frozen" hicard="1"
   isAbstract="false" isAutomatic="false" isDerived="false"
   isImplementation="false" isImplicit="false" isOrdered="false" isUnique="true"
   locard="0" noDeleteIfSet="false" partitionsChildren="false"
   scope="instance_level" visibility="public_vis">
    <documentation>One of the AbstractChemAtoms making up the Link. The direct bond is betweeen boundChemAtom (within this ChemComp) and boundLinkAtom (outside this ChemComp). The optional remoteChemAtom (within this ChemComp) and remoteLinkAtom (outside this ChemComp) arebound to the their respective boundAtoms. If defined they serve to define angles and torsions that involve the out-of-ChemComp bond.</documentation>
    <otherRole>www.ccpn.ac.uk_Fogh_2006-08-16-18:23:25_00018</otherRole>
    <valueType>www.ccpn.ac.uk_Fogh_2006-08-16-14:22:52_00037</valueType>
  </MetaRole>

  <MetaRole name="remoteLinkAtom"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:25_00021"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:52_00030"
   baseName="remoteLinkAtom" changeability="frozen" hicard="1"
   isAbstract="false" isAutomatic="false" isDerived="false"
   isImplementation="false" isImplicit="false" isOrdered="false" isUnique="true"
   locard="0" noDeleteIfSet="false" partitionsChildren="false"
   scope="instance_level" visibility="public_vis">
    <documentation>One of the AbstractChemAtoms making up the Link. The direct bond is betweeen boundChemAtom (within this ChemComp) and boundLinkAtom (outside this ChemComp). The optional remoteChemAtom (within this ChemComp) and remoteLinkAtom (outside this ChemComp) arebound to the their respective boundAtoms. If defined they serve to define angles and torsions that involve the out-of-ChemComp bond.</documentation>
    <otherRole>www.ccpn.ac.uk_Fogh_2006-08-16-18:23:25_00020</otherRole>
    <valueType>www.ccpn.ac.uk_Fogh_2006-08-16-14:22:52_00038</valueType>
  </MetaRole>
</MetaClass>

