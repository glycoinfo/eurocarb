<?xml version='1.0'?>
<!--
#######################################################################

CCPN Data Model version 2.0.b2

Autogenerated by XmlModelIo revision 1.14.2.4 on ?
  from data model element ccp.molecule.ChemComp.ChemCompVar revision ?

#######################################################################
======================COPYRIGHT/LICENSE START==========================

ChemCompVar.xml: xmlmodel model for CCPN data model, MetaClass ccp.molecule.ChemComp.ChemCompVar

Copyright (C) 2007  (CCPN Project)

=======================================================================

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.
 
A copy of this license can be found in ../../../../../license/LGPL.license
 
This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
Lesser General Public License for more details.
 
You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA


======================COPYRIGHT/LICENSE END============================

for further information, please contact :

- CCPN website (http://www.ccpn.ac.uk/)

- email: ccpn@bioc.cam.ac.uk

=======================================================================

If you are using this software for academic purposes, we suggest
quoting the following references:

===========================REFERENCE START=============================
Rasmus H. Fogh, Wayne Boucher, Wim F. Vranken, Anne
Pajon, Tim J. Stevens, T.N. Bhat, John Westbrook, John M.C. Ionides and
Ernest D. Laue (2005). A framework for scientific data modeling and automated
software development. Bioinformatics 21, 1678-1684.


This file was generated with the Memops software generation framework,
and contains original contributions embedded in the framework

===========================REFERENCE END===============================
-->

<MetaClass name="ChemCompVar"
 guid="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:52_00005"
 container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:51_00046"
 isAbstract="false" isImplicit="false" isLeaf="false" isRoot="false"
 isSingleton="false" partitionsChildren="false" visibility="public_vis">
  <documentation>ChemComp with a given chain location (for polymers) or sybstitution/lin king pattern (for non-polymers) and a given topological variant. Topological variants are e.g. protonation states, and in general topological variations that can change over time for a given molecule. For Polymers topological variations (defined through the descriptor attribute) also include linking patterns in addition to those that make up the linear polymer links.

A Polymer ChemComp is any ChemComp with at least one ChemCompVar with  linking 'start', 'middle', or 'end'.  
If linking is 'start', there must be a 'next' link but no 'prev' link
if linking is 'end' there must be a 'prev' link but no 'next' link
if linking is 'middle' there must be both a 'next' and 'a prev'
if linking is neither there must be neither a 'next' nor a 'prev' link
if linking is 'none' and the ChemComp is not a linear polymer, there must be no links at all.
If there are no links, liking must be 'none'

The relevant constraints are placed on ChemCompVar and LinkEnd.</documentation>
  <keyNames>
    <item>linking</item>
    <item>descriptor</item>
  </keyNames>
  <supertypes>
    <item>www.ccpn.ac.uk_Fogh_2006-09-14-16:28:57_00005</item>
  </supertypes>
  <taggedValues>
    <item tag="repositoryId">$Id: ChemCompVar.xml,v 1.52.2.10 2009/03/11 17:20:00 rhfogh Exp $</item>
    <item tag="repositoryTag">$Name: release_2_0_8_3 $</item>
  </taggedValues>

  <!-- Start constraints for <MetaClass: ccp.molecule.ChemComp.ChemCompVar>: -->
  <MetaConstraint name="Atom_name_is_unique_within_ChemCompVar"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:52_00007"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:52_00005"
   isImplicit="false">
    <codeStubs>
      <item tag="java">java.util.Set&lt;java.lang.String&gt; dd = new java.util.HashSet&lt;java.lang.String&gt;();
int nn = 0;
for (ccp.api.molecule.ChemComp.AbstractChemAtom ca: getChemAtoms()) {
  dd.add(ca.getName());
  nn++;
}

if (dd.size() == nn)
  isValid = true;
else
  isValid = false;
</item>
      <item tag="python">ll = self.chemAtoms
isValid = (len(ll) == len(set(x.name for x in ll)))
</item>
    </codeStubs>
  </MetaConstraint>
  <MetaConstraint name="relationship_between_linkings_linkCodes_and_isLinearPolymer"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:52_00006"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:52_00005"
   isImplicit="false">
    <codeStubs>
      <item tag="java">java.util.Set&lt;java.lang.String&gt; le = new java.util.HashSet&lt;java.lang.String&gt;();
for (ccp.api.molecule.ChemComp.LinkEnd linkend: getLinkEnds())
  le.add(linkend.getLinkCode());

java.lang.String linking = getLinking();
isValid = true;

// none means no links, except for linear polymers
if ("none".equals(linking)) {
  if (!le.isEmpty() &amp;&amp; !getChemComp().getIsLinearPolymer())
    isValid = false;

// no links always means that linking must be 'none'
} else if (le.isEmpty()) {
  isValid = false;

// 'start' linking incompatible with 'prev' link
} else if ("start".equals(linking)) {
  if (le.contains("prev"))
    isValid = false;

// 'end' linking incompatible with 'next' link
} else if ("end".equals(linking)) {
  if (le.contains("next"))
    isValid = false;

// 'prev' and 'next' links require 'start', 'middle', or 'end' linking
} else if (!"middle".equals(linking)) {
  if (le.contains("prev") || le.contains("next"))
    isValid = false;
}
</item>
      <item tag="python"># set up
le = set(x.linkCode for x in self.linkEnds)
linking = self.linking
isValid = True

# none means no links, except for linear polymers
if linking == 'none':
  if le and not self.chemComp.isLinearPolymer:
    isValid = False

# no links always means that linking must be 'none'
elif not le:
  isValid = False

# 'start' linking incompatible with 'prev' link
elif linking == 'start':
  if 'prev' in le:
    isValid = False

# 'end' linking incompatible with 'next' link
elif linking == 'end':
  if 'next' in le:
    isValid = False

# 'prev' and 'next' links require 'start', 'middle', or 'end' linking
elif linking != 'middle':
  if 'prev' in le or 'next' in le:
    isValid = False
</item>
    </codeStubs>
  </MetaConstraint>
  <!-- End constraints for <MetaClass: ccp.molecule.ChemComp.ChemCompVar>: -->


  <MetaRole name="chemAngles"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:23_00021"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:52_00005"
   baseName="chemAngle" changeability="frozen" hicard="-1" isAbstract="false"
   isAutomatic="false" isDerived="true" isImplementation="false"
   isImplicit="false" isOrdered="false" isUnique="true" locard="0"
   noDeleteIfSet="false" partitionsChildren="false" scope="instance_level"
   visibility="public_vis">
    <documentation>chemAngles that lie within ChemCompVar</documentation>
    <valueType>www.ccpn.ac.uk_Fogh_2006-08-16-14:22:51_00054</valueType>
  </MetaRole>

  <MetaRole name="chemAtomSets"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:23_00023"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:52_00005"
   baseName="chemAtomSet" changeability="frozen" hicard="-1" isAbstract="false"
   isAutomatic="false" isDerived="true" isImplementation="false"
   isImplicit="false" isOrdered="false" isUnique="true" locard="0"
   noDeleteIfSet="false" partitionsChildren="false" scope="instance_level"
   visibility="public_vis">
    <documentation>ChemAtomSets contained in ChemCompVar. The setsa are </documentation>
    <valueType>www.ccpn.ac.uk_Fogh_2006-08-16-14:22:52_00014</valueType>
  </MetaRole>

  <MetaRole name="chemAtoms"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:22_00017"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:52_00005"
   baseName="chemAtom" changeability="changeable" hicard="-1" isAbstract="false"
   isAutomatic="false" isDerived="false" isImplementation="false"
   isImplicit="false" isOrdered="false" isUnique="true" locard="0"
   noDeleteIfSet="false" partitionsChildren="false" scope="instance_level"
   visibility="public_vis">
    <documentation>AbstractChemAtoms making up ChemCompVar</documentation>
    <otherRole>www.ccpn.ac.uk_Fogh_2006-08-16-18:23:22_00018</otherRole>
    <valueType>www.ccpn.ac.uk_Fogh_2006-08-16-14:22:52_00001</valueType>
  </MetaRole>

  <MetaRole name="chemBonds"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:23_00022"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:52_00005"
   baseName="chemBond" changeability="frozen" hicard="-1" isAbstract="false"
   isAutomatic="false" isDerived="true" isImplementation="false"
   isImplicit="false" isOrdered="false" isUnique="true" locard="0"
   noDeleteIfSet="false" partitionsChildren="false" scope="instance_level"
   visibility="public_vis">
    <documentation>Bonds contained in ChemCompVar</documentation>
    <valueType>www.ccpn.ac.uk_Fogh_2006-08-16-14:22:52_00003</valueType>
  </MetaRole>

  <MetaRole name="chemComp"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:20_00009"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:52_00005"
   aggregation="composite" baseName="chemComp" changeability="frozen" hicard="1"
   hierarchy="parent" isAbstract="false" isAutomatic="false" isDerived="false"
   isImplementation="false" isImplicit="false" isOrdered="false" isUnique="true"
   locard="1" noDeleteIfSet="false" partitionsChildren="false"
   scope="instance_level" visibility="public_vis">
    <otherRole>www.ccpn.ac.uk_Fogh_2006-08-16-18:23:20_00010</otherRole>
    <valueType>www.ccpn.ac.uk_Fogh_2006-08-16-14:22:51_00047</valueType>
  </MetaRole>

  <MetaRole name="chemCompSysNames"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:23_00014"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:52_00005"
   baseName="chemCompSysName" changeability="frozen" hicard="-1"
   isAbstract="false" isAutomatic="false" isDerived="true"
   isImplementation="false" isImplicit="false" isOrdered="false" isUnique="true"
   locard="0" noDeleteIfSet="false" partitionsChildren="false"
   scope="instance_level" visibility="public_vis">
    <documentation>All chemCompSysNames relevant to ChemCompVar</documentation>
    <otherRole>www.ccpn.ac.uk_Fogh_2006-08-16-18:23:23_00015</otherRole>
    <valueType>www.ccpn.ac.uk_Fogh_2006-08-16-14:22:52_00004</valueType>
  </MetaRole>

  <MetaRole name="chemTorsions"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:23_00020"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:52_00005"
   baseName="chemTorsion" changeability="frozen" hicard="-1" isAbstract="false"
   isAutomatic="false" isDerived="true" isImplementation="false"
   isImplicit="false" isOrdered="false" isUnique="true" locard="0"
   noDeleteIfSet="false" partitionsChildren="false" scope="instance_level"
   visibility="public_vis">
    <documentation>chemTorsions that lie within ChemCompVar</documentation>
    <valueType>www.ccpn.ac.uk_Fogh_2006-08-16-14:22:52_00008</valueType>
  </MetaRole>

  <MetaAttribute name="descriptor"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:23_00029"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:52_00005"
   baseName="descriptor" changeability="frozen" hicard="1" isAbstract="false"
   isAutomatic="false" isDerived="false" isImplementation="false"
   isImplicit="false" isOrdered="false" isUnique="true" locard="1"
   scope="instance_level" visibility="public_vis">
    <documentation>Short string distinguishing the topological variant of the ChemCompVar (e.g. protonation state) of the ChemCompVar. For ChemComps of linear polymer type (only) also distinguishes substitution patterns not related to the polymer bonds. The formatting rules are complex - see comment in 'descriptor_format_rule' constraint for details.</documentation>
    <valueType>www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00033</valueType>

    <!-- Start constraints for <MetaAttribute: ccp.molecule.ChemComp.ChemCompVar.descriptor>: -->
    <MetaConstraint name="descriptor_format_rule"
     guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:23_00030"
     container="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:23_00029"
     isImplicit="false">
      <codeStubs>
        <item tag="java">/*
  a descriptor is a semicolon-separated string of individual descriptors
  an individual descriptor is of the form : tag:atName(,atName)+
  the tags must appear in the order given in validTags,
  and the atoms must be present
  examples: 'prot:HD1''  'prot:HD1,HO;deprot:H1;link:SG' 'stereo_2:C1'
  'link:C2_2'
  The ''link' tag is an exception, in that the 'atNames' are actually
  LinkEnd.linkCodes. These are atom names, but may in some cases have a '_n'
  suffix where n is an integer. The linkCodes must correspond to linkEnds present in the ChemCompVar
  For all other atNames after the tag, atom (name=atName)
  must be present in  the ChemCompVar
  'stereo' tags are of the form stereo_n, where n is a subType no.
  and are the only tags to contain an underscore
  Here, for all atNames after the tag, atom (name=atName, subType=subTypeNo)
  must be present in  the ChemCompVar. The interpretation is that these
  atom subtypes are chosen to give the correct stereochemistry; what that
  stereochemistry is cna be seen by examining the atom network.
*/

//  valid special descriptor
java.util.List&lt;java.lang.String&gt; validDescriptors = new java.util.ArrayList&lt;java.lang.String&gt;();
validDescriptors.add("neutral");

// valid tags (key) and the order they must appear in (value)
java.util.Map&lt;java.lang.String, java.lang.Integer&gt; validTags = new java.util.HashMap&lt;java.lang.String, java.lang.Integer&gt;();
validTags.put("prot", 0);
validTags.put("deprot", 1);
validTags.put("link", 2);
validTags.put("stereo", 3);

isValid = true;
if ((value != null) &amp;&amp; !validDescriptors.contains(value)) {
  java.util.Set&lt;java.lang.String&gt; chemAtomNames = new java.util.HashSet&lt;java.lang.String&gt;();
  java.util.Set&lt;java.lang.String&gt; linkAtomNames = new java.util.HashSet&lt;java.lang.String&gt;();
  
  ccp.api.molecule.ChemComp.ChemComp chemComp = getChemComp();
  for (ccp.api.molecule.ChemComp.AbstractChemAtom ca: chemComp.getChemAtoms()) {
    if (ca instanceof ccp.api.molecule.ChemComp.ChemAtom)
      chemAtomNames.add(ca.getName());
    else
      linkAtomNames.add(ca.getName());
  }

  int tagIndex = -1;
  for (java.lang.String desc: value.split(";")) {
    java.lang.String[] strings1 = desc.split(":", 2);
    if (strings1.length != 2)
    {
      // no colon in descriptor
      java.lang.System.out.println("Malformed descriptor " + value + ": '" + desc + "' does not contain ':'");
      isValid = false;
      break;
    }
    
    int subNo = 0;
    int lastSubNo = 0;
    java.lang.String tag = strings1[0];
    java.lang.String text = strings1[1];

    // check that tags come in order,
    // and that _subType come in order for each tag type
    java.lang.String[] splitTag = tag.split("_");
    tag = splitTag[0];
    if (splitTag.length &gt; 1) {
      if ("stereo".equals(tag)) {
        subNo = java.lang.Integer.parseInt(splitTag[1]);
      } else {
        java.lang.System.out.println("Malformed descriptor " + value + ": '"+  tag + "': only 'stereo' tag may contain underscore");
        isValid = false;
        break;
      }
    } else {
      subNo = 0;
    }

    java.lang.Integer ii = validTags.get(tag);
    if (ii == null) {
      // tag validity
      java.lang.System.out.println("Malformed descriptor " + value + ": '"+  tag + "' is not a valid tag");
      isValid = false;
      break;
    } else if (ii &lt; tagIndex) {
      // tag order
      java.lang.System.out.println("Malformed descriptor " + value + ": '"+  tag + "' appears out of sequence");
      isValid = false;
      break;
    } else if (ii == tagIndex) {
      if (subNo &lt;= lastSubNo) {
        // tags with subNo not presented in order
        java.lang.System.out.println("Malformed descriptor " + value + ": '"+  desc + "' is out of order");
        isValid = false;
        break;
      }
    } else {
      // moved on to next type of tag
      tagIndex = ii;
    }

    lastSubNo = subNo;

    if ("link".equals(tag)) {
      if (!getChemComp().getIsLinearPolymer()) {
        java.lang.System.out.println("Malformed descriptor " + value + ": only linear polymer ChemComps may have 'link' descriptors");
        isValid = false;
        break;
      }

      java.util.List&lt;java.lang.String&gt; linkCodes = new java.util.ArrayList&lt;java.lang.String&gt;();
      for (java.lang.String ss: text.split(","))
        linkCodes.add(ss);

      java.lang.String[] np = { "next", "prev" };
      for (java.lang.String ss: np) {
        if (linkCodes.contains(ss)) {
          java.lang.System.out.println("Malformed descriptor " + value + ": 'link:' section contains " + ss);
          isValid = false;
          break;
        }
      }

      for (java.lang.String lc: linkCodes) {
        if (chemComp.findFirstLinkEnd("linkCode", lc) == null) {
          java.lang.System.out.println("Malformed descriptor " + value + ": 'link:' " + lc + " is not a known linkCode");
          isValid = false;
          break;
        }
      }

      java.util.List&lt;java.lang.String&gt; atNames = new java.util.ArrayList&lt;java.lang.String&gt;();
      for (java.lang.String ss: text.split(",")) {
        java.lang.String[] tt = ss.split("_", 2);
        atNames.add(tt[0]);
        if ((tt.length &gt; 1) &amp;&amp; (!linkAtomNames.contains(tt[1]))) {
          java.lang.System.out.println("Malformed descriptor " + value + ": atom name " + tt[1] + " is not a LinkAtom name for ChemCompVar");
          isValid = false;
          break;
        }
      }
    } else {
      java.lang.String[] atNames = text.split(",");

      if ("stereo".equals(tag)) {
        for (java.lang.String aa: atNames) {
          if (findFirstChemAtom("name", aa, "subType", subNo) == null) {
            java.lang.System.out.println("Malformed descriptor " + value + ": atom name " + aa + " subtype " + subNo + " is not in ChemCompVar");
            isValid = false;
            break;
          }
        }
      } else {
        for (java.lang.String aa: atNames) {
          if (!chemAtomNames.contains(aa)) {
            java.lang.System.out.println("Malformed descriptor " + value + ": atom name " + aa + " is not in ChemCompVar");
            isValid = false;
            break;
          }
        }
      }
    }

    if (!isValid)
      break;
  }
}
</item>
        <item tag="python"># a descriptor is a semicolon-separated string of individual descriptors
# an individual descriptor is of the form : tag:atName(,atName)+
# the tags must appear in the order given in validTags,
# and the atoms must be present
# examples: 'prot:HD1''  'prot:HD1,HO;deprot:H1;link:SG' 'stereo_2:C1'
# 'link:C2_2'
# The ''link' tag is an exception, in that the 'atNames' are actually 
# LinkEnd.linkCodes. These are atom names, but may in some cases have a '_n'
# suffix where n is an integer. The linkCodes must correspond to linkEnds present in the ChemCompVar
# For all other atNames after the tag, atom (name=atName) 
# must be present in  the ChemCompVar
# 'stereo' tags are of the form stereo_n, where n is a subType no.
# and are the only tags to contain an underscore
# Here, for all atNames after the tag, atom (name=atName, subType=subTypeNo)
# must be present in  the ChemCompVar. The interpretation is that these
# atom subtypes are chosen to give the correct stereochemistry; what that
# stereochemistry is cna be seen by examining the atom network.

# valid special descriptor
validDescriptors = ('neutral',)

# valid tags (key) and the order they must appear in (value)
validTags = {'prot':0, 'deprot':1, 'link':2, 'stereo':3,}

isValid = True
if value is not None and value not in validDescriptors:

  chemAtomNames = set()
  linkAtomNames = set()
  for ca in self.chemComp.chemAtoms:
    if isinstance(ca, ChemAtom):
      chemAtomNames.add(ca.name)
    else:
      linkAtomNames.add(ca.name)

  tagIndex = -1
  for desc in value.split(';'):

    try:
      (tag, text) = desc.split(':', 1)
    except ValueError:
      # no colon in descriptor
      print("Malformed descriptor %s: %s does not contain ':'" % (value, `desc`))
      isValid = False
      break
    
    # check that tags come in order, 
    # and that _subType come in order for each tag type
    splitTag = tag.split('_')
    tag = splitTag[0]
    if len(splitTag) &gt; 1:
      if tag == 'stereo':
        subNo = int(splitTag[1])
      else:
        print(
         "Malformed descriptor %s: only 'stereo' tag may contain underscore'" 
         % value
        )
        isValid = False
        break
        
    else:
      subNo = 0 
    
    ii = validTags.get(tag)
    if ii is None:
      # tag validity
      print("Malformed descriptor %s: %s is not a valid tag" % (value, `tag`))
      isValid = False
      break
      
    elif ii &lt; tagIndex:
      # tag order
      print("Malformed descriptor %s: tag %s appears out of sequence" % (value, `tag`))
      isValid = False
      break
      
    elif ii == tagIndex:
      if subNo &lt;= lastSubNo:
        # tags with subNo not presented in order
        print("Malformed descriptor %s: %s is out of order" % (value, `desc`))
        isValid = False
        break
        
    else:
      # moved on to next type of tag
      tagIndex = ii
    
    lastSubNo = subNo

    if tag == 'link':
      if not self.chemComp.isLinearPolymer:
        print("Malformed descriptor %s: only linear polymer ChemComps may have 'link' descriptors" % (value,))
        isValid = False
        break
      linkCodes = text.split(',')
      for ss in ('next', 'prev'):
        if ss in linkCodes:
          print ("Malformed descriptor %s: 'link:' section contains %s" % (value, ss))
          isValid = False
          break
      
      atNames = []
      chemComp = self.chemComp
      for lc in linkCodes:
        if chemComp.findFirstLinkEnd(linkCode=lc) is None:
          print ("Malformed descriptor %s: 'link:'  %s is not a known linkCode" % (value, lc))
          isValid = False
          break

      atNames = []
      for ss in linkCodes :
        tt = ss.split('-', 1)
        atNames.append(tt[0])
        if len(tt) &gt; 1 and tt[1] not in linkAtomNames:
          print("Malformed descriptor %s: atom name %s is not a LinkAtom name for ChemCompVar" % (value, tt[1]))
          isValid = False
          break
    else:
      atNames = text.split(',')
    
      if tag == 'stereo':
        for aa in atNames:
          if self.findFirstChemAtom(name=aa, subType=subNo) is None:
            print("Malformed descriptor %s: atom name %s subtype %s is not in ChemCompVar" % (value, aa, subNo))
            isValid = False
            break
      else:
        for aa in atNames:
          if aa not in chemAtomNames:
            print("Malformed descriptor %s: atom name %s is not in ChemCompVar" % (value, aa))
            isValid = False
            break

    if not isValid:
      break
</item>
      </codeStubs>
    </MetaConstraint>
    <!-- End constraints for <MetaAttribute: ccp.molecule.ChemComp.ChemCompVar.descriptor>: -->
  </MetaAttribute>

  <MetaAttribute name="formalCharge"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:23_00040"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:52_00005"
   baseName="formalCharge" changeability="changeable" hicard="1"
   isAbstract="false" isAutomatic="false" isDerived="false"
   isImplementation="false" isImplicit="false" isOrdered="false" isUnique="true"
   locard="1" scope="instance_level" visibility="public_vis">
    <documentation>Formal charge of ChemCompVar</documentation>
    <valueType>www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00032</valueType>
  </MetaAttribute>

  <MetaAttribute name="formula"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:23_00039"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:52_00005"
   baseName="formula" changeability="frozen" hicard="1" isAbstract="false"
   isAutomatic="false" isDerived="true" isImplementation="false"
   isImplicit="false" isOrdered="false" isUnique="true" locard="0"
   scope="instance_level" visibility="public_vis">
    <documentation>Chemical formula for ChemCompVar</documentation>
    <valueType>www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00033</valueType>
  </MetaAttribute>

  <MetaOperation name="getChemAngles"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:23_00054"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:52_00005"
   isAbstract="false" isImplicit="false" isQuery="true" opType="get"
   scope="instance_level" visibility="public_vis">
    <documentation>getter for derived link chemAngles</documentation>
    <target>www.ccpn.ac.uk_Fogh_2006-08-16-18:23:23_00021</target>
    <codeStubs>
      <item tag="java">result = new java.util.HashSet&lt;ccp.api.molecule.ChemComp.ChemAngle&gt;();
java.util.Collection chemAtoms = getChemAtoms();
for (ccp.api.molecule.ChemComp.ChemAngle xx: getChemComp().getChemAngles()) {
  if (chemAtoms.containsAll(xx.getChemAtoms()))
    result.add(xx);
}</item>
      <item tag="python">atomsIncluded = self.chemAtoms.issuperset
result = frozenset(xx for xx in self.chemComp.chemAngles if atomsIncluded(xx.chemAtoms))</item>
    </codeStubs>
  </MetaOperation>

  <MetaOperation name="getChemAtomSets"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:24_00003"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:52_00005"
   isAbstract="false" isImplicit="false" isQuery="true" opType="get"
   scope="instance_level" visibility="public_vis">
    <documentation>getter for derived link chemAtomSets</documentation>
    <target>www.ccpn.ac.uk_Fogh_2006-08-16-18:23:23_00023</target>
    <codeStubs>
      <item tag="java">java.util.Collection&lt;ccp.api.molecule.ChemComp.AbstractChemAtom&gt; chemAtomVars = getChemAtoms();
java.util.Set&lt;ccp.api.molecule.ChemComp.ChemAtomSet&gt; chemAtomSets = getChemComp().getChemAtomSets();

// remove ChemAtomSets that do not have all atoms within ChemCompVar
for (ccp.api.molecule.ChemComp.AbstractChemAtom ca: getChemComp().getChemAtoms()) {
  if ((ca instanceof ccp.api.molecule.ChemComp.ChemAtom) &amp;&amp; (!chemAtomVars.contains(ca))) {
    ccp.api.molecule.ChemComp.ChemAtomSet cas = ((ccp.api.molecule.ChemComp.ChemAtom) ca).getChemAtomSet();
    while (chemAtomSets.contains(cas)) {
      chemAtomSets.remove(cas);
      cas = cas.getChemAtomSet();
    }
  }
}

// remove ChemAtomSets with duplicate names
java.util.Map&lt;java.lang.String, ccp.api.molecule.ChemComp.ChemAtomSet&gt; casByName = new java.util.HashMap&lt;java.lang.String, ccp.api.molecule.ChemComp.ChemAtomSet&gt;();

java.util.Set&lt;ccp.api.molecule.ChemComp.ChemAtomSet&gt; chemAtomSetsCopy = memops.universal.Util.copyToSet(chemAtomSets);
for (ccp.api.molecule.ChemComp.ChemAtomSet cas: chemAtomSetsCopy) {
  java.lang.String name = cas.getName();
  ccp.api.molecule.ChemComp.ChemAtomSet cas0 = casByName.get(name);

  if (cas0 == null) {
    casByName.put(name, cas);
  } else {
    java.util.Collection set0, set1 = cas.getChemAtomSets();
    if (!set1.isEmpty()) {
      set0 = cas0.getChemAtomSets();
    } else {
      set1 = cas.getChemAtoms();
      set0 = cas0.getChemAtoms();
    }

    ccp.api.molecule.ChemComp.ChemAtomSet casx = null;
    if (set0.containsAll(set1)) {
      casx = cas;
      if (set1.isEmpty())
        // TBD: report cas and cas0
        throw new memops.general.ApiException(this + " found ChemAtomSets that are incompatible");
    } else if (set1.containsAll(set0)) {
      casByName.put(name, cas);
      casx = cas0;
      if (set0.isEmpty())
        // TBD: report cas and cas0
        throw new memops.general.ApiException(this + " found ChemAtomSets that are incompatible");
    } else {
      // TBD: report cas and cas0
      throw new memops.general.ApiException(this + " found ChemAtomSets that are not subsets of each other");
    }

    while (chemAtomSets.contains(casx)) {
      chemAtomSets.remove(casx);
      casx = casx.getChemAtomSet();
    }
  }
}

result = chemAtomSets;</item>
      <item tag="python">chemAtomVars = self.chemAtoms
chemAtomSets = set(self.chemComp.chemAtomSets)

# remove ChemAtomSets that do not have all atoms within ChemCompVar
for ca in self.chemComp.chemAtoms:
  if isinstance(ca, ChemAtom) and ca not in chemAtomVars:
    cas = ca.chemAtomSet
    while cas in chemAtomSets:
      chemAtomSets.remove(cas)
      cas = cas.chemAtomSet

# remove ChemAtomSets with duplicate names
casByName = {}
for cas in chemAtomSets.copy():
  name = cas.name
  cas0 = casByName.get(name)

  if cas0 is None:
    casByName[name] = cas

  else:
    set1 = cas.chemAtomSets
    if set1:
      set0 = cas0.chemAtomSets
    else:
      set1 = cas.chemAtoms
      set0 = cas0.chemAtoms

    if set1 &lt; set0:
      casx = cas
      if not set1:
        raise ApiError("%s found ChemAtomSets %s and %s that are incompatible" % (self, cas, cas0))

    elif set0 &lt; set1:
      casByName[name] = cas
      casx = cas0
      if not set0:
        raise ApiError("%s found ChemAtomSets %s and %s that are incompatible" % (self, cas, cas0))

    else:
      raise ApiError("%s found ChemAtomSets %s and %s that are not subsets of each other" % (self, cas, cas0))
      
    while casx in chemAtomSets:
      chemAtomSets.remove(casx)
      casx = casx.chemAtomSet
#
result = frozenset(chemAtomSets)</item>
    </codeStubs>
  </MetaOperation>

  <MetaOperation name="getChemBonds"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:23_00052"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:52_00005"
   isAbstract="false" isImplicit="false" isQuery="true" opType="get"
   scope="instance_level" visibility="public_vis">
    <documentation>getter for derived link chemBonds</documentation>
    <target>www.ccpn.ac.uk_Fogh_2006-08-16-18:23:23_00022</target>
    <codeStubs>
      <item tag="java">result = new java.util.HashSet&lt;ccp.api.molecule.ChemComp.ChemBond&gt;();
java.util.Collection chemAtomVars = getChemAtoms();
for (ccp.api.molecule.ChemComp.ChemBond xx: getChemComp().getChemBonds()) {
  if (chemAtomVars.containsAll(xx.getChemAtoms()))
    result.add(xx);
}</item>
      <item tag="python">chemAtomVars = self.chemAtoms
result = frozenset(xx for xx in self.chemComp.chemBonds if xx.chemAtoms.issubset(chemAtomVars))</item>
    </codeStubs>
  </MetaOperation>

  <MetaOperation name="getChemCompSysNames"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:24_00005"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:52_00005"
   isAbstract="false" isImplicit="false" isQuery="true" opType="get"
   scope="instance_level" visibility="public_vis">
    <documentation>getter for derived link chemCompSysNames</documentation>
    <target>www.ccpn.ac.uk_Fogh_2006-08-16-18:23:23_00014</target>
    <codeStubs>
      <item tag="java">result = getSpecificSysNames();
for (ccp.api.molecule.ChemComp.NamingSystem x: getChemComp().getNamingSystems()) {
  for (ccp.api.molecule.ChemComp.ChemCompSysName y: x.getChemCompSysNames()) {
    if (y.getSpecificChemCompVars().isEmpty())
      result.add(y);
  }
}</item>
      <item tag="python">result = frozenset(y for x in self.chemComp.namingSystems for y in x.chemCompSysNames if not y.specificChemCompVars).union(self.specificSysNames)</item>
    </codeStubs>
  </MetaOperation>

  <MetaOperation name="getChemTorsions"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:24_00001"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:52_00005"
   isAbstract="false" isImplicit="false" isQuery="true" opType="get"
   scope="instance_level" visibility="public_vis">
    <documentation>getter for derived link chemTorsions</documentation>
    <target>www.ccpn.ac.uk_Fogh_2006-08-16-18:23:23_00020</target>
    <codeStubs>
      <item tag="java">result = new java.util.HashSet&lt;ccp.api.molecule.ChemComp.ChemTorsion&gt;();
java.util.Collection chemAtoms = getChemAtoms();
for (ccp.api.molecule.ChemComp.ChemTorsion xx: getChemComp().getChemTorsions()) {
  if (chemAtoms.containsAll(xx.getChemAtoms()))
    result.add(xx);
}</item>
      <item tag="python">atomsIncluded = self.chemAtoms.issuperset
result = frozenset(xx for xx in self.chemComp.chemTorsions if atomsIncluded(xx.chemAtoms))</item>
    </codeStubs>
  </MetaOperation>

  <MetaOperation name="getFormula"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:23_00048"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:52_00005"
   isAbstract="false" isImplicit="false" isQuery="true" opType="get"
   scope="instance_level" visibility="public_vis">
    <documentation>getter for derived attribute formula</documentation>
    <target>www.ccpn.ac.uk_Fogh_2006-08-16-18:23:23_00039</target>
    <codeStubs>
      <item tag="java">// get formula dictionary 
java.util.Map&lt;java.lang.String, java.lang.Integer&gt; dd = new java.util.HashMap&lt;java.lang.String, java.lang.Integer&gt;();
for (ccp.api.molecule.ChemComp.AbstractChemAtom ca: getChemAtoms()) {
  if (ca instanceof ccp.api.molecule.ChemComp.ChemAtom) {
    java.lang.String ss = ((ccp.api.molecule.ChemComp.ChemAtom) ca).getElementSymbol();
    java.lang.Integer ii = dd.get(ss);
    if (ii == null)
      dd.put(ss, 1);
    else
      dd.put(ss, ii+1);
  }
}

// generate formula
java.lang.StringBuffer ll = new java.lang.StringBuffer(2*dd.size());
java.lang.String[] es = { "C", "H" };
for (int kk = 0; kk &lt; es.length; kk++) {
  java.lang.String ss = es[kk];
  java.lang.Integer ii = dd.remove(ss);
  if (ii != null) {
    ll.append(ss);
    ll.append(ii);
  }
}

java.util.List&lt;java.lang.String&gt; keys = java.util.Collections.list(java.util.Collections.enumeration(dd.keySet()));
java.util.Collections.sort(keys);
for (java.lang.String ss: keys) {
  java.lang.Integer ii = dd.get(ss);
  ll.append(ss);
  ll.append(ii);
}

result = ll.toString();</item>
      <item tag="python"># get formula dictionary
dd = {}
for ca in self.chemAtoms:
  if isinstance(ca, ChemAtom):
    ss = ca.elementSymbol
    ii = dd.get(ss)
    if ii is None:
      dd[ss] = 1
    else:
      dd[ss] = ii + 1

# generate formula
ll = [None] * (len(dd)*2)
next = 0
for ss in ('C', 'H'):
  ii = dd.get(ss)
  if ii is not None:
    ll[next] = ss
    ll[next+1] = str(ii)
    del dd[ss]
    next = next + 2

items = dd.items()
items.sort()
for ss, ii in items:
  ll[next] = ss
  ll[next+1] = str(ii)
  next = next + 2
#
result = ''.join(ll)</item>
    </codeStubs>
  </MetaOperation>

  <MetaOperation name="getLinkEnds"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:23_00046"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:52_00005"
   isAbstract="false" isImplicit="false" isQuery="true" opType="get"
   scope="instance_level" visibility="public_vis">
    <documentation>getter for derived link linkEnds</documentation>
    <target>www.ccpn.ac.uk_Fogh_2006-08-16-18:23:25_00016</target>
    <codeStubs>
      <item tag="java">result = new java.util.HashSet&lt;ccp.api.molecule.ChemComp.LinkEnd&gt;();
for (ccp.api.molecule.ChemComp.AbstractChemAtom ca: getChemAtoms()) {
  if (ca instanceof ccp.api.molecule.ChemComp.LinkAtom) {
    ccp.api.molecule.ChemComp.LinkEnd le = (ccp.api.molecule.ChemComp.LinkEnd) ((ccp.api.molecule.ChemComp.LinkAtom)ca).getBoundLinkEnd();
    if (le != null)
      result.add(le);
  }
}</item>
      <item tag="python">result = set(ca.boundLinkEnd for ca in self.chemAtoms if isinstance(ca,LinkAtom))
if None in result:
  result.remove(None)
result = frozenset(result)</item>
    </codeStubs>
  </MetaOperation>

  <MetaOperation name="getMolecularMass"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:23_00050"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:52_00005"
   isAbstract="false" isImplicit="false" isQuery="true" opType="get"
   scope="instance_level" visibility="public_vis">
    <documentation>getter for derived attribute molecularMass</documentation>
    <target>www.ccpn.ac.uk_Fogh_2006-08-16-18:23:23_00041</target>
    <codeStubs>
      <item tag="java">// get formula dictionary 
java.util.Map&lt;java.lang.String, java.lang.Integer&gt; dd = new java.util.HashMap&lt;java.lang.String, java.lang.Integer&gt;();
for (ccp.api.molecule.ChemComp.AbstractChemAtom ca: getChemAtoms()) {
  if (ca instanceof ccp.api.molecule.ChemComp.ChemAtom) {
    java.lang.String ss = ((ccp.api.molecule.ChemComp.ChemAtom) ca).getElementSymbol();
    java.lang.Integer ii = dd.get(ss);
    if (ii == null)
      dd.put(ss, 1);
    else
      dd.put(ss, ii+1);
  }
}

// calculate mass
ccp.api.molecule.ChemElement.ChemElementStore xx = getRoot().getCurrentChemElementStore();
result = 0.0f;
for (java.lang.String ss: dd.keySet()) {
  java.lang.Integer ii = dd.get(ss);
  result += ii * xx.findFirstChemElement("symbol", ss).getMass();
}</item>
      <item tag="python"># get formula dictionary
dd = {}
for ca in self.chemAtoms:
  if isinstance(ca, ChemAtom):
    ss = ca.elementSymbol
    ii = dd.get(ss)
    if ii is None:
      dd[ss] = 1
    else:
      dd[ss] = ii + 1

# calculate mass
xx = self.root.currentChemElementStore
result = sum(ii * xx.findFirstChemElement(symbol=ss).mass for (ss, ii) in dd.iteritems())</item>
    </codeStubs>
  </MetaOperation>

  <MetaOperation name="getName"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:24_00009"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:52_00005"
   isAbstract="false" isImplicit="false" isQuery="true" opType="get"
   scope="instance_level" visibility="public_vis">
    <documentation>getter for derived attribute 'name'.</documentation>
    <target>www.ccpn.ac.uk_Fogh_2006-08-16-18:23:23_00033</target>
    <codeStubs>
      <item tag="java">result = getVarName();
if (result == null)
  result = getChemComp().getName();</item>
      <item tag="python">result = self.varName
if result is None:
  result = self.chemComp.name</item>
    </codeStubs>
  </MetaOperation>

  <MetaAttribute name="glycoCtCode"
   guid="www.ccpn.ac.uk_Fogh_2007-04-02-13:31:25_00003"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:52_00005"
   baseName="glycoCtCode" changeability="frozen" hicard="1" isAbstract="false"
   isAutomatic="false" isDerived="false" isImplementation="false"
   isImplicit="false" isOrdered="false" isUnique="true" locard="0"
   scope="instance_level" visibility="public_vis">
    <documentation>glycoCT chem_comp_code specific to ChemCompVar. If not set use chemComp.baseGlycoCtCode</documentation>
    <valueType>www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00035</valueType>
  </MetaAttribute>

  <MetaAttribute name="isAromatic"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:23_00045"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:52_00005"
   baseName="isAromatic" changeability="changeable" hicard="1"
   isAbstract="false" isAutomatic="false" isDerived="false"
   isImplementation="false" isImplicit="false" isOrdered="false" isUnique="true"
   locard="1" scope="instance_level" visibility="public_vis">
    <documentation>is ChemCompVar  aromatic?</documentation>
    <valueType>www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00028</valueType>
  </MetaAttribute>

  <MetaAttribute name="isDefaultVar"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:23_00031"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:52_00005"
   baseName="isDefaultVar" changeability="changeable" hicard="1"
   isAbstract="false" isAutomatic="false" isDerived="false"
   isImplementation="false" isImplicit="false" isOrdered="false" isUnique="true"
   locard="1" scope="instance_level" visibility="public_vis">
    <documentation>Is this ChemCompVar the default for its linking? Or, in other words, is this the ChemCompVar to use by default when creating a MolResidue with this particular molType, ccpCode, and linking? 
Note that
myChemComp.findAllChemCompVars(linking=x,isDefaultVar=True)

will return either one object or none for any value of x.</documentation>
    <valueType>www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00028</valueType>
    <defaultValue>
      <item>false</item>
    </defaultValue>

    <!-- Start constraints for <MetaAttribute: ccp.molecule.ChemComp.ChemCompVar.isDefaultVar>: -->
    <MetaConstraint name="only_true_for_one_ChemCompVar_with_each_linking"
     guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:23_00032"
     container="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:23_00031"
     isImplicit="false">
      <codeStubs>
        <item tag="java">isValid = true;
if ((value != null) &amp;&amp; value)
{
  java.lang.String linking = getLinking();
  for (ccp.api.molecule.ChemComp.ChemCompVar x: getChemComp().getChemCompVars()) {
    if (x.getIsDefaultVar() &amp;&amp; x.getLinking().equals(linking) &amp;&amp; (x != this))
    {
      isValid = false;
      break;
    }
  }
}
</item>
        <item tag="python">isValid = True
if value:
  if [x for x in self.chemComp.findAllChemCompVars(linking=self.linking)
         if x.isDefaultVar and x is not self]:
    isValid = False
</item>
      </codeStubs>
    </MetaConstraint>
    <!-- End constraints for <MetaAttribute: ccp.molecule.ChemComp.ChemCompVar.isDefaultVar>: -->
  </MetaAttribute>

  <MetaAttribute name="isParamagnetic"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:23_00044"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:52_00005"
   baseName="isParamagnetic" changeability="changeable" hicard="1"
   isAbstract="false" isAutomatic="false" isDerived="false"
   isImplementation="false" isImplicit="false" isOrdered="false" isUnique="true"
   locard="1" scope="instance_level" visibility="public_vis">
    <documentation>is ChemCompVar paramagnetic?</documentation>
    <valueType>www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00028</valueType>
  </MetaAttribute>

  <MetaRole name="linkEnds"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:25_00016"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:52_00005"
   baseName="linkEnd" changeability="frozen" hicard="-1" isAbstract="false"
   isAutomatic="false" isDerived="true" isImplementation="false"
   isImplicit="false" isOrdered="false" isUnique="true" locard="0"
   noDeleteIfSet="false" partitionsChildren="false" scope="instance_level"
   visibility="public_vis">
    <documentation>linkEnds available to ChemCompVar. A LinkEnd belongs to a ChemCompVar if and only if the LinkEnd.boundLinkAtom belongs to the ChemCompVAr.</documentation>
    <otherRole>www.ccpn.ac.uk_Fogh_2006-08-16-18:23:25_00017</otherRole>
    <valueType>www.ccpn.ac.uk_Fogh_2006-08-16-14:22:52_00030</valueType>
  </MetaRole>

  <MetaAttribute name="linking"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:23_00028"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:52_00005"
   baseName="linking" changeability="frozen" hicard="1" isAbstract="false"
   isAutomatic="false" isDerived="false" isImplementation="false"
   isImplicit="false" isOrdered="false" isUnique="true" locard="1"
   scope="instance_level" visibility="public_vis">
    <documentation>String distinguishing the pattern of linkEnds (substitution pattern) of the ChemCompVar.  For a linear polymer type ChemComp linking must be 'start', 'middle', 'end', or 'none', and other linking patterns are taken care of by the descriptor attribute. For Other ChemComps linking distinguishes all possible substitution patterns. Here the format is 'link:' followed by a comma-separated list of the linkCodes for the active links. E.g. 'link:SG,C1_2'</documentation>
    <valueType>www.ccpn.ac.uk_Fogh_2006-08-16-14:22:52_00025</valueType>

    <!-- Start constraints for <MetaAttribute: ccp.molecule.ChemComp.ChemCompVar.linking>: -->
    <MetaConstraint name="linking_format_rule"
     guid="www.ccpn.ac.uk_Fogh_2007-07-10-16:25:15_00001"
     container="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:23_00028"
     isImplicit="false">
      <codeStubs>
        <item tag="java">isValid = true;
if (!("start".equals(value) || "middle".equals(value) || "end".equals(value) ||
"none".equals(value))) {
  if (value.startsWith("link:")) {
    ccp.api.molecule.ChemComp.ChemComp chemComp = getChemComp();
    for (java.lang.String lc: value.substring(5).split(",")) {
      if (chemComp.findFirstLinkEnd("linkCode", lc) == null) {
        System.out.println("Malformed linking '" + value + "': 'link:' '" + lc
+ "' is not a known linkCode");
        isValid = false;
        break;
      }
    }
  } else {
    System.out.println("Malformed linking '" + value + "': does not start with 'link:'");
    isValid = false;
  }
}
</item>
        <item tag="python">isValid = True
if value not in ('start', 'middle', 'end', 'none'):
  if value.startswith('link:'):
    chemComp = self.chemComp
    for lc in value[5:].split(','):
      if chemComp.findFirstLinkEnd(linkCode=lc) is None:
        print ("Malformed linking %s: 'link:'  %s is not a known linkCode" % (value, lc))
        isValid = False
        break
    
  else:
    isValid = False
    print "Malformed linking %s - does not start with 'link:'" % value
</item>
      </codeStubs>
    </MetaConstraint>
    <!-- End constraints for <MetaAttribute: ccp.molecule.ChemComp.ChemCompVar.linking>: -->
  </MetaAttribute>

  <MetaAttribute name="molecularMass"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:23_00041"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:52_00005"
   baseName="molecularMass" changeability="frozen" hicard="1" isAbstract="false"
   isAutomatic="false" isDerived="true" isImplementation="false"
   isImplicit="false" isOrdered="false" isUnique="true" locard="1"
   scope="instance_level" visibility="public_vis">
    <documentation>molecular mass for ChemCompVar.</documentation>
    <valueType>www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00031</valueType>
  </MetaAttribute>

  <MetaAttribute name="name"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:23_00033"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:52_00005"
   baseName="name" changeability="changeable" hicard="1" isAbstract="false"
   isAutomatic="false" isDerived="true" isImplementation="false"
   isImplicit="false" isOrdered="false" isUnique="true" locard="0"
   scope="instance_level" visibility="public_vis">
    <documentation>name of ChemCompVar. Equal to varName if set, otherwise to ChemComp.name</documentation>
    <valueType>www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00036</valueType>
  </MetaAttribute>

  <MetaAttribute name="nonStereoSmiles"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:23_00042"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:52_00005"
   baseName="nonStereoSmiles" changeability="changeable" hicard="1"
   isAbstract="false" isAutomatic="false" isDerived="false"
   isImplementation="false" isImplicit="false" isOrdered="false" isUnique="true"
   locard="0" scope="instance_level" visibility="public_vis">
    <documentation>Smiles description of topology (non-stereo)</documentation>
    <valueType>www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00035</valueType>
  </MetaAttribute>

  <MetaOperation name="setName"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:24_00011"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:52_00005"
   isAbstract="false" isImplicit="false" isQuery="false" opType="set"
   scope="instance_level" visibility="public_vis">
    <documentation>setter for derived, settable attribute 'name'.</documentation>
    <target>www.ccpn.ac.uk_Fogh_2006-08-16-18:23:23_00033</target>
    <codeStubs>
      <item tag="java">setVarName(value);</item>
      <item tag="python">self.varName = value</item>
    </codeStubs>
  </MetaOperation>

  <MetaRole name="specificSysNames"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:23_00011"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:52_00005"
   baseName="specificSysName" changeability="changeable" hicard="-1"
   isAbstract="false" isAutomatic="false" isDerived="false"
   isImplementation="false" isImplicit="false" isOrdered="false" isUnique="true"
   locard="0" noDeleteIfSet="false" partitionsChildren="false"
   scope="instance_level" visibility="public_vis">
    <documentation>Systematic names that are valid for this ChemCompVar but not for all others. In addition to the specific ChemCompSysNames in this link, any ChemCompSysName that is not linked to specific ChemCompVars is valid for all ChemCompVars. Each ChemCompVar can have only one ChemCompSysName within a given naming system.</documentation>
    <otherRole>www.ccpn.ac.uk_Fogh_2006-08-16-18:23:23_00012</otherRole>
    <valueType>www.ccpn.ac.uk_Fogh_2006-08-16-14:22:52_00004</valueType>
  </MetaRole>

  <MetaAttribute name="stereoSmiles"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:23_00043"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:52_00005"
   baseName="stereoSmiles" changeability="changeable" hicard="1"
   isAbstract="false" isAutomatic="false" isDerived="false"
   isImplementation="false" isImplicit="false" isOrdered="false" isUnique="true"
   locard="0" scope="instance_level" visibility="public_vis">
    <documentation>Smiles description of topology (stereo)</documentation>
    <valueType>www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00035</valueType>
  </MetaAttribute>

  <MetaAttribute name="varName"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:23_00034"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:52_00005"
   baseName="varName" changeability="changeable" hicard="1" isAbstract="false"
   isAutomatic="false" isDerived="false" isImplementation="false"
   isImplicit="false" isOrdered="false" isUnique="true" locard="0"
   scope="instance_level" visibility="public_vis">
    <documentation>Name for ChemCompVar. Overrides ChemComp.name and should only be set when different from this. See ChemCompVar.name documentation</documentation>
    <valueType>www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00036</valueType>
  </MetaAttribute>
</MetaClass>

