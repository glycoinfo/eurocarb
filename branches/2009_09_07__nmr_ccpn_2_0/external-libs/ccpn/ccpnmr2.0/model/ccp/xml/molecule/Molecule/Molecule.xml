<?xml version='1.0'?>
<!--
#######################################################################

CCPN Data Model version 2.0.b2

Autogenerated by XmlModelIo revision 1.14.2.4 on ?
  from data model element ccp.molecule.Molecule.Molecule revision ?

#######################################################################
======================COPYRIGHT/LICENSE START==========================

Molecule.xml: xmlmodel model for CCPN data model, MetaClass ccp.molecule.Molecule.Molecule

Copyright (C) 2007  (CCPN Project)

=======================================================================

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.
 
A copy of this license can be found in ../../../../../license/LGPL.license
 
This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
Lesser General Public License for more details.
 
You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA


======================COPYRIGHT/LICENSE END============================

for further information, please contact :

- CCPN website (http://www.ccpn.ac.uk/)

- email: ccpn@bioc.cam.ac.uk

=======================================================================

If you are using this software for academic purposes, we suggest
quoting the following references:

===========================REFERENCE START=============================
Rasmus H. Fogh, Wayne Boucher, Wim F. Vranken, Anne
Pajon, Tim J. Stevens, T.N. Bhat, John Westbrook, John M.C. Ionides and
Ernest D. Laue (2005). A framework for scientific data modeling and automated
software development. Bioinformatics 21, 1678-1684.


This file was generated with the Memops software generation framework,
and contains original contributions embedded in the framework

===========================REFERENCE END===============================
-->

<MetaClass name="Molecule"
 guid="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00039"
 container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00038"
 isAbstract="false" isImplicit="false" isLeaf="false" isRoot="false"
 isSingleton="false" partitionsChildren="true" visibility="public_vis">
  <documentation>Abstract molecule, with defined topology but no location, coordinates, etc. </documentation>
  <keyNames>
    <item>name</item>
  </keyNames>
  <supertypes>
    <item>www.ccpn.ac.uk_Fogh_2006-09-14-16:28:57_00002</item>
  </supertypes>
  <taggedValues>
    <item tag="repositoryId">$Id: Molecule.xml,v 1.50.2.10 2009/03/11 17:20:08 rhfogh Exp $</item>
    <item tag="repositoryTag">$Name: release_2_0_8_3 $</item>
  </taggedValues>

  <!-- Start constraints for <MetaClass: ccp.molecule.Molecule.Molecule>: -->
  <MetaConstraint name="molResidue_serials_must_be_consecutive"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00042"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00039"
   isImplicit="false">
    <codeStubs>
      <item tag="java">java.util.List&lt;? extends ccp.api.molecule.Molecule.MolResidue&gt; ll = sortedMolResidues();
if (ll == null)
  isValid = true;
else
  isValid = (ll.size() == (ll.get(ll.size()-1).getSerial() - ll.get(0).getSerial() + 1));
</item>
      <item tag="python">ll = self.sortedMolResidues()
if ll:
  isValid = (len(ll) == (ll[-1].serial - ll[0].serial + 1))
else:
  isValid = True
</item>
    </codeStubs>
  </MetaConstraint>
  <MetaConstraint name="seqCode_and_seqInsertCode_form_secondary_key_for_molResidues"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00041"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00039"
   isImplicit="false">
    <codeStubs>
      <item tag="java">java.util.Set&lt;java.lang.String&gt; dd = new java.util.HashSet&lt;java.lang.String&gt;();
int nn = 0;
for (ccp.api.molecule.Molecule.MolResidue res: getMolResidues()) {
  java.lang.String ss = res.getSeqCode() + ":" + res.getSeqInsertCode();
  dd.add(ss);
  nn++;
}
isValid = (dd.size() == nn);
</item>
      <item tag="python">ll = self.molResidues
aset = frozenset((x.seqCode, x.seqInsertCode) for x in ll)
isValid = (len(aset) == len(ll))
</item>
    </codeStubs>
  </MetaConstraint>
  <MetaConstraint name="smiles_goes_with_smilesType"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00040"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00039"
   isImplicit="false">
    <codeStubs>
      <item tag="java">(getSmiles() == null) == (getSmilesType() == null)</item>
      <item tag="python">(self.smiles is None) == (self.smilesType is None)</item>
    </codeStubs>
  </MetaConstraint>
  <!-- End constraints for <MetaClass: ccp.molecule.Molecule.Molecule>: -->

  <MetaRole name="currentMolecule"
   guid="ccpn_automatic_memops.Implementation.MemopsRoot.currentMolecule"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00047"
   baseName="currentMolecule" changeability="changeable" hicard="1"
   isAbstract="false" isAutomatic="false" isDerived="false"
   isImplementation="false" isImplicit="false" isOrdered="false" isUnique="true"
   locard="0" noDeleteIfSet="false" partitionsChildren="false"
   scope="instance_level" visibility="public_vis">
    <documentation>current molecule - may be reset by implementation.</documentation>
    <valueType>www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00039</valueType>
  </MetaRole>

  <MetaOperation name="getCurrentMolecule"
   guid="ccpn_automatic_memops.Implementation.MemopsRoot.getCurrentMolecule"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00047"
   isAbstract="false" isImplicit="false" isQuery="true" opType="get"
   scope="instance_level" visibility="public_vis">
    <documentation>Get for memops.Implementation.MemopsRoot.currentMolecule</documentation>
    <target>ccpn_automatic_memops.Implementation.MemopsRoot.currentMolecule</target>
    <codeStubs>
      <item tag="java">
result = _currentMolecule;
if (result == null) {
  findFirstMolecule();
  result = _currentMolecule;
}
</item>
      <item tag="python">
result = dataDict.get('currentMolecule')
if result is None:
  self.findFirstMolecule()
  result = dataDict.get('currentMolecule')
</item>
    </codeStubs>
  </MetaOperation>


  <MetaRole name="alignments"
   guid="www.ccpn.ac.uk_Fogh_2007-11-26-10:15:40_00002"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00039"
   baseName="alignment" changeability="changeable" hicard="-1" hierarchy="child"
   isAbstract="false" isAutomatic="false" isDerived="false"
   isImplementation="false" isImplicit="false" isOrdered="false" isUnique="true"
   locard="0" noDeleteIfSet="false" partitionsChildren="false"
   scope="instance_level" visibility="public_vis">
    <otherRole>www.ccpn.ac.uk_Fogh_2007-11-26-10:15:40_00001</otherRole>
    <valueType>www.ccpn.ac.uk_Fogh_2007-11-26-10:11:54_00001</valueType>
  </MetaRole>

  <MetaAttribute name="calcIsoelectricPoint"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:34_00018"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00039"
   baseName="calcIsoelectricPoint" changeability="changeable" hicard="1"
   isAbstract="false" isAutomatic="false" isDerived="false"
   isImplementation="false" isImplicit="false" isOrdered="false" isUnique="true"
   locard="0" scope="instance_level" visibility="public_vis">
    <documentation>Calculated isoelectric point of molecule. The pI indicates the value of pH at which the net charge of the molecule would be neutralized, if the molecule would have a conformation with each amino acid fully exposed to the solvent. NB This is derived information, this should be moved when this gets developed.</documentation>
    <valueType>www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00031</valueType>
  </MetaAttribute>

  <MetaRole name="molecules"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:33_00050"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:55_00011"
   baseName="molecule" changeability="changeable" hicard="-1" isAbstract="false"
   isAutomatic="false" isDerived="false" isImplementation="false"
   isImplicit="false" isOrdered="false" isUnique="true" locard="0"
   noDeleteIfSet="false" partitionsChildren="false" scope="instance_level"
   visibility="public_vis">
    <documentation>Molecules described by Citation</documentation>
    <otherRole>www.ccpn.ac.uk_Fogh_2006-08-16-18:23:33_00051</otherRole>
    <valueType>www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00039</valueType>
  </MetaRole>

  <MetaRole name="citations"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:33_00051"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00039"
   baseName="citation" changeability="frozen" hicard="-1" isAbstract="false"
   isAutomatic="false" isDerived="false" isImplementation="false"
   isImplicit="false" isOrdered="false" isUnique="true" locard="0"
   noDeleteIfSet="false" partitionsChildren="false" scope="instance_level"
   visibility="public_vis">
    <documentation>Citations describing molecule.</documentation>
    <otherRole>www.ccpn.ac.uk_Fogh_2006-08-16-18:23:33_00050</otherRole>
    <valueType>www.ccpn.ac.uk_Fogh_2006-08-16-14:22:55_00011</valueType>
  </MetaRole>

  <MetaAttribute name="commonNames"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:34_00014"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00039"
   baseName="commonName" changeability="changeable" hicard="-1"
   isAbstract="false" isAutomatic="false" isDerived="false"
   isImplementation="false" isImplicit="false" isOrdered="true" isUnique="false"
   locard="0" scope="instance_level" visibility="public_vis">
    <documentation>List of molecule common names.</documentation>
    <valueType>www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00033</valueType>
  </MetaAttribute>

  <MetaAttribute name="details"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:34_00026"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00039"
   baseName="details" changeability="changeable" hicard="1" isAbstract="false"
   isAutomatic="false" isDerived="false" isImplementation="false"
   isImplicit="false" isOrdered="false" isUnique="true" locard="0"
   scope="instance_level" visibility="public_vis">
    <documentation>Free text, for notes, explanatory comments, etc.</documentation>
    <valueType>www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00035</valueType>
  </MetaAttribute>

  <MetaAttribute name="empiricalFormula"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:34_00019"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00039"
   baseName="empiricalFormula" changeability="frozen" hicard="1"
   isAbstract="false" isAutomatic="false" isDerived="true"
   isImplementation="false" isImplicit="false" isOrdered="false" isUnique="true"
   locard="1" scope="instance_level" visibility="public_vis">
    <documentation>Empirical formula for molecule.</documentation>
    <valueType>www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00033</valueType>
  </MetaAttribute>

  <MetaAttribute name="formalCharge"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:34_00021"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00039"
   baseName="formalCharge" changeability="frozen" hicard="1" isAbstract="false"
   isAutomatic="false" isDerived="true" isImplementation="false"
   isImplicit="false" isOrdered="false" isUnique="true" locard="1"
   scope="instance_level" visibility="public_vis">
    <documentation>Formal charge of molecule.</documentation>
    <valueType>www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00032</valueType>
  </MetaAttribute>

  <MetaAttribute name="functions"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:34_00016"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00039"
   baseName="function" changeability="changeable" hicard="-1" isAbstract="false"
   isAutomatic="false" isDerived="false" isImplementation="false"
   isImplicit="false" isOrdered="true" isUnique="false" locard="0"
   scope="instance_level" visibility="public_vis">
    <documentation>Keywords describing functions for molecule. e.g. 'enzyme', 'structure', ...</documentation>
    <valueType>www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00033</valueType>
  </MetaAttribute>

  <MetaOperation name="getEmpiricalFormula"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:34_00038"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00039"
   isAbstract="false" isImplicit="false" isQuery="true" opType="get"
   scope="instance_level" visibility="public_vis">
    <documentation>getter for derived attribute empiricalFormula</documentation>
    <target>www.ccpn.ac.uk_Fogh_2006-08-16-18:23:34_00019</target>
    <codeStubs>
      <item tag="java">// get formula dictionary 
java.util.Map&lt;java.lang.String, java.lang.Integer&gt; dd = new java.util.HashMap&lt;java.lang.String, java.lang.Integer&gt;();
for (ccp.api.molecule.Molecule.MolResidue mr: getMolResidues()) {
  for (ccp.api.molecule.ChemComp.AbstractChemAtom ca: mr.getChemComp().findFirstChemCompVar("linking", mr.getLinking(), "descriptor", mr.getDescriptor()).getChemAtoms()) {
    if (ca instanceof ccp.api.molecule.ChemComp.ChemAtom) {
      java.lang.String ss = ((ccp.api.molecule.ChemComp.ChemAtom) ca).getElementSymbol();
      java.lang.Integer ii = dd.get(ss);
      if (ii == null)
        dd.put(ss, 1);
      else
        dd.put(ss, ii+1);
    }
  }
}

// generate formula
java.lang.StringBuffer ll = new java.lang.StringBuffer(2*dd.size());
java.lang.String[] es = { "C", "H" };
for (int kk = 0; kk &lt; es.length; kk++) {
  java.lang.String ss = es[kk];
  java.lang.Integer ii = dd.remove(ss);
  if (ii != null) {
    ll.append(ss);
    ll.append(ii);
  }
}

java.util.List&lt;java.lang.String&gt; keys = java.util.Collections.list(java.util.Collections.enumeration(dd.keySet()));
java.util.Collections.sort(keys);
for (java.lang.String ss: keys) {
  java.lang.Integer ii = dd.get(ss);
  ll.append(ss);
  ll.append(ii);
}

result = ll.toString();</item>
      <item tag="python"># get formula dictionary
dd = {}
clazz = ccp.api.molecule.ChemComp.ChemAtom

for mr in self.molResidues:
  for ss in (ca.elementSymbol for ca in mr.getByNavigation('chemComp', ('chemCompVars', (mr.linking, mr.descriptor)), 'chemAtoms') if isinstance(ca, clazz)):
    ii = dd.get(ss)
    if ii is None:
      dd[ss] = 1
    else:
      dd[ss] = ii + 1

# generate formula
ll = [None] * (len(dd)*2)
next = 0
for ss in ('C','H'):
  ii = dd.get(ss)
  if ii is not None:
    ll[next] = ss
    ll[next+1] = str(ii)
    del dd[ss]
    next = next + 2

items = dd.items()
items.sort()
for (ss, ii) in items:
  ll[next] = ss
  ll[next+1] = str(ii)
  next = next + 2
#
result = ''.join(ll) or None</item>
    </codeStubs>
  </MetaOperation>

  <MetaOperation name="getFormalCharge"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:34_00042"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00039"
   isAbstract="false" isImplicit="false" isQuery="true" opType="get"
   scope="instance_level" visibility="public_vis">
    <documentation>getter for derived attribute formalCharge</documentation>
    <target>www.ccpn.ac.uk_Fogh_2006-08-16-18:23:34_00021</target>
    <codeStubs>
      <item tag="java">result = 0;
for (ccp.api.molecule.Molecule.MolResidue x: getMolResidues())
  result += x.getChemCompVar().getFormalCharge();</item>
      <item tag="python">result = sum(x.chemCompVar.formalCharge for x in self.molResidues)</item>
    </codeStubs>
  </MetaOperation>

  <MetaOperation name="getHasNonStdChemComp"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:34_00052"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00039"
   isAbstract="false" isImplicit="false" isQuery="true" opType="get"
   scope="instance_level" visibility="public_vis">
    <documentation>getter for derived attribute hasNonStdChemComp</documentation>
    <target>www.ccpn.ac.uk_Fogh_2006-08-16-18:23:34_00030</target>
    <codeStubs>
      <item tag="java">result = false;
for (ccp.api.molecule.Molecule.MolResidue x: getMolResidues()) {
  ccp.api.molecule.ChemComp.ChemComp cc = x.getChemComp();
  if (!cc.getCcpCode().equals(cc.getStdChemCompCode())) {
    result = true;
    break;
  }
}</item>
      <item tag="python">for cc in frozenset(x.chemComp for x in self.molResidues):
  if cc.ccpCode != cc.stdChemCompCode:
    result = True
    break
else:
  result = False</item>
    </codeStubs>
  </MetaOperation>

  <MetaOperation name="getHasNonStdChirality"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:34_00054"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00039"
   isAbstract="false" isImplicit="false" isQuery="true" opType="get"
   scope="instance_level" visibility="public_vis">
    <documentation>getter for derived link hasNonStdChirality</documentation>
    <target>www.ccpn.ac.uk_Fogh_2006-08-16-18:23:34_00031</target>
    <codeStubs>
      <item tag="java">result = false;
for (ccp.api.molecule.Molecule.MolResidue x: getMolResidues()) {
  ccp.api.molecule.ChemComp.ChemComp cc = x.getChemComp();
  if (!java.lang.Boolean.TRUE.equals(cc.getHasStdChirality())) {
    result = true;
    break;
  }
}</item>
      <item tag="python">for cc in frozenset(x.chemComp for x in self.molResidues):
  if not cc.hasStdChirality:
    result = True
    break
else:
  result = False</item>
    </codeStubs>
  </MetaOperation>

  <MetaOperation name="getIsAromatic"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:34_00044"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00039"
   isAbstract="false" isImplicit="false" isQuery="true" opType="get"
   scope="instance_level" visibility="public_vis">
    <documentation>getter for derived attribute isAromatic</documentation>
    <target>www.ccpn.ac.uk_Fogh_2006-08-16-18:23:34_00022</target>
    <codeStubs>
      <item tag="java">result = false;
for (ccp.api.molecule.Molecule.MolResidue rr: getMolResidues()) {
  if (rr.getChemCompVar().getIsAromatic()) {
    result = true;
    break;
  }
}</item>
      <item tag="python">for rr in self.molResidues:
  if rr.chemCompVar.isAromatic == True:
    result = True
    break
else:
  result = False</item>
    </codeStubs>
  </MetaOperation>

  <MetaOperation name="getIsParamagnetic"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:34_00046"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00039"
   isAbstract="false" isImplicit="false" isQuery="true" opType="get"
   scope="instance_level" visibility="public_vis">
    <documentation>getter for derived attribute isParamagnetic</documentation>
    <target>www.ccpn.ac.uk_Fogh_2006-08-16-18:23:34_00023</target>
    <codeStubs>
      <item tag="java">result = false;
for (ccp.api.molecule.Molecule.MolResidue rr: getMolResidues()) {
  if (rr.getChemCompVar().getIsParamagnetic()) {
    result = true;
    break;
  }
}</item>
      <item tag="python">for rr in self.molResidues:
  if rr.chemCompVar.isParamagnetic == True:
    result = True
    break
else:
  result = False</item>
    </codeStubs>
  </MetaOperation>

  <MetaOperation name="getIsStdCyclic"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:34_00048"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00039"
   isAbstract="false" isImplicit="false" isQuery="true" opType="get"
   scope="instance_level" visibility="public_vis">
    <documentation>getter for derived attribute isStdCyclic</documentation>
    <target>www.ccpn.ac.uk_Fogh_2006-08-16-18:23:34_00033</target>
    <codeStubs>
      <item tag="java">java.util.Collection&lt;? extends ccp.api.molecule.Molecule.MolResLink&gt; molResLinks = getMolResLinks();
int maxDiff = getMolResidues().size() - 1;
int spareLinks = molResLinks.size() - maxDiff - 1;
for (ccp.api.molecule.Molecule.MolResLink molResLink: molResLinks) {
  java.util.Set&lt;ccp.api.molecule.Molecule.MolResLinkEnd&gt; molResLinkEnds = molResLink.getMolResLinkEnds();
  java.util.Iterator&lt;ccp.api.molecule.Molecule.MolResLinkEnd&gt; iter = molResLinkEnds.iterator();
  ccp.api.molecule.Molecule.MolResLinkEnd endA = iter.next();
  ccp.api.molecule.Molecule.MolResLinkEnd endB = iter.next();
  java.lang.String codeA = endA.getLinkCode();
  java.lang.String codeB = endB.getLinkCode();
  int diff = endA.getMolResidue().getSerial() - endB.getMolResidue().getSerial();
  if (!(((diff == -1) &amp;&amp; "next".equals(codeA) &amp;&amp; "prev".equals(codeB)) ||
        ((diff == 1) &amp;&amp; "next".equals(codeB) &amp;&amp; "prev".equals(codeA)) ||
        ((diff == maxDiff) &amp;&amp; "next".equals(codeA) &amp;&amp; "prev".equals(codeB)) ||
        ((diff == -maxDiff) &amp;&amp; "next".equals(codeB) &amp;&amp; "prev".equals(codeA))))
    spareLinks--;
}
if (spareLinks &lt; 0)
  result = false;
else
  result = true;</item>
      <item tag="python">molResLinks = self.molResLinks
maxDiff = len(self.molResidues)-1
spareLinks = len(molResLinks) - maxDiff -1

for molResLink in molResLinks:
  endA, endB = molResLink.molResLinkEnds
  codeA = endA.linkCode
  codeB = endB.linkCode
  diff = endA.molResidue.serial - endB.molResidue.serial
  if not ( (diff == -1 and codeA == 'next' and codeB == 'prev') or 
            (diff == 1 and codeB == 'next' and codeA == 'prev' ) or
            (diff == maxDiff and codeA == 'next' and codeB == 'prev') or 
            (diff == -maxDiff and codeB == 'next' and codeA == 'prev' ) ):
    spareLinks = spareLinks -1

if spareLinks &lt; 0:
  result = False
else:
  result = True</item>
    </codeStubs>
  </MetaOperation>

  <MetaOperation name="getIsStdLinear"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:34_00050"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00039"
   isAbstract="false" isImplicit="false" isQuery="true" opType="get"
   scope="instance_level" visibility="public_vis">
    <documentation>getter for derived attribute isStdLinear</documentation>
    <target>www.ccpn.ac.uk_Fogh_2006-08-16-18:23:34_00032</target>
    <codeStubs>
      <item tag="java">java.util.Collection&lt;? extends ccp.api.molecule.Molecule.MolResLink&gt; molResLinks = getMolResLinks();
int maxDiff = getMolResidues().size() - 1;
int spareLinks = molResLinks.size() - maxDiff;
for (ccp.api.molecule.Molecule.MolResLink molResLink: molResLinks) {
  java.util.Set&lt;ccp.api.molecule.Molecule.MolResLinkEnd&gt; molResLinkEnds = molResLink.getMolResLinkEnds();
  java.util.Iterator&lt;ccp.api.molecule.Molecule.MolResLinkEnd&gt; iter = molResLinkEnds.iterator();
  ccp.api.molecule.Molecule.MolResLinkEnd endA = iter.next();
  ccp.api.molecule.Molecule.MolResLinkEnd endB = iter.next();
  java.lang.String codeA = endA.getLinkCode();
  java.lang.String codeB = endB.getLinkCode();
  int diff = endA.getMolResidue().getSerial() - endB.getMolResidue().getSerial();
  if (!(((diff == -1) &amp;&amp; "next".equals(codeA) &amp;&amp; "prev".equals(codeB)) ||
        ((diff == 1) &amp;&amp; "next".equals(codeB) &amp;&amp; "prev".equals(codeA))))
    spareLinks--;
}
if (spareLinks &lt; 0)
  result = false;
else
  result = true;</item>
      <item tag="python">molResLinks = self.molResLinks
maxDiff = len(self.molResidues)-1
spareLinks = len(molResLinks) - maxDiff

for molResLink in molResLinks:
  endA, endB = molResLink.molResLinkEnds
  codeA = endA.linkCode
  codeB = endB.linkCode
  diff = endA.molResidue.serial - endB.molResidue.serial
  if not ( (diff == -1 and codeA == 'next' and codeB == 'prev') or 
            (diff == 1 and codeB == 'next' and codeA == 'prev' ) ):
    spareLinks = spareLinks -1

if spareLinks &lt; 0:
  result = False
else:
  result = True</item>
    </codeStubs>
  </MetaOperation>

  <MetaOperation name="getMolType"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:34_00034"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00039"
   isAbstract="false" isImplicit="false" isQuery="true" opType="get"
   scope="instance_level" visibility="public_vis">
    <documentation>Getter for derived attribute molType. Possible return values are 'protein', 'DNA', 'RNA', 'carbohydrate', or 'DNA/RNA'</documentation>
    <target>www.ccpn.ac.uk_Fogh_2006-08-16-18:23:34_00013</target>
    <codeStubs>
      <item tag="java">java.util.Set&lt;java.lang.String&gt; aset = new java.util.HashSet&lt;java.lang.String&gt;();
for (ccp.api.molecule.Molecule.MolResidue x: getMolResidues())
  aset.add(x.getChemComp().getMolType());

int nn = aset.size();
if (nn == 1)
  result = aset.iterator().next();
else if ((nn == 2) &amp;&amp; aset.contains("DNA") &amp;&amp; aset.contains("RNA"))
  result = "DNA/RNA";
else
  result = null;</item>
      <item tag="python">aset = set(x.chemComp for x in self.molResidues)
aset = set(x.molType for x in aset)
if len(aset) == 1:
  result = aset.pop()
elif aset == set(('DNA', 'RNA')):
  result = 'DNA/RNA'
else:
  result = None</item>
    </codeStubs>
  </MetaOperation>

  <MetaOperation name="getMolecularMass"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:34_00040"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00039"
   isAbstract="false" isImplicit="false" isQuery="true" opType="get"
   scope="instance_level" visibility="public_vis">
    <documentation>getter for derived attribute molecularMass</documentation>
    <target>www.ccpn.ac.uk_Fogh_2006-08-16-18:23:34_00020</target>
    <codeStubs>
      <item tag="java">// get formula dictionary 
java.util.Map&lt;java.lang.String, java.lang.Integer&gt; dd = new java.util.HashMap&lt;java.lang.String, java.lang.Integer&gt;();
for (ccp.api.molecule.Molecule.MolResidue mr: getMolResidues()) {
  for (ccp.api.molecule.ChemComp.AbstractChemAtom ca: mr.getChemComp().findFirstChemCompVar("linking", mr.getLinking(), "descriptor", mr.getDescriptor()).getChemAtoms()) {
    if (ca instanceof ccp.api.molecule.ChemComp.ChemAtom) {
      java.lang.String ss = ((ccp.api.molecule.ChemComp.ChemAtom) ca).getElementSymbol();
      java.lang.Integer ii = dd.get(ss);
      if (ii == null)
        dd.put(ss, 1);
      else
        dd.put(ss, ii+1);
    }
  }
}

// calculate mass
ccp.api.molecule.ChemElement.ChemElementStore xx = getRoot().getCurrentChemElementStore();
result = 0.0f;
for (java.lang.String ss: dd.keySet()) {
  java.lang.Integer ii = dd.get(ss);
  result += ii * xx.findFirstChemElement("symbol", ss).getMass();
}</item>
      <item tag="python"># get formula dictionary
dd = {}
clazz = ccp.api.molecule.ChemComp.ChemAtom

for mr in self.molResidues:
  for ss in (ca.elementSymbol for ca in mr.getByNavigation('chemComp', ('chemCompVars', (mr.linking, mr.descriptor)), 'chemAtoms') if isinstance(ca, clazz)):
    ii = dd.get(ss)
    if ii is None:
      dd[ss] = 1
    else:
      dd[ss] = ii + 1

# calculate mass
xx = self.root.currentChemElementStore
result = sum(ii * xx.findFirstChemElement(symbol=ss).mass for (ss, ii) in dd.iteritems())</item>
    </codeStubs>
  </MetaOperation>

  <MetaOperation name="getSeqLength"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:34_00036"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00039"
   isAbstract="false" isImplicit="false" isQuery="true" opType="get"
   scope="instance_level" visibility="public_vis">
    <documentation>Getter function for derived attribute seqLength.</documentation>
    <target>www.ccpn.ac.uk_Fogh_2006-08-16-18:23:34_00017</target>
    <codeStubs>
      <item tag="java">result = getMolResidues().size();</item>
      <item tag="python">result = len(self.molResidues)</item>
    </codeStubs>
  </MetaOperation>

  <MetaOperation name="getSeqString"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:34_00056"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00039"
   isAbstract="false" isImplicit="false" isQuery="true" opType="get"
   scope="instance_level" visibility="public_vis">
    <documentation>getter for derived attribute seqString</documentation>
    <target>www.ccpn.ac.uk_Fogh_2006-08-16-18:23:34_00028</target>
    <codeStubs>
      <item tag="java">java.util.List&lt;? extends ccp.api.molecule.Molecule.MolResidue&gt; ll = sortedMolResidues();
result = "";
if (!ll.isEmpty()) {
  java.lang.String molType = ll.get(0).getMolType();
  java.util.Map&lt;java.lang.String, java.lang.String&gt; mapDict = ccp.general.Constants.getCcpCodeToCode1LetterMap(molType);

  if ((mapDict != null) &amp;&amp; getIsStdLinear()) {
    int nn = ll.size();
    java.lang.StringBuffer output = new java.lang.StringBuffer(nn);

    boolean ok = true;
    for (ccp.api.molecule.Molecule.MolResidue molRes: ll) {
      if (!molType.equals(molRes.getMolType())) {
        ok = false;
        break;
      }

      String code = mapDict.get(molRes.getCcpCode());
      if (code == null)
        code = "*";
      output.append(code);
    }

    if (ok)
      result = output.toString();
  }
}</item>
      <item tag="python">ll = self.sortedMolResidues()
result = ''
if ll:
  
  from ccp.general.Constants import ccpCodeToCode1LetterDict
  molType = ll[0].molType
  mapDict = ccpCodeToCode1LetterDict.get(molType)
  
  if mapDict is not None and self.isStdLinear:
    output = [None] * len(ll)
    ii = -1

    for rr in ll:
      if rr.molType != molType:
        break
      
      ii = ii + 1
      output[ii] = mapDict.get(rr.ccpCode,'*')

    else:
      result = ''.join(output)</item>
    </codeStubs>
  </MetaOperation>

  <MetaOperation name="getStdSeqString"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:34_00058"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00039"
   isAbstract="false" isImplicit="false" isQuery="true" opType="get"
   scope="instance_level" visibility="public_vis">
    <documentation>getter for serived attribute stdSeqString</documentation>
    <target>www.ccpn.ac.uk_Fogh_2006-08-16-18:23:34_00029</target>
    <codeStubs>
      <item tag="java">java.util.List&lt;? extends ccp.api.molecule.Molecule.MolResidue&gt; ll = sortedMolResidues();
result = "";
if (!ll.isEmpty()) {
  java.lang.String molType = ll.get(0).getMolType();
  java.util.Map&lt;java.lang.String, java.lang.String&gt; mapDict = ccp.general.Constants.getCcpCodeToCode1LetterMap(molType);

  if ((mapDict != null) &amp;&amp; getIsStdLinear()) {
    int nn = ll.size();
    java.lang.StringBuffer output = new java.lang.StringBuffer(nn);

    boolean ok = true;
    for (ccp.api.molecule.Molecule.MolResidue molRes: ll) {
      if (!molType.equals(molRes.getMolType())) {
        ok = false;
        break;
      }

      String code = mapDict.get(molRes.getCcpCode());
      if (code == null) {
        code = molRes.getChemComp().getCode1Letter();
        if ((code == null) || (code.length() == 0))
          code = "*";
      }
      output.append(code);
    }

    if (ok)
      result = output.toString();
  }
}</item>
      <item tag="python">ll = self.sortedMolResidues()
result = ''
if ll:
  
  from ccp.general.Constants import ccpCodeToCode1LetterDict
  
  molType = ll[0].molType
  mapDict = ccpCodeToCode1LetterDict.get(molType)
  if mapDict is not None and self.isStdLinear:

    output = [None] * len(ll)
    ii = -1

    for rr in ll:
      if rr.molType != molType:
        break
      
      ii = ii + 1
      output[ii] = mapDict.get(rr.ccpCode) or rr.chemComp.code1Letter or '*'

    else:
      result = ''.join(output)</item>
    </codeStubs>
  </MetaOperation>

  <MetaAttribute name="hasNonStdChemComp"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:34_00030"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00039"
   baseName="hasNonStdChemComp" changeability="frozen" hicard="1"
   isAbstract="false" isAutomatic="false" isDerived="true"
   isImplementation="false" isImplicit="false" isOrdered="false" isUnique="true"
   locard="1" scope="instance_level" visibility="public_vis">
    <documentation>Does molecule contain non-standard ChemComp? Note that this will be true whenever the molecule does not consist entirely of StdChemComps. Since only molTypes protein, DNA, and RNA have any StdChemComps at all, this attribute will be True but meaningless for any Molecule that contains ChemComps of other types.</documentation>
    <valueType>www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00028</valueType>
  </MetaAttribute>

  <MetaAttribute name="hasNonStdChirality"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:34_00031"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00039"
   baseName="hasNonStdChirality" changeability="frozen" hicard="1"
   isAbstract="false" isAutomatic="false" isDerived="true"
   isImplementation="false" isImplicit="false" isOrdered="false" isUnique="true"
   locard="0" scope="instance_level" visibility="public_vis">
    <documentation>Does molecule contain ChemComp of non-standard chirality? Note that this will be true also when the Molecule contains a ChemComp where no StdChirality is defined.</documentation>
    <valueType>www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00028</valueType>
  </MetaAttribute>

  <MetaAttribute name="isAromatic"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:34_00022"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00039"
   baseName="isAromatic" changeability="frozen" hicard="1" isAbstract="false"
   isAutomatic="false" isDerived="true" isImplementation="false"
   isImplicit="false" isOrdered="false" isUnique="true" locard="1"
   scope="instance_level" visibility="public_vis">
    <documentation>Does molecule contain aromatic groups?</documentation>
    <valueType>www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00028</valueType>
  </MetaAttribute>

  <MetaAttribute name="isFinalised"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:34_00012"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00039"
   baseName="isFinalised" changeability="changeable" hicard="1"
   isAbstract="false" isAutomatic="false" isDerived="false"
   isImplementation="false" isImplicit="false" isOrdered="false" isUnique="true"
   locard="1" scope="instance_level" visibility="public_vis">
    <documentation>Non-finalised molecules may not have links to Samples etc.
Finalised molecules can no longer have residues added or removed.
Note that you can add MolResidues to non-finalised molecules even if they already have chanis, but that you must make sure of adding new MolSystem.Residues as necessary.</documentation>
    <valueType>www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00028</valueType>
    <defaultValue>
      <item>false</item>
    </defaultValue>
  </MetaAttribute>

  <MetaAttribute name="isParamagnetic"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:34_00023"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00039"
   baseName="isParamagnetic" changeability="frozen" hicard="1"
   isAbstract="false" isAutomatic="false" isDerived="true"
   isImplementation="false" isImplicit="false" isOrdered="false" isUnique="true"
   locard="1" scope="instance_level" visibility="public_vis">
    <documentation>Does Molecule contain paramagnetic groups?</documentation>
    <valueType>www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00028</valueType>
  </MetaAttribute>

  <MetaAttribute name="isStdCyclic"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:34_00033"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00039"
   baseName="isStdCyclic" changeability="frozen" hicard="1" isAbstract="false"
   isAutomatic="false" isDerived="true" isImplementation="false"
   isImplicit="false" isOrdered="false" isUnique="true" locard="0"
   scope="instance_level" visibility="public_vis">
    <documentation>Is Molecule a Std Cyclic polymer, i.e. a Std Linear polymer with a polymer-type link between the last and the first residue?</documentation>
    <valueType>www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00028</valueType>
  </MetaAttribute>

  <MetaAttribute name="isStdLinear"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:34_00032"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00039"
   baseName="isStdLinear" changeability="frozen" hicard="1" isAbstract="false"
   isAutomatic="false" isDerived="true" isImplementation="false"
   isImplicit="false" isOrdered="false" isUnique="true" locard="1"
   scope="instance_level" visibility="public_vis">
    <documentation>Is the molecule a standard linear polymer? A linear polymer must contain a linear sequence where MolResidues with successive serials are linked by linear polymer type links  (linkCodes 'next' and 'prev'). 

Linear polymers may be heavily crosslinked but all the sequential links must be present and of  the correct type. The component MolResidues may be of any type or a mixture of types (peptide, nucleotide, styrene monomers, ...) provided the 'next' and/or 'prev' links are present.
The following are not linear polymers:
- A strand of DNA with a break in the middle of the sequence numbering, even if the strand is circular.
- A protein with one peptide bond replaced by a bond going through an Aspartate side chain COOH. 
- A glycoprotein. 
- A linear polysaccharide.</documentation>
    <valueType>www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00028</valueType>
  </MetaAttribute>

  <MetaAttribute name="keywords"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:34_00015"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00039"
   baseName="keyword" changeability="changeable" hicard="-1" isAbstract="false"
   isAutomatic="false" isDerived="false" isImplementation="false"
   isImplicit="false" isOrdered="true" isUnique="false" locard="0"
   scope="instance_level" visibility="public_vis">
    <documentation>Keywords for searching molecule. e.g. 'DNA binding', 'receptor', 'Zinc finger'...</documentation>
    <valueType>www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00033</valueType>
  </MetaAttribute>

  <MetaAttribute name="longName"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:34_00011"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00039"
   baseName="longName" changeability="changeable" hicard="1" isAbstract="false"
   isAutomatic="false" isDerived="false" isImplementation="false"
   isImplicit="false" isOrdered="false" isUnique="true" locard="0"
   scope="instance_level" visibility="public_vis">
    <documentation>Long form of molecule name.</documentation>
    <valueType>www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00036</valueType>
  </MetaAttribute>

  <MetaRole name="molecules"
   guid="ccpn_automatic_memops.Implementation.MemopsRoot.molecule"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00047"
   baseName="molecule" changeability="changeable" hicard="-1" hierarchy="child"
   isAbstract="false" isAutomatic="false" isDerived="false"
   isImplementation="false" isImplicit="false" isOrdered="false" isUnique="true"
   locard="0" noDeleteIfSet="false" partitionsChildren="false"
   scope="instance_level" visibility="public_vis">
    <documentation>child link</documentation>
    <otherRole>ccpn_automatic_ccp.molecule.Molecule.Molecule.memopsRoot</otherRole>
    <valueType>www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00039</valueType>
  </MetaRole>

  <MetaRole name="memopsRoot"
   guid="ccpn_automatic_ccp.molecule.Molecule.Molecule.memopsRoot"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00039"
   aggregation="composite" baseName="memopsRoot" changeability="frozen"
   hicard="1" hierarchy="parent" isAbstract="false" isAutomatic="false"
   isDerived="false" isImplementation="false" isImplicit="false"
   isOrdered="false" isUnique="true" locard="1" noDeleteIfSet="false"
   partitionsChildren="false" scope="instance_level" visibility="public_vis">
    <documentation>parent link</documentation>
    <otherRole>ccpn_automatic_memops.Implementation.MemopsRoot.molecule</otherRole>
    <valueType>www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00047</valueType>
  </MetaRole>

  <MetaRole name="molResLinks"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:34_00007"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00039"
   baseName="molResLink" changeability="changeable" hicard="-1"
   hierarchy="child" isAbstract="false" isAutomatic="false" isDerived="false"
   isImplementation="false" isImplicit="false" isOrdered="false" isUnique="true"
   locard="0" noDeleteIfSet="false" partitionsChildren="false"
   scope="instance_level" visibility="public_vis">
    <otherRole>www.ccpn.ac.uk_Fogh_2006-08-16-18:23:34_00006</otherRole>
    <valueType>www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00049</valueType>
  </MetaRole>

  <MetaRole name="molResidues"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:33_00047"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00039"
   baseName="molResidue" changeability="changeable" hicard="-1"
   hierarchy="child" isAbstract="false" isAutomatic="false" isDerived="false"
   isImplementation="false" isImplicit="false" isOrdered="false" isUnique="true"
   locard="0" noDeleteIfSet="false" partitionsChildren="false"
   scope="instance_level" visibility="public_vis">
    <otherRole>www.ccpn.ac.uk_Fogh_2006-08-16-18:23:33_00046</otherRole>
    <valueType>www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00044</valueType>
  </MetaRole>

  <MetaRole name="molSeqFragments"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:34_00009"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00039"
   baseName="molSeqFragment" changeability="changeable" hicard="-1"
   hierarchy="child" isAbstract="false" isAutomatic="false" isDerived="false"
   isImplementation="false" isImplicit="false" isOrdered="false" isUnique="true"
   locard="0" noDeleteIfSet="false" partitionsChildren="false"
   scope="instance_level" visibility="public_vis">
    <otherRole>www.ccpn.ac.uk_Fogh_2006-08-16-18:23:34_00008</otherRole>
    <valueType>www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00045</valueType>
  </MetaRole>

  <MetaAttribute name="molType"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:34_00013"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00039"
   baseName="molType" changeability="frozen" hicard="1" isAbstract="false"
   isAutomatic="false" isDerived="true" isImplementation="false"
   isImplicit="false" isOrdered="false" isUnique="true" locard="0"
   scope="instance_level" visibility="public_vis">
    <documentation>molType of ChemComps making up Molecule. Possible values: 'protein', 'DNA', 'RNA', 'DNA/RNA', 'other'. The values are returned if *all* ChemComps are of the correct molType(s). 'other' is returned if the Molecule contains neither protein, not DNA, nor RNA ChemComps. If the Molecule contains a mixture of molTypes (except for DNA/RNA) the value is None (not set). 

Note that the molType says nothing about how the ChemComps are linked, and that e.g. a Molecule of molType 'protein' need not contain a single peptide bond. If e.g. molType is 'protein' and isStdLinear' is True, on the other hand, the Molecule is a single unbroken polypeptide (which may or may not contain crosslinks).</documentation>
    <valueType>www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00055</valueType>
  </MetaAttribute>

  <MetaAttribute name="molecularMass"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:34_00020"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00039"
   baseName="molecularMass" changeability="frozen" hicard="1" isAbstract="false"
   isAutomatic="false" isDerived="true" isImplementation="false"
   isImplicit="false" isOrdered="false" isUnique="true" locard="1"
   scope="instance_level" visibility="public_vis">
    <documentation>Molecular mass, in atomic units. This is the sum of the atomic weights of the atoms that form this molecule.</documentation>
    <valueType>www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00031</valueType>
  </MetaAttribute>

  <MetaRole name="moleculeSysNames"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:33_00049"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00039"
   baseName="moleculeSysName" changeability="changeable" hicard="-1"
   hierarchy="child" isAbstract="false" isAutomatic="false" isDerived="false"
   isImplementation="false" isImplicit="false" isOrdered="false" isUnique="true"
   locard="0" noDeleteIfSet="false" partitionsChildren="false"
   scope="instance_level" visibility="public_vis">
    <otherRole>www.ccpn.ac.uk_Fogh_2006-08-16-18:23:33_00048</otherRole>
    <valueType>www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00043</valueType>
  </MetaRole>

  <MetaAttribute name="name"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:34_00010"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00039"
   baseName="name" changeability="frozen" hicard="1" isAbstract="false"
   isAutomatic="false" isDerived="false" isImplementation="false"
   isImplicit="false" isOrdered="false" isUnique="true" locard="1"
   scope="instance_level" visibility="public_vis">
    <documentation>Name of Molecule. Used as key. Should be correct and informative, but may be an abbreviation or an acronym if the alternative is too long. Recommended e.g. NaCl, Lysozyme, Lac headpiece, morphine.</documentation>
    <valueType>www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00033</valueType>
  </MetaAttribute>

  <MetaRole name="molecules"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:34_00001"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-18:19:50_00003"
   baseName="molecule" changeability="changeable" hicard="-1" isAbstract="false"
   isAutomatic="false" isDerived="false" isImplementation="false"
   isImplicit="false" isOrdered="false" isUnique="true" locard="0"
   noDeleteIfSet="false" partitionsChildren="false" scope="instance_level"
   visibility="public_vis">
    <documentation>Molecules from natural source.</documentation>
    <otherRole>www.ccpn.ac.uk_Fogh_2006-08-16-18:23:34_00002</otherRole>
    <valueType>www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00039</valueType>
  </MetaRole>

  <MetaRole name="naturalSource"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:34_00002"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00039"
   baseName="naturalSource" changeability="changeable" hicard="1"
   isAbstract="false" isAutomatic="false" isDerived="false"
   isImplementation="false" isImplicit="false" isOrdered="false" isUnique="true"
   locard="0" noDeleteIfSet="false" partitionsChildren="false"
   scope="instance_level" visibility="public_vis">
    <documentation>Natural source for molecule</documentation>
    <otherRole>www.ccpn.ac.uk_Fogh_2006-08-16-18:23:34_00001</otherRole>
    <valueType>www.ccpn.ac.uk_Fogh_2006-08-16-18:19:50_00003</valueType>
  </MetaRole>

  <MetaAttribute name="seqDetails"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:34_00027"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00039"
   baseName="seqDetails" changeability="changeable" hicard="1"
   isAbstract="false" isAutomatic="false" isDerived="false"
   isImplementation="false" isImplicit="false" isOrdered="false" isUnique="true"
   locard="0" scope="instance_level" visibility="public_vis">
    <documentation>Details, notes, comments etc. about the sequence.</documentation>
    <valueType>www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00036</valueType>
  </MetaAttribute>

  <MetaAttribute name="seqLength"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:34_00017"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00039"
   baseName="seqLength" changeability="frozen" hicard="1" isAbstract="false"
   isAutomatic="false" isDerived="true" isImplementation="false"
   isImplicit="false" isOrdered="false" isUnique="true" locard="1"
   scope="instance_level" visibility="public_vis">
    <documentation>Number of MolResidues in Molecule. For linear polymers equal to sequence length.</documentation>
    <valueType>www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00032</valueType>
  </MetaAttribute>

  <MetaAttribute name="seqString"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:34_00028"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00039"
   baseName="seqString" changeability="frozen" hicard="1" isAbstract="false"
   isAutomatic="false" isDerived="true" isImplementation="false"
   isImplicit="false" isOrdered="false" isUnique="true" locard="0"
   scope="instance_level" visibility="public_vis">
    <documentation>String holding sequence one-letter-codes with '*' for non-standard residues. The attribute is always defined, but is equal to the empty string except for linear polymers of defined molType. Note that one-letter codes are only defined for std ChemComps, which are only found for peptides and nucleotides, so the value for linear polymers of type 'other' is likely to be meaningless. </documentation>
    <valueType>www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00035</valueType>
  </MetaAttribute>

  <MetaAttribute name="smiles"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:34_00024"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00039"
   baseName="smiles" changeability="changeable" hicard="1" isAbstract="false"
   isAutomatic="false" isDerived="false" isImplementation="false"
   isImplicit="false" isOrdered="false" isUnique="true" locard="0"
   scope="instance_level" visibility="public_vis">
    <documentation>SMILES (Simplified Molecular Input Line Entry Specification) string describing molecule. </documentation>
    <valueType>www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00035</valueType>
  </MetaAttribute>

  <MetaAttribute name="smilesType"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:34_00025"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00039"
   baseName="smilesType" changeability="changeable" hicard="1"
   isAbstract="false" isAutomatic="false" isDerived="false"
   isImplementation="false" isImplicit="false" isOrdered="false" isUnique="true"
   locard="0" scope="instance_level" visibility="public_vis">
    <documentation>Type of Smiles string in smiles attribute</documentation>
    <valueType>www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00051</valueType>
  </MetaAttribute>

  <MetaAttribute name="stdSeqString"
   guid="www.ccpn.ac.uk_Fogh_2006-08-16-18:23:34_00029"
   container="www.ccpn.ac.uk_Fogh_2006-08-16-14:22:54_00039"
   baseName="stdSeqString" changeability="frozen" hicard="1" isAbstract="false"
   isAutomatic="false" isDerived="true" isImplementation="false"
   isImplicit="false" isOrdered="false" isUnique="true" locard="0"
   scope="instance_level" visibility="public_vis">
    <documentation>String holding sequence one-letter-codes with non-standard ChemComps replaced by one-letter-code of corresponding standard derivative, or by '*' if there is no standard derivative.
 The attribute is always defined, but is equal to the empty string except for linear polymers of defined molType. Note that one-letter codes are only defined for std ChemComps, which are only found for peptides and nucleotides, so the value for linear polymers of type 'other' is likely to be meaningless. </documentation>
    <valueType>www.ccpn.ac.uk_Fogh_2006-08-16-14:22:53_00035</valueType>
  </MetaAttribute>
</MetaClass>

